{"meta":{"title":"HoshI-blog","subtitle":null,"description":null,"author":"HoshIlIlI","url":"https://enderhoshi.github.io","root":"/"},"pages":[{"title":"HoShI's Blog","date":"2020-07-06T11:48:11.000Z","updated":"2025-07-09T09:33:16.190Z","comments":false,"path":"about/index.html","permalink":"https://enderhoshi.github.io/about/index.html","excerpt":"","text":"这是一个 Android 菜鸟的个人博客，记录一些开发中的坑、学习中的笔记、编码中的琐事 我见识浅薄，文笔拙劣，如有错漏，请大佬们不吝赐教"}],"posts":[{"title":"git merge 后产生重复提交的原因","slug":"git merge 后产生重复提交的原因","date":"2025-07-09T07:52:33.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2025/07/09/git merge 后产生重复提交的原因/","link":"","permalink":"https://enderhoshi.github.io/2025/07/09/git%20merge%20%E5%90%8E%E4%BA%A7%E7%94%9F%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"今天同事打算对散乱的分支进行合并，处理完成后，我 fetch 之后看了一下，发现 git 分支图上，产生了重复的提交，而且作者栏里面，我的名称后多了一个星号 这种情况之前也发生过，我有时候合并完也会出现这样的情形，这对功能并没有多大影响，但是让分支图显得不太好看。另外如果后续有回退代码的需求时，存在内容、作者都相同的两个提交，也需要我们对其进行甄别，到底回退到哪个才是正确的，因为它们虽然内容相同，但是它们的前后提交有可能是不同的 为什么会出现经过一些排查，还是没搞清楚为什么会出现这种情况，比较接近的答案是：上游分支和本地分支有冲突，或者存在提交历史的不同，可能会出现将提交历史重新应用到上游分支的过程中，会将本地分支的每个提交都应用一次 出现如何处理最好配合 git reflog 以及 git reset 进行重置，然后看看哪里出了问题，灵活运用 git rebase，不要一味 merge 如何避免下次出现一般正常使用不会出现，需要再研究下出现条件再避免，平时使用时要注意下面几点： 不要直接将 develop 分支合并到 develop 的子分支上 要根据实际情况，利用好 git rebase","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"git","slug":"git","permalink":"https://enderhoshi.github.io/tags/git/"}]},{"title":"记一次 Android 15 适配","slug":"记一次 Android 15 适配","date":"2025-03-13T08:38:33.000Z","updated":"2025-07-09T09:33:16.190Z","comments":true,"path":"2025/03/13/记一次 Android 15 适配/","link":"","permalink":"https://enderhoshi.github.io/2025/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Android%2015%20%E9%80%82%E9%85%8D/","excerpt":"记录一次将 targetSdkVersion 从 31 提升到 35 的过程","text":"公司有个项目一直没有维护，Google Play 上收到用户投诉，提示目标版本过低，无法安装，于是需要进行一次适配，这里详尽记录一下经过 很多年前写过一篇 Android 9、10 的适配记录，但是过于凌乱，那时候基础也差，基本是搜到什么就粘贴进项目里，能跑起来就完事了（其实现在也差不多）。后面有一些开发笔记用于记录适配相关的事项，但是好像又比较零散，想着还是以记录完整经过的模式来写，写时候比较舒服，读起来也更通顺 项目背景1234targetSdkVersion = 31AGP Version = 7.0.4Gradle Version = 7.0.2Kotlin Version = 1.6.21 提升相关版本最基础的一步是提升 targetSdkVersion，然后直接运行，发现报错提示还需要提升 AGP 版本，这里提升到 8.7.3 这个 AGP 版本指的是 Android Gradle 插件版本（Android Gradle Plugin），该插件版本适用于在相应 Android Studio 项目中构建的所有模块，可以在以下几个地方指定： Android Studio 的 File &gt; Project Structure &gt; Project 菜单中指定插件版本 在顶级 build.gradle.kts 文件中指定 123plugins &#123; id(&quot;com.android.application&quot;) version &quot;8.7.3&quot; apply false&#125; 使用 build.gradle 的话，指的是 classpath ‘com.android.tools.build:gradle:8.7.3’ 这个 12345buildscript &#123; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:8.7.3&#x27; &#125;&#125; 提升 AGP 版本后，对应的，Gradle 版本要提升到 8.9，JDK 需要升级至 17 以上 后续因为 reverse() 方法的问题，提升了 Kotlin 版本到 1.9.22，又因为在 Kotlin 版本大于 1.7 时，Room 库 2.4.3 以下版本下无法识别挂起函数，编译报错，再把 Room 库提升到最新版本 2.6.1 后，又报如下问题 12D:\\WorkSpace\\cpp-0914\\common\\build\\tmp\\kapt3\\stubs\\domesticDebug\\com\\ddpai\\common\\database\\dao\\VVideoDao.java:16: 错误: Methods annotated with [@Insert, @Upsert, @Update, @Delete] shouldn&#x27;t declare nullable parameters (com.ddpai.common.database.entities.VVideo[]). com.ddpai.common.database.entities.VVideo[] item, @org.jetbrains.annotations.NotNull() 意思是这几个注解下不能用可空的类型，需要改成非空类型，好办，改完再运行下，无问题了 参考文章 解决 Kotlin 升级 1.7 以上版本时 Room 库报错的问题 模块级别的 build.gradle 改动这里的 build.gradle 指的是除了顶级 build.gradle 之外的 build.gradle，需要做以下改动 namespace每个模块下的 build.gradle 都需要声明一个 namespace（下列代码举例子为了方便所以写到一起了，事实是分开的），新建项目会自带 123456789android &#123; namespace = &quot;com.hoshi.test&quot; // 这个是 test 模块&#125;android &#123; namespace = &quot;com.hoshi.common&quot; // 这个是 common 模块&#125;android &#123; namespace = &quot;com.hoshi.platform&quot; // 这个是 platform 模块&#125; 这个东东是干嘛的呢？为什么另一个项目不需要？待研究后补充，现在已知的是新增了这个之后，会导致你以前的 R 文件引用产生变化 以前假设你在 test 模块下写代码，test 模块引用 common 模块，你只 import com.hoshi.test.R，就既可以使用 test 模块的资源，又可以使用 common 模块的资源 但是现在不一样了，你 import com.hoshi.test.R 只能使用 test 模块的资源，如果你想用 common 的资源，你就需要在资源文件前加上完整包名，如 context.getString(com.hoshi.common.R.string.common_today) 增加了 namespace 后，AndroidManifest 里面的 package=&quot;com.hoshi.test&quot; 就可以删掉了 zipAlignEnabledzipAlignEnabled 废弃，不再需要声明，删掉代码即可，直接是自动默认为开的 buildConfig新版本 AGP，默认关闭 buildConfig，会导致你的 BuildConfig.xxxxx 全部出现异常，需要作如下配置 12345android &#123; buildFeatures &#123; buildConfig = true // 配置开启 buildConfig 构建特性，新版本 AGP 需要配置 &#125;&#125; 其他写法调整1234flavorDimensions &#x27;isOverseas&#x27;// flavor 配置的写法调整，上面是旧版的，改为下面这样flavorDimensions = [&quot;isOverseas&quot;] 这种调整经常会有，如果遇到可以往类似方向调整，或者直接搜一下如何解决 存储权限适配targetSdkVersion 大于等于 33，并且运行在 Android 13 的手机上时，通过代码判断是否拥有 READ_EXTERNAL_STORAGE 权限，一定返回 false XXPermissions 库不再允许申请 READ_EXTERNAL_STORAGE 权限（会直接闪退并告知原因是申请 READ_EXTERNAL_STORAGE），而 ActivityResultLauncher 库中，取图片、视频的 PickContentLauncher 会判断是否拥有 READ_EXTERNAL_STORAGE 权限，所以需要做一下适配 首先彻底移除自己项目中所有的 READ_EXTERNAL_STORAGE，使用 READ_MEDIA_IMAGES、READ_MEDIA_VIDEO、READ_MEDIA_AUDIO 替代，然后把 PickContentLauncher 单独取出来，进行如下修改 123456789101112131415// 当当前手机版本为 Android 13，并且 targetSdkVersion 为 33 时// 根据文件类型分别取得 READ_MEDIA_IMAGES 和 READ_MEDIA_VIDEO// 低版本下一律取 READ_EXTERNAL_STORAGEval applicationInfo = AppState.getApplicationContext().applicationInfoval permissionStr = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU &amp;&amp; applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.TIRAMISU) &#123; if (input == &quot;image/*&quot;) &#123; Manifest.permission.READ_MEDIA_IMAGES &#125; else &#123; Manifest.permission.READ_MEDIA_VIDEO &#125;&#125; else &#123; Manifest.permission.READ_EXTERNAL_STORAGE&#125; 最后找一下用到原 PickContentLauncher 类的地方，将其替换成自己魔改过的 PickContentLauncher 类 MQTT 相关调整因为以下众多原因，需要对 MQTT 库进行一些魔改 SCHEDULE_EXACT_ALARM 权限需要和 Google 官方说明申请原因，还要拍摄录像告知使用场景，最好移除掉 前台 service 需要声明 android:foregroundServiceType 动态广播接收器必须指定导出的行为，也就是 registerReceiver 方法要加一个 flag 说明是 RECEIVER_EXPORTED 还是 RECEIVER_NOT_EXPORTED Github 上有挺多方案，甚至还有 Kotlin 版本的，现在追求改动最小，所以沿用了这个方案。这个方案将之前官方 MQTT 用到的 AlarmManager 直接用 Worker 替换掉，且也做了 2、3 两点的适配，十分符合此次适配的需求 隐式 Intent 和 PendingIntent 的限制官方的说法是，要启动非导出活动，应用程序应使用显式意图，具体可以直接看我之前写过的文章中的某段 —— Android 14 适配 Intent 相关 这个不难，如果自己写有统一的跳转方法的话，直接给 intent 加上 packageName 即可，这里需要特别注意的就是，第三方库里面的跳转如果没有加上 packageName 就会导致闪退，我这里又是 ActivityResultLauncher 库里面的跳转导致的，只能说开源不易，不能怪人，自己发现后及时修改即可 Edge to Edge 适配，沉浸式的新方案之前一直用 ImmersionBar 库来做沉浸式，提升到 Android 15 后，发现在某些页面中，状态栏和应用顶部的控件又重叠了，好家伙全都白搞了，又要一轮全新的适配。虽然官方告知可以在 theme 中声明 &lt;item name=&quot;android:windowOptOutEdgeToEdgeEnforcement&quot;&gt;true&lt;/item&gt; 来暂时规避，但是 Android 16 明确说了会废弃并停用这个选项，躲得了初一躲不过十五，还是乖乖适配好了 首先把 ImmersiveBar 相关的解决布局与状态栏重叠问题的代码（比如 ImmersionBar.fitsSystemWindows() 这些）移除掉，避免重复处理，然后写相关的 View 扩展代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Android 15 Edge to Edge 适配 * @receiver View */fun View.statusPaddingEdge() &#123; val layoutParams = this.layoutParams // 首先取得 LayoutParams var oldHeight = layoutParams.height // 然后先用 LayoutParams 取得控件的高 var isMatchParent = false if (oldHeight == ViewGroup.LayoutParams.MATCH_PARENT) &#123; isMatchParent = true &#125; else if (oldHeight == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; // 如果是 MATCH_PARENT 或者 WRAP_CONTENT，要再测量取实际高度 val width = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED) val height = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED) this.measure(width, height) oldHeight = this.measuredHeight // 然后先在外部取得控件的高，放在监听里面可能会多次回调导致高度累加，显示异常 &#125; if (oldHeight &lt;= 0 &amp;&amp; (oldHeight != ViewGroup.LayoutParams.MATCH_PARENT)) &#123; VLog.e(&quot;statusPaddingEdge&quot;, &quot;取得控件的高小于 0，且不是 MATCH_PARENT，不正确，请检查，对应控件：&quot; + this.javaClass.name) return &#125; ViewCompat.setOnApplyWindowInsetsListener(this) &#123; v, insets -&gt; val statusBars = insets.getInsets(WindowInsetsCompat.Type.statusBars()) val statusBarsTop = statusBars.top if (!isMatchParent) &#123; layoutParams.height = oldHeight + statusBarsTop // 如果不是 MATCH_PARENT，整个 View 要增高 &#125; v.layoutParams = layoutParams v.setPadding(statusBars.left, statusBarsTop, statusBars.right, statusBars.bottom) // VLog.e(&quot;statusPaddingEdge&quot;, &quot;statusBars = $statusBars, oldHeight = $oldHeight&quot;) insets &#125;&#125;// 在实际使用过程中，有一些界面/控件不会触发 setOnApplyWindowInsetsListener 里面的 OnApplyWindowInsetsListener，这时候就用下面这个老方法来处理/** * 增加 View 的上内边距, 增加高度为状态栏高度, 防止视图和状态栏重叠 * 如果是 RelativeLayout 设置 padding 值会导致 centerInParent 等属性无法正常显示 * * !----注意----! 这个方法在某些手机（目前发现荣耀 magic3）的横屏界面上会出问题，表现为顶部多出一段间距 * 可以尝试采用其它沉浸式方法处理，如 statusPaddingEdge、ImmersionBar * * @param remove true: paddingTop = 状态栏高度 * false: paddingTop = 0 */@JvmOverloadsfun View.statusPadding(remove: Boolean = false) &#123; if (this is RelativeLayout) &#123; throw UnsupportedOperationException(&quot;Unsupported set statusPadding for RelativeLayout&quot;) &#125; val statusBarHeight = context.statusBarHeight val lp = layoutParams if (remove) &#123; if (paddingTop &lt; statusBarHeight) return if (lp != null &amp;&amp; lp.height &gt; 0) &#123; lp.height -= statusBarHeight // 减高 &#125; setPadding( paddingLeft, paddingTop - statusBarHeight, paddingRight, paddingBottom ) &#125; else &#123; if (paddingTop &gt;= statusBarHeight) return if (lp != null &amp;&amp; lp.height &gt; 0) &#123; lp.height += statusBarHeight // 增高 &#125; setPadding( paddingLeft, paddingTop + statusBarHeight, paddingRight, paddingBottom ) &#125;&#125; 在状态栏和控件重叠的页面，让重叠的控件调用上面代码即可 参考文章 Android 15 新特性，强制 edge-to-edge 全面屏体验 无边框设计停用退出选项 _Collection.reversed() 扩展方法闪退问题报错如下 1java.lang.NoSuchMethodError: No interface method reversed()Ljava/util/List; in class Ljava/util/List; or its super classes (declaration of &#x27;java.util.List&#x27; appears in /apex/com.android.runtime/javalib/core-oj.jar) 这里报错的是集合类的扩展方法 reversed()，以前用得好好的，突然就不行了，感觉可能也和 APG 版本、JDK 版本有关。我这里直接替换为 asReversed() 即可，下面说下它们之间有什么不同 简单概括就是：两个类都会返回一个 List，改变 list.reversed() 返回的 List 中的元素，不会影响到原 List，而改变 list.asReversed() 返回的 List 中的元素，会影响到原 List 后来想到还是要看看为什么突然就不行了，留意到我的 Kotlin 版本是 1.6.21，看了下扩展方法里面的具体实现，处于位置 kotlin-stdlib-common-1.6.21-sources.jar!\\generated_Collections.kt，代码如下 1public expect fun &lt;T&gt; MutableList&lt;T&gt;.reverse(): Unit 这里的这个 expect 关键字是用于跨平台的，这里用 expect 声明了方法之后，其他平台再使用对应的 actual 关键字实现对应的方法，每个目标平台（如 JVM、JS、Native 等）都可以有自己的 actual 实现 那么可以猜测，应该是提升了 JDK 版本为 17 后，对应的 Native 实现没有实现到这个方法了，所以导致报错，于是升级 Kotlin 版本试试，发现升级后，reverse 扩展方法位置变了，在 _CollectionsJVM.kt 里面，且代码变为如下 123public actual fun &lt;T&gt; MutableList&lt;T&gt;.reverse(): Unit &#123; java.util.Collections.reverse(this)&#125; 看起来是个 actual 方法，有实现了，应该可行了，编译运行，执行相关的方法，没有报错了 参考文章 Kotlin 中 expect 和 actual 关键字修饰的函数作用 asReversed() vs reversed() in Kotlin? R8 混淆相关上面的步骤都处理完了，提交代码，进行远程打包，直接报错 123app:minifyReleaseWithR8 FAILEDMissing classes detected while running R8. Please add the missing classes or apply additional keep rules that are generated in D:\\WorkSpace\\myApp\\app\\build\\outputs\\mapping\\domesticRelease\\missing_rules.txt. 打开提示中的对应目录，有如下内容，说明我们缺少了这些，需要加上。这里的 -dontwarn 是关闭警告的意思，为什么需要加上这些，具体原理不明，估计是 JDK 版本提升后，R8 的一些相关配置改变了 1234-dontwarn com.google.android.exoplayer2.decoder.OutputBuffer$Owner-dontwarn com.google.android.exoplayer2.decoder.OutputBuffer-dontwarn com.google.android.exoplayer2.decoder.SimpleOutputBuffer-dontwarn com.google.android.exoplayer2.drm.ExoMediaCrypto 复制粘贴到 proguard-rules.pro 中，再上传打包，这次没问题了，打包 apk 成功，但是安装好后一运行就闪退了，好好好，再看闪退日志 123java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast Student// 另外还有一些关于 ParameterizedType 的问题，这里没有记录到就不贴了，大致是说取不到具体泛型类型，只能取到一个 Class 之类的// 因为我这个项目的 ViewBinding 是用反射的方式来处理的，所以还有一些 ViewBinding 工具无法取到泛型产生的报错 搜索资料得知，如果使用了 R8 混淆，JDK 17 默认会开启 R8 fullMode 混淆模式，完整模式下，对于没有 keep 的类，将会擦除泛型信息。而我的项目中 ViewBinding 是用反射的方式在基类中处理的，并且使用了类似于 BaseResponse&lt;T&gt; 的类，有自定义解析器，所以精准踩中了这个雷。一个个去手动配置混淆豁免规则过于麻烦，所以选择直接手动关闭完整模式，在 gradle.properties 文件中添加以下代码即可 1android.enableR8.fullMode=false 参考文章 R8 full mode 完整模式兼容问题 使用 ViewBinding 混淆后 APP 炸了？ 使用 gson，出现 LinkedTreeMap cannot be cast to xxx 总结至此，这次的 Android 15 告一段落了。不得不说 Android 的适配每次都能给你来点新花样，每次有新版本时，及时对 APP 进行适配，能够减轻将来再有新版本时适配的工作量，同时也能更快利用上一些新版本 Bug 特性，还是值得重视的","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"版本适配","slug":"版本适配","permalink":"https://enderhoshi.github.io/tags/%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"}]},{"title":"ADB 漫游指南","slug":"ADB 漫游指南","date":"2025-02-25T02:25:11.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2025/02/25/ADB 漫游指南/","link":"","permalink":"https://enderhoshi.github.io/2025/02/25/ADB%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/","excerpt":"","text":"作为 Android 开发，经常要使用到 ADB，但是始终没有系统规范地全面学习过，导致使用过程中经常会记不起命令，感到卡壳；有时看到别人的巧妙用法，又会感叹 “居然还能这么用”。故作此指南，供需要时翻阅 awesome-adb点击这里跳转项目，这是一个比较知名的用法大全库，有需要的可以 fork 到自己的仓库中保存，当需要 ADB 指令又记不起时，可以优先从这里找 ADB 打包 tar有时候我们需要把一些文件打包拉取，一是为了方便统一分享；二是有时候文件中含有一些 windows 非法字符（比如冒号这些），无法直接 pull，需要打包后再 pull 这时就可以使用指令 adb exec-out tar chf - -C /data/data/xxx . &gt; aaa.tar，注意这里的 tar 只是打包，没有压缩 使用技巧将 adb 封装成 .bat 文件可以将 adb 指令写入到 .bat 文件内，举个例子，下面是一个将当前屏幕分辨率设置为 1440 x 1920 的 .bat 的代码 12adb shell wm size 1440x1920pause 封装后就可以双击直接一键运行了","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"https://enderhoshi.github.io/tags/ADB/"}]},{"title":"开发笔记-WebView","slug":"开发笔记-WebView","date":"2025-02-13T08:17:56.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2025/02/13/开发笔记-WebView/","link":"","permalink":"https://enderhoshi.github.io/2025/02/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-WebView/","excerpt":"WebView 使用笔记","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 网页中无法弹出选择框网页内有一个按钮，正常情况下点击后会弹出地区选择弹窗，开发时发现在应用内 WebView 中无法弹出，在手机浏览器或 PC 浏览器内均正常，搜索后发现是因为 WebView 初始化时，context 参数传了 Application。看了一下网上的分析，初步估计应该是弹出地区选择弹窗时，用的是原生 Dialog，而 Application 不能作为 Dialog 的 context。所以把 WebView 的初始化参数改为当前 Activity，就解决了问题 参考文章 一文洞彻：Application 为啥不能作为 Dialog 的 context？ webview 无法弹出 select 选择框","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"WebView","slug":"WebView","permalink":"https://enderhoshi.github.io/tags/WebView/"}]},{"title":"开发笔记-应用签名","slug":"开发笔记-应用签名","date":"2025-01-17T04:18:56.000Z","updated":"2025-07-09T09:33:16.190Z","comments":true,"path":"2025/01/17/开发笔记-应用签名/","link":"","permalink":"https://enderhoshi.github.io/2025/01/17/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/","excerpt":"应用签名杂记","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 一些细碎的问题 build.gradle 里面的 signingConfigs 里的 keyAlias 要与你新建 Key Store 时填写的 Alias 保持一致，否则会报错：No key with alias ‘xxxx’ found in keystore E:\\workspace\\xxxx\\xxxx，如果不小心忘记了，可以用指令：keytool -changealias -keystore test.keystore -alias key_name -destalias new_key_name 来处理，参考文章：修改 alias 方法 发现未签名的 apk 打包出来后，文件名里面带有 unsigned，签了名的就没有了，这个应该是可以配置的 生成签名文件和查看签名文件 script12345如何生成 .keystorekeytool -genkey -v -keystore myApp.keystore -alias myApp.keystore -keyalg RSA -validity 30000如何查看 .keystorekeytool -list -v -keystore keystore文件路径 -storepass keystore密码 No.2 关于系统签名近来接触了一下车机项目，因为需要系统级权限，探索了一下系统签名，这里简单记录一下，后续如果还有进行更多关于系统签名的学习的话，可以再继续完善 首先我们手上的是一个普通 apk，能够直接 adb install 到手机、车机等 Android 设备上，这时候我们想要打包一个系统级别的 apk，我做了如下步骤： AndroidManifest.xml 里面 Application 层级声明了 android:sharedUserId=&quot;android.uid.system&quot;12345678&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; package=&quot;com.hoshi.test&quot; android:sharedUserId=&quot;android.uid.system&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0.0&quot;&gt; ...&lt;/manifest&gt; 然后将客户提供的 platform.jks 文件放到项目根目录下 修改 build.gradle 里面的 signingConfigs 12345678910111213141516171819202122signingConfigs &#123; systemKey &#123; keyAlias &quot;e02&quot; keyPassword &quot;123456&quot; storeFile file(&quot;../platform.jks&quot;) storePassword &quot;123456&quot; &#125; ...&#125;buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-project.txt&#x27; signingConfig signingConfigs.systemKey &#125; debug &#123; minifyEnabled false signingConfig signingConfigs.debugkey &#125;&#125; 然后把代码提交，Jenkins 进行打包，得到 apk 使用 keytool -list -v -keystore 指令查看 jks 的 SHA1 码，然后把 apk 上传到客户的应用市场 上面步骤走完，整个处理就结束了，大体流程非常简单，但是里面的细节可以讲很多，下面稍微展开讲讲 第 1 步我们声明了一个 android:sharedUserId=&quot;android.uid.system&quot;，声明之后，就无法通过 AS 直接运行我们的 apk 了，如果要本地运行，调试应用，还需要把这个注释掉 默认情况下，Android 会为每个应用分配其唯一用户 ID。如果两个或多个应用将此属性设置为相同的值，则这些应用都将共享相同的 ID，前提是这些应用的签名完全相同。具有相同用户 ID 的应用可以访问彼此的数据，如果需要的话，还可以在同一进程中运行。所以我们设置了这个 sharedUserId 后，又签了同一个应用的签名，除了都获得了系统级权限之外，彼此之间应该也都可以共享数据了 要注意，android:sharedUserId 在 Android 29 上已经被弃用了，所以高版本还需要找下替代，同时，由于现有应用无法移除此值，这类应用应添加 android:sharedUserMaxSdkVersion=&quot;32&quot; ，以免在新用户安装时使用共享用户 ID。因为我这次开发针对的车机 Android 版本比较老，所以不怎么需要管这个 第 2 步第 2 步这个 platform.jks 文件，应该是客户进入到 AOSP 的 build 目录（或者什么别的目录）下，运行 keytool 相关指令生成的，因为用户有车机系统的源码，所以他可以生成一个车机系统的签名文件出来，具体细节我不太了解，这里简单提一下大概原理即可 第 5 步因为上传到用户的应用市场需要填入 SHA1 码，所以调用 keytool 指令去获取，这里记录一下方便以后有类似场景时查阅，如果不需要的话就不要管这个了 最后我们得到的这个 apk，是无法正常 adb install 的，只能获得 root 权限后，通过 adb push 到 system&#x2F;app&#x2F; 这种目录下，然后重启系统让其自行安装，具体的执行方法视乎具体系统而定。安装好后，这个应用拥有系统级权限，且无法通过常规手段卸载 No.3 APK 迁移 AAB首先用我自己的理解简单说说什么是 AAB，AAB 全称是 Android App Bundle，在用户进行下载时，它会根据用户所在地区、语言、手机分辨率等差异进行分发，以达到精简应用大小的效果，更正式的说明可以自行搜索文档或其他文章 从 2021 年 8 月起，新应用上架 Google 市场就需要以 AAB 的格式上传，老应用可以继续用 APK。公司的应用逐渐臃肿，已经超过 APK 的大小限制 —— 100 MB 了。因为之前已经进行过精简，所以再压缩会比较困难，而 AAB 的大小限制是 150 MB，所以刚好趁这次机会直接将 APK 升级为 AAB 格式 需要做的非常简单，只需要修改 Jenkins 打包脚本，将 gradlew assebleRelease 改为 gradlew bundleRelease，就可以将产物从 .apk 变为 .aab，至于签名密钥文件，可以沿用 .keystore，也可以将 .keystore 转换成 .jks，这两种都是一样的，转换指令为：keytool -importkeystore -srckeystore your-keystore.keystore -srcstoretype JKS -destkeystore your-keystore.jks -deststoretype JKS .keystore 和 .jks 文件本质上是 Java 密钥库的不同命名格式，网上很多文章说 .keystore 是 Eclipse、keytool 生成的，而 .jks 是 Android Studio 生成的，它们本质是一样的，具体还没怎么研究，相关文章也少，暂时按这样理解，后续由新的认知可以再补充下 另外还有个语言分包问题，如果 app 做了应用内多语言切换的话，用 AAB 格式，会由于根据语言分发的特性而导致部分语言实效，所以还要加上如下配置，这里记录一下 1234567891011121314android &#123; ... bundle &#123; language &#123; // Specifies that the app bundle should not support // configuration APKs for language resources. These // resources are instead packaged with each base and // feature APK. enableSplit = false &#125; &#125;&#125;","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"应用签名","slug":"应用签名","permalink":"https://enderhoshi.github.io/tags/%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/"}]},{"title":"ConstraintLayout 的一个小技巧","slug":"ConstraintLayout 的一个小技巧","date":"2024-09-05T10:00:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2024/09/05/ConstraintLayout 的一个小技巧/","link":"","permalink":"https://enderhoshi.github.io/2024/09/05/ConstraintLayout%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"使用约束布局实现头像、名称、标签布局时的一个小技巧","text":"需求背景在做一些账号相关的功能时，我们经常有以下场景，需要展示一个人的头像、名称，名称后要跟一个小标签，比如勋章&#x2F;成就图标、定位图标、等级图标等，大致如下： 用常规方式实现上面这种布局，如下：（为了简化代码，尽可能看到关键的约束条件和参数，我写了点 style 把不太相关的参数统一声明了，后面的代码示例也是这样，不做赘述） 1234567891011121314151617181920212223&lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/cl_container_0&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_avatar_0&quot; style=&quot;@style/ConstraintLayoutTips.Avatar&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_name_0&quot; style=&quot;@style/ConstraintLayoutTips.Name&quot; app:layout_constraintStart_toEndOf=&quot;@id/iv_avatar_0&quot; /&gt; &lt;ImageView android:id=&quot;@+id/iv_position_0&quot; style=&quot;@style/ConstraintLayoutTips.Position&quot; android:layout_marginStart=&quot;10dp&quot; app:layout_constraintStart_toEndOf=&quot;@id/tv_name_0&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 但是名称是用户自己定义的，有长有短，遇到太长的名字时，name 控件会穿出屏幕边界，把右侧的 position 挤得不可见，如下： 实际上我们想要 position 控件跟着 name 控件的长度改变位置，但是最右只能去到屏幕边界，不能被挤出去，同理 name 控件既要根据文字内容来展示，又要在宽度即将超出时进行折叠，末尾显示为 … 的形式，效果如下： 要达到这种效果，直接沿用上面的三个控件的结构，暂时我还没有办法做到，这时需要加入第四个控件（如果需求里跟在名称后的控件有两个，就省了这个操作，如果没有，直接加一个 1dp 宽高的占位 View 即可），然后分两种方式达到我们想要的效果 解决方案第一种方案12345678910111213141516171819202122232425262728293031323334&lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/cl_container_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintTop_toBottomOf=&quot;@id/cl_container_0&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_avatar_1&quot; style=&quot;@style/ConstraintLayoutTips.Avatar&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_name_1&quot; style=&quot;@style/ConstraintLayoutTips.Name&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintEnd_toStartOf=&quot;@id/placeholder_view_1&quot; app:layout_constraintStart_toEndOf=&quot;@id/iv_avatar_1&quot; /&gt; &lt;!-- 宽高 1dp 的占位 View，仅用于实现约束效果，并没有其他作用 --&gt; &lt;View android:id=&quot;@+id/placeholder_view_1&quot; style=&quot;@style/ConstraintLayoutTips.Placeholder&quot; android:layout_marginStart=&quot;10dp&quot; app:layout_constraintStart_toEndOf=&quot;@+id/tv_name_1&quot; /&gt; &lt;ImageView android:id=&quot;@+id/iv_position_1&quot; style=&quot;@style/ConstraintLayoutTips.Position&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintStart_toEndOf=&quot;@id/placeholder_view_1&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 与原始布局的不同点在于： name 控件多了 app:layout_constrainedWidth&#x3D;”true” 属性，而且右侧约束 placeholder_view 多了一个 placeholder_view 占位控件，placeholder_view 左侧约束 name 控件 position 控件多了 app:layout_constraintHorizontal_bias&#x3D;”0.0” 属性，而且左侧约束 placeholder_view，右侧约束父布局 这个方案的基本原理在于 “推动”，name 控件推动 placeholder_view，placeholder_view 控件推动 position，推到边界时，position 控件右侧约束父布局，再也推不动了，理论上来说 position 会被限制在边界，但事实上还要再给 name 加上 app:layout_constrainedWidth&#x3D;”true” 属性，对 name 控件进行强制约束，这时才能达到效果 同时还要注意，这里的 name、placeholder_view 和 position 不能形成链，形成链的话要方案二的一些处理才能达到最终效果，讲方案二时会再展开 第二种方案1234567891011121314151617181920212223242526272829303132333435363738&lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/cl_container_2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintTop_toBottomOf=&quot;@id/cl_container_1&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_avatar_2&quot; style=&quot;@style/ConstraintLayoutTips.Avatar&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_name_2&quot; style=&quot;@style/ConstraintLayoutTips.Name&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintEnd_toStartOf=&quot;@id/placeholder_view_2&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintStart_toEndOf=&quot;@id/iv_avatar_2&quot; app:layout_constraintWidth_default=&quot;wrap&quot; /&gt; &lt;!-- 宽高 1dp 的占位 View，仅用于实现约束效果，并没有其他作用 --&gt; &lt;View android:id=&quot;@+id/placeholder_view_2&quot; style=&quot;@style/ConstraintLayoutTips.Placeholder&quot; android:layout_marginStart=&quot;10dp&quot; app:layout_constraintEnd_toStartOf=&quot;@id/iv_position_2&quot; app:layout_constraintStart_toEndOf=&quot;@+id/tv_name_2&quot; /&gt; &lt;ImageView android:id=&quot;@+id/iv_position_2&quot; style=&quot;@style/ConstraintLayoutTips.Position&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@id/placeholder_view_2&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 与原始布局的不同点在于： name 控件 android:layout_width&#x3D;”0dp”，多了 app:layout_constraintWidth_default&#x3D;”wrap” 属性，设置了 app:layout_constraintHorizontal_bias&#x3D;”0.0”、app:layout_constraintHorizontal_chainStyle&#x3D;”packed”，而且右侧约束 placeholder_view 多了一个 placeholder_view 占位控件，placeholder_view 左侧约束 name 控件，右侧约束 position 控件 position 控件左侧约束 placeholder_view，右侧约束父布局 与方案一的不同点在于： 三个控件构成了一条链 主要处理的控件是 name 控件 这个方案的基本原理在于 “链”，三个控件构成了一条链，且把它们 packed 打包到一起，用 app:layout_constraintHorizontal_bias&#x3D;”0.0” 控制居左显示，最后用 android:layout_width&#x3D;”0dp” 配合 app:layout_constraintWidth_default&#x3D;”wrap”，处理了 name 控件字数不多时没有根据字数动态展示宽度的问题（不设置这个参数，它会把控件占满，因为 width&#x3D;”0dp”） 需要注意 layout_constraintHorizontal_bias 用于控制布局相对水平约束空间的位置百分比，在约束主体只有一个时才有效（不知道这样说是不是合理，大概是这个意思吧），也就是说分两块时，要把 layout_constraintHorizontal_chainStyle 设置为 packed，将其绑成一块才行，否则不会生效（vertical 同理） layout_constraintWidth_default 需要在 layout_width 为 0dp 时才能生效，因为它就是用来控制 layout_width 为 0dp 时的布局状态的（height 同理） 参考文章看了这位哥们的文章学到的，加了些自己的理解，整理归纳","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"UI","slug":"UI","permalink":"https://enderhoshi.github.io/tags/UI/"}]},{"title":"开发笔记-序列化与反序列化","slug":"开发笔记-序列化与反序列化","date":"2024-09-05T04:13:33.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2024/09/05/开发笔记-序列化与反序列化/","link":"","permalink":"https://enderhoshi.github.io/2024/09/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"关于序列化与反序列化","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 实现 Parcelable 接口后，构造方法需要可空值记录一下序列化遇到的问题：需要在 Intent 中传递数据，所以需要序列化，Kotlin 中实现 Parcelable 接口后，constructor(parcel: Parcel) 构造方法中报错提示需要可空值，所以改动了一下默认构造方法中的类型变为可空，但是没有赋默认值，导致后续使用默认构造函数时，需要你传一个 parcel 进去，这时补上可空参数的默认值 &#x3D; null 就可以了 No.2 Serializable 接口的 “传递” 问题最近遇到一个问题，从某个页面返回手机系统 home 页面后，再打开 app 返回那个页面，会引发闪退，报错 java.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name &#x3D; xxx.xxxx.xxxBean)。这是因为我们在某个 A 实体类中实现了 Serializable 接口，然后 A 类中有一些 B、C、D 其他类，这些 B、C、D 类却没有实现 Serializable 接口，而页面恢复时需要序列化来还原一些数据，这时进行序列化遇到没有实现 Serializable 接口的类就会报错，没有实现 Serializable 接口的类会在报错后具体写出，参考文章。因为父类声明了子类也需要声明，所以我把这个叫做 Serializable 接口的 “传递” 问题，经过一番检索，有下面三种处理方法 用 transient 来修饰类内不参与序列化&#x2F;反序列化的属性。这个需要再仔细了解下 transient 修饰符，不能乱用，因为加上了这个，对应属性不参与序列化&#x2F;反序列化，可能会影响页面数据的恢复 考虑一下属性的用途，看是否可以修改属性，不要直接用实体类，比如只需要一个 String 就能存储的信息，就不需要用一个类了。一般比较推荐这个，毕竟是做减法，复杂度更小了，毕竟你的 B、C、D 等类内可能还有 E、F、G 这些其他类，会越来越麻烦 用 Parcelable 来替代 Serializable。如果是简单的类还比较好弄，如果有很多字段，且这个类会比较频繁地加属性，那后面要一直维护这个类，不如 Seriallizable 简单。而且抽象类实现 Parcelable 接口貌似还比较复杂，不太好用 这三种处理方法的原文在这里，截图如下，贴出来供参考，综上所述，我比较推荐使用第 2 种方案，实在不行的话就要再考虑 1、3 这两种了 另外附上 《Android Studio 自动生成 SerialVersionUID》 文章供查阅 展开讲讲什么是 serialVersionUID？有什么用？serialVersionUID 用来表明类的不同版本间的兼容性，其目的是以序列化对象进行版本控制，有关各版本反序加化时是否兼容 如果类没有显示定义这个静态变量，它的值是 JRE 根据类的内部细节自动生成的。若类做了修改，serialVersionUID 可能发生变化，故建议显式声明","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://enderhoshi.github.io/tags/Java/"},{"name":"序列化","slug":"序列化","permalink":"https://enderhoshi.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"移动存储介质实现 git 远端仓库","slug":"移动存储介质实现 git 远端仓库","date":"2024-05-11T09:35:28.000Z","updated":"2025-07-09T09:33:16.190Z","comments":true,"path":"2024/05/11/移动存储介质实现 git 远端仓库/","link":"","permalink":"https://enderhoshi.github.io/2024/05/11/%E7%A7%BB%E5%8A%A8%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%AE%9E%E7%8E%B0%20git%20%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93/","excerpt":"","text":"最近看到一个关于离线使用 Git 的技巧，就是将远端仓库配置在一个移动存储介质（U 盘、移动硬盘，下面统一用 U 盘来描述）里，需要 push、pull 时把 U 盘插到电脑上，然后进行相关的操作 实现步骤 首先我们需要在本地文件夹内建立一个本地的 git 仓库 1234567// 创建一个文件夹，最好记住这个文件夹名，后面创建远端仓库时也用这个，后面 clone 就比较统一了mkdir myRepocd myRepogit inittouch test.txt // 创建一个用于测试的 txtgit add .git commit -m &quot;Initial Commit&quot; 然后把你的 U 盘插到电脑里 cd 到你的 U 盘目录下，进行设置 1234cd /h // 假设你的 U 盘被电脑识别为 H 盘mkdir myRepo.gitcd myRepo.gitgit init --bare // 注意要加 --bare 创建一个裸库 然后回到你的本地文件夹内，进行 push 123456cd /path/to/local/myRepo // 回到你的本地文件夹内git remote add origin /h/myRepo.gitgit push origin master// 如果有提示本地的分支没有和远程分支建立联系，可以再加上下面这句git push --set-upstream origin master 这时就完成了 U 盘远端仓库的配置了，如果你需要把文件 pull 到本地电脑上，只需要插入 U 盘后就可以正常 fetch、pull 了 如果你需要把文件 pull 到另一台电脑上，先将 U 盘插入指定电脑，然后执行如下指令 1git clone /h/repoName.git // 这里同样假设你的 U 盘被电脑识别为 H 盘 使用场景可以想象，这种方案可以用于一些只想本地脱离网络的多人开发场合，局域网内 gitlab 也可以做到，但是配置相对复杂一点，这个直接利用 U 盘的就非常简单 除了上述的多人开发场合，我最近也有一个用得到的场景，那就是相册备份 每次我把相机&#x2F;无人机的照片&#x2F;视频传到个人电脑上时，我还要传一份到 U 盘上，如果我直接整个文件夹复制，电脑肯定会提示我有重复的，询问是否覆盖，这时我们就要选择全部覆盖。同理，从 U 盘上把文件提取到电脑上时，也会经历这个过程。照片&#x2F;视频非常多时，这个过程会很不优雅，这时使用上面的 U 盘 Git 方案就会很方便了，它具有以下优点 能够满足电脑、U 盘各存一份照片的需求 能够增量更新，不必自己识别新增了哪些照片，也不用全部覆盖 多台电脑之间可以实现相册同步，不会出现差异 比起直接用 github、gitee，这种离线方案没有容量限制，也更安全，传输也更快 比起在局域网内搭建 gitlab，这个方案更简单直接 后续基于上述设想，我进行了尝试，很快败下阵来，因为我的图片非常多，仅仅是 git add . 指令就花费了一个多小时还没结束。我尝试对一个 2G 的文件夹进行 git add 操作，发现也耗费了十来分钟。对一个 14G 的进行操作直接又一个多小时，我们平时的代码看着文件很多，但实际文件大小不大，所以才可以正常进行各种操作。而相册对于 git 来说实在是太庞大了，git 的处理速度和传输速度不足以对相册进行此类操作，遂最终放弃了这个相册存储方案 参考文章 Using Git offline 使用 U 盘或在本地电脑作为 git 远程仓库进行托管 Git init 和 Git init –bare 的区别，以及 Git init –bare 如何创建工作空间","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"git","slug":"git","permalink":"https://enderhoshi.github.io/tags/git/"}]},{"title":"Kotlin 主次构造函数理解","slug":"Kotlin 主次构造函数理解","date":"2024-03-07T03:09:28.000Z","updated":"2025-07-09T09:33:16.188Z","comments":true,"path":"2024/03/07/Kotlin 主次构造函数理解/","link":"","permalink":"https://enderhoshi.github.io/2024/03/07/Kotlin%20%E4%B8%BB%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/","excerpt":"","text":"今天在做需求时需要自定义两个 View，在取自定义属性时稍微纠结了一下该放在哪里 是不是该在主构造函数中调用 但是主构造方法不能有方法体 那是不是不应该放在 init 代码块里 但是 init 代码块不是会在类构造前就调用的吗，那怎么取到自定义属性 搞来搞去，越来越乱，和 Java 的用法彻底搞混淆了，说来惭愧，用了 Kotlin 这么多年，还是没有彻底理清这种基础的东西，现在做点笔记记录下 Java 构造函数与 init 代码块首先直接捋一下 Java 的，相对 Kotlin 的应该比较基础 想要在 Android 项目中直接跑 Java 代码，可以 new module 创建一个 Java or Kotlin Library，选择 Java 语言即可 123456789101112131415161718192021222324public class Person &#123; &#123; System.out.println(&quot;初始化块1&quot;); &#125; public Person() &#123; System.out.println(&quot;无参构造函数&quot;); &#125; &#123; System.out.println(&quot;初始化块2&quot;); &#125; public static void main(String[] args) &#123; new Person(); &#125;&#125;// 执行结果： 初始化块1初始化块2无参构造函数 从上面的代码和运行结果可以看出，当创建 Java 对象时： 先执行初始化块； 如果定义多个初始化块，则前面的先执行，后面的后执行； 然后执行构造函数。 虽然可以定义多个初始化块，但是没有意义， 一般合并在一起，代码更加简洁。 static init 代码块使用 static 修饰符定义的初始化块，称为静态初始化块，也叫类初始化块。普通初始化块是对对象初始化，类初始化块是对类初始化。因此静态初始化块总是比普通初始化块先执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Root &#123; static &#123; System.out.println(&quot;Root static init&quot;); &#125; &#123; System.out.println(&quot;Root obj init&quot;); &#125; public Root() &#123; System.out.println(&quot;Root constructor func&quot;); &#125;&#125;class Mid extends Root &#123; static &#123; System.out.println(&quot;Mid static init&quot;); &#125; &#123; System.out.println(&quot;Mid obj init&quot;); &#125; public Mid() &#123; System.out.println(&quot;Mid constructor func&quot;); &#125; public Mid(String msg) &#123; this(); System.out.println(&quot;Mid has param constructor: &quot; + msg); &#125;&#125;class Leaf extends Mid&#123; static &#123; System.out.println(&quot;Leaf static init&quot;); &#125; &#123; System.out.println(&quot;Leaf obj init&quot;); &#125; public Leaf() &#123; super(&quot;MESSAGE&quot;); System.out.println(&quot;Leaf constructor func &quot;); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; new Leaf(); &#125;&#125;// 执行结果Root static initMid static initLeaf static initRoot obj initRoot constructor funcMid obj initMid constructor funcMid has param constructor: MESSAGELeaf obj initLeaf constructor func 从上面的代码和执行结果看： 会先进行类初始化， 然后对象初始化，类初始化全部先执行一遍。先执行父类初始化，然后子类初始化。 对象初始化时，同样先执行父类的初始化块，构造函数，然后执行子类的。 另外，静态初始化块和静态成员变量，初始化的值与代码顺序相对应。如果你先 int a &#x3D; 5，然后再写 init 块改变它的值为 8，最后输出 a 为 8，反之如果先 init 块中赋值 a &#x3D; 8，再 int a &#x3D; 5，那么最后输出 a 为 5 总结 初始化块是构造函数的补充。 初始化块总在构造函数之前执行。 初始化块是一段固定执行的代码， 不接受任何参数， 因此，如果一段初始化代码对所有对象相同， 且不用接收任何参数，则可以把这段初始化代码放在初始化块中。 实际上初始化块是一个假象， 使用 javac 编译 Java 类后， 初始化块消失，被”还原”到构造器中，且位于构造器所有函数的前面。 参考文章 Kotlin 构造函数与 init 代码块然后再看一下 Kotlin 相关的内容，在 Kotlin 中有两种类型的构造函数，分别是主构造函数（主构造器）和次级构造函数（次级构造器），在 Kotlin 类中只有一个主构造函数，而次级构造函数可以是一个或者多个。 construction 在 Kotlin 中是一个关键字，在 Java 中，构造方法名必须和类名相同，例如文中开头写的 Java 的构造函数；而在 Kotlin 中，是通过 constructor 关键字来标明的，对于主构造函数来说，它的位置在类的标题中声明，而对于次级构造函数来说它的位置在类中。 并且当 constructor 关键字没有注解和可见性修饰符作用于它时，constructor 关键字可以省略。 1234567class Person(name: String, age: Int) &#123; ... &#125; // 省略class Person private constructor(name: String, age: Int) &#123; ... &#125; // private 修饰class Person @JvmOverloads constructor(name: String, age: Int = 12) &#123; ... &#125; // 有注解// 如果构造方法中参数用了 val 或 var 修饰，那么他们就是类的属性，否则只是参数class Person(name: String, age: Int) &#123; ... &#125; // name 和 age 都不是 Person 类的属性class Person(val name: String, var age: Int) &#123; ... &#125; // name 和 age 都是 Person 类的属性 主构造函数主构造函数用于初始化类，它在类标题中声明。需要注意的是主构造函数不能包含任何代码，所以这时的初始化代码块本质就是主构造函数的方法体。 当我们定义一个类并没有声明一个主构造函数的时候，Kotlin 会默认为我们生成一个无参的主构造函数，这一点和 Java 一样 次级构造函数我们可以在同一类中使用主构造函数和次级构造函数。如果一个类有次构造函数，那么这些次构造函数就必须调用主构造函数，方式可以不同： 无参的主构造函数会被次级构造函数隐式调用，且顺序在次级构造函数之前 可以使用 this() 对同一个类中的另一个构造函数进行调用 可以使用 super() 来调用父类的构造函数 总结Kotlin 的用法和 Java 的有比较大的不同，使用时要注意区分 参考文章 回到问题梳理完毕，现在我们看回一开始的问题 是不是该在主构造函数中调用 确实是应该在主构造中调用，View 构造完就该读取自定义属性了 但是主构造方法不能有方法体 init 就是主构造的方法体 那是不是不应该放在 init 代码块里 应该放在 init 代码块里，因为它就是主构造的方法体 但是 init 代码块不是会在类构造前就调用的吗，那怎么取到自定义属性 Java 的会在类构造前调用，但是 Kotlin 的不会，Kotlin 中 init 就是主构造函数的一部分，执行到 init 时，已经跑完主构造函数，它能够取到自定义属性","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://enderhoshi.github.io/tags/Kotlin/"}]},{"title":"Android Gradle 统一依赖管理方案","slug":"Android Gradle 统一依赖管理方案","date":"2024-03-05T08:51:33.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2024/03/05/Android Gradle 统一依赖管理方案/","link":"","permalink":"https://enderhoshi.github.io/2024/03/05/Android%20Gradle%20%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/","excerpt":"","text":"在组件化开发 Android 应用时，多个模块可能由不同同事负责，并且依赖引入也可能不是由同一个人来控制，这样会导致引用到的依赖版本不一致，统一升级不方便等问题，所以对版本的统一管理很重要 Android 最原始的依赖管理方式就是直接引入，如果要统一管理，有三种方式： 传统 apply from 的方式 buildSrc 方式 includeBuild 方式（也有叫 composing builds 方式的） 经过一些考虑，个人认为 apply from 的方式无法跟踪代码、无法自动补全、需要手动搜索相关的依赖，且可读性很差；而 includeBuild 的方式有点太复杂了，于是选择使用 buildSrc 的方式，这里做下记录 buildSrc 方式统一管理依赖流程 在项目根目录下新建一个名为 buildSrc 的文件夹(名字必须是 buildSrc，因为运行 Gradle 时会检查项目中是否存在一个名为 buildSrc 的目录) 在 buildSrc 文件夹里创建名为 build.gradle.kts 的文件，添加以下内容123456plugins &#123; `kotlin-dsl`&#125;repositories&#123; mavenCentral()&#125; 创建 buildSrc&#x2F;src&#x2F;main&#x2F;kotlin&#x2F; 目录，然后在其下新建 Dependencies.kt 文件，添加以下内容 1234567891011object Versions &#123; private const val compileAndTargetSdk = 34 const val compileSdk = compileAndTargetSdk const val targetSdk = compileAndTargetSdk const val minSdk = 24 const val buildToolsVersion = &quot;30.0.3&quot;&#125;object Strings &#123; const val applicationId =&quot;com.hoshi.armor&quot;&#125; 同步一下，项目里就会多出一个名为 buildSrc 的 module，同时buildSrc 目录下多出了一些不需要的东西，可以在 gitignore 中加一下来忽略掉 然后就可以在 build.gradle.kts 中使用了12345678910compileSdk = Versions.compileSdkbuildToolsVersion = Versions.buildToolsVersiondefaultConfig &#123; applicationId = Strings.applicationId targetSdk = Versions.targetSdk minSdk = Versions.minSdk versionCode = 1 versionName = &quot;1.0&quot;&#125; 有一点要注意的，如果发现无法引用到 Dependencies 内定义的常量，可能是同步的顺序有问题，我在执行上面第 2 步后立刻同步，就无法正确引用了，重新按顺序走一遍流程，最后走到第 4 步才同步，就可以正常使用 参考文章 &lt;版本&gt;Android统一依赖管理 Android gradle统一依赖版本：kotlin+buildSrc Android 统一依赖管理 新一代版本依赖管理 Vesion Catalog这个是预览版的内容，还未稳定发布，但是看起来将来会成为比较主流的一种用法，后续 AS 的稳定版本支持这种方式后，可以尝试改成这种，然后再补充一下日志，参考文章","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://enderhoshi.github.io/tags/Gradle/"},{"name":"依赖管理","slug":"依赖管理","permalink":"https://enderhoshi.github.io/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}]},{"title":"开发笔记-版本适配","slug":"开发笔记-版本适配","date":"2024-03-05T07:38:33.000Z","updated":"2025-07-09T09:33:16.190Z","comments":true,"path":"2024/03/05/开发笔记-版本适配/","link":"","permalink":"https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/","excerpt":"关于版本适配的一些开发中的笔记","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 startForegroundService 方法导致报错 RemoteServiceException 引起闪退闪退机型：(均为 Android 9.0 系统) 小米 MI NOTE 3 华为 P30 Pro (VOG AL00) P10 PLUS (VKY AL00 ) NOVA 4 (VCE AL00) Mate10 (ALP AL00) Mate20 (LYA AL00) P30 (ELE AL00) 荣耀 HONOR 9 (STF AL00) HONOR 10 （COL AL10） HONOR V10 （BKL AL20） HONOR Note 10 （RVL AL09） HONOR Play （COR AL00） 索尼 G8142 一加 pro 7 报错详细信息： 12android.app.RemoteServiceException Context.startForegroundService() did not then call Service.startForeground() Android O 后台执行限制Android 8.0 为提高电池续航时间而引入的变更之一是，当您的应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁 此外，为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言： 现在，在后台运行的应用对后台服务的访问受到限制 应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播） 默认情况下，这些限制仅适用于针对 O 的应用，不过，用户可以从 Settings 屏幕为任意应用启用这些限制，即使应用并不是以 O 为目标平台 Android 8.0 还对特定函数做出了以下变更： 如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException 新的 Context.startForegroundService() 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 Context.startForegroundService()。不过，应用必须在创建服务后的五秒内调用该服务的 startForeground() 函数，否则会导致 ANR Android O 后台服务限制在后台中运行的服务会消耗设备资源，这可能降低用户体验。 为了缓解这一问题，系统对这些服务施加了一些限制 系统可以区分 前台 和 后台 应用，（用于服务限制目的的后台定义与内存管理使用的定义不同；一个应用按照内存管理的定义可能处于后台，但按照能够启动服务的定义又处于前台）如果满足以下任意条件，应用将被视为处于前台： 具有可见 Activity（不管该 Activity 已启动还是已暂停） 具有前台服务 另一个前台应用已关联到该应用（不管是通过绑定到其中一个服务，还是通过使用其中一个内容提供程序），例如，如果另一个应用绑定到该应用的服务，那么该应用处于前台： IME 壁纸服务 通知侦听器 语音或文本服务 如果以上条件均不满足，应用将被视为处于后台。 绑定服务不受影响，这些规则不会对绑定服务产生任何影响，如果您的应用定义了绑定服务，则不管应用是否处于前台，其他组件都可以绑定到该服务 处于前台时，应用可以自由创建和运行前台服务与后台服务，进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用服务，在该时间窗结束后，应用将被视为处于 空闲 状态。 此时，系统将停止应用的后台服务，就像应用已经调用服务的 Service.stopSelf() 方法，在这些情况下，后台应用将被置于一个临时白名单中并持续数分钟。 位于白名单中时，应用可以无限制地启动服务，并且其后台服务也可以运行，处理对用户可见的任务时，应用将被置于白名单中，例如： 处理一条高优先级 Firebase 云消息传递 (FCM) 消息。 接收广播，例如短信&#x2F;彩信消息。 从通知执行 PendingIntent。 在很多情况下，您的应用都可以使用 JobScheduler 作业替换后台服务，例如 CoolPhotoApp 需要检查用户是否已经从朋友那里收到共享的照片，即使该应用未在前台运行，在之前的版本中，应用使用一种会检查其云存储的后台服务。 为了迁移到 Android 8.0，开发者使用一个计划作业替换了这种后台服务，该作业将按一定周期启动，查询服务器，然后退出，在 Android 8.0 之前，创建前台服务的方式通常是先创建一个后台服务，然后将该服务推到前台，而 Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务，因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务，在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知，如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR 所以为了解决这个问题，应该： 将启动 Service 调用的 startService 改为 startForegroundService 调用了 startForegroundService 后需要在 Service 里继续调用 Service.startForeground()，有如下三个注意事项 在 Service 的 onCreate 方法和 onStartCommand 方法中都调用 startForeground，因为 onCreate 方法不一定会每一次都调用，主要是针对后台保活的服务，如果在服务A运行期间，保活机制又调用 startForegroundService 启动了一次服务A，那么这样不会调用服务A的 onCreate 方法，只会调用 onStartCommand 方法 notification ID 必须不为 0，否则会报同样的错误 调用 stopSelf 必须要在调用 startForeground 之后 这样应该就能够解决了 相关文章：Android Service 生命周期、Android 通知渠道、Android Oreo 通知新特性 No.2 Android Q 反射失效导致K线图缩放异常在处理一些手势缩放事件时，可以用如下做法： 12345678910111213141516private val scaleGestureDetector = ScaleGestureDetector(context, ScaleListener())private inner class ScaleListener : ScaleGestureDetector.SimpleOnScaleGestureListener() &#123; override fun onScaleBegin(detector: ScaleGestureModifyDetector?): Boolean &#123; return super.onScaleBegin(detector) // 开始缩放 &#125; override fun onScale(detector: ScaleGestureModifyDetector): Boolean &#123; return super.onScale(detector) // 缩放中的处理 &#125; override fun onScaleEnd(detector: ScaleGestureModifyDetector?) &#123; // 缩放完毕 &#125;&#125; 只需要在 ScaleListener 中实现想要的逻辑就可以了 但是，在 ScaleGestureDetector 中有一个属性 mMinSpan，在执行构造函数初始化时，会赋予一个从 viewConfiguration 对象获得的 mMinScalingSpan 值，又从 onTouchEvent() 方法中可以看到，当 span &lt; mMinSpan 时，会调用 mListener.onScaleEnd(this)，意思就是，当双指缩小到这个尺寸时，就不会再缩小了，所以造成了缩放不顺畅的效果，那么这个尺寸是多少呢，要怎么修改呢 1234567891011121314151617181920212223public ScaleGestureDetector(Context context, OnScaleGestureListener listener, Handler handler) &#123; ··· mMinSpan = viewConfiguration.getScaledMinimumScalingSpan(); ···&#125;public int getScaledMinimumScalingSpan() &#123; if (!mConstructedWithContext) &#123; throw new IllegalStateException(&quot;Min scaling span cannot be determined when this &quot; + &quot;method is called on a ViewConfiguration that was instantiated using a &quot; + &quot;constructor with no Context parameter&quot;); &#125; return mMinScalingSpan;&#125;public boolean onTouchEvent(MotionEvent event) &#123; ··· if (!inAnchoredScaleMode() &amp;&amp; mInProgress &amp;&amp; (span &lt; mMinSpan || configChanged)) &#123; mListener.onScaleEnd(this); mInProgress = false; mInitialSpan = span; &#125; ··· return true;&#125; 跟踪进去看到，ViewConfiguration 类中的 get() 方法中，会用 ViewConfiguration 的私有构造函数创建一个 ViewConfiguration 对象 123456789public static ViewConfiguration get(Context context) &#123; ··· ViewConfiguration configuration = sConfigurations.get(density); if (configuration == null) &#123; configuration = new ViewConfiguration(context); sConfigurations.put(density, configuration); &#125; return configuration;&#125; 而 ViewConfiguration 的私有构造函数中，会取到一个系统中写死的值 123private ViewConfiguration(Context context) &#123; mMinScalingSpan = res.getDimensionPixelSize(com.android.internal.R.dimen.config_minScalingSpan);&#125; 这个 mm 是指屏幕的物理毫米尺寸，换算成 dp 大概是三四百像素左右，这么大，难怪卡顿了，必须要改掉 1&lt;dimen name=&quot;config_minScalingSpan&quot;&gt;27mm&lt;/dimen&gt; 首先用了反射的方法，将这个值直接给他改成 50 像素 12345val declaredFields = ScaleGestureDetector::class.java.declaredFieldsdeclaredFields.first &#123; it.name == &quot;mMinSpan&quot; &#125;?.apply &#123; isAccessible = true set(scaleGestureDetector, 50)&#125; 在 Android Q 之前的版本，运行完美，但是一但用户更新了 Android Q，就又会出现缩放不灵敏的感觉，就是说，我们的反射失效了 查阅文档，可以在 Android Q 中受限的灰名单中的非 SDK 接口列表中看到下面这一条： 12Landroid/view/ScaleGestureDetector;-&gt;mMinSpan:I # To retrieve the min scaling span value in pixels, you can now use ViewConfiguration.get([context]).getScaledMinScalingSpan().# 翻译：要检索最小缩放范围值（以像素为单位），现在可以使用 ViewConfiguration.get([context]).getScaledMinScalingSpan() 也就是说，在 Android 9 中还是不建议使用的这个变量，现在直接受限了，使用反射是取不到改不了的了，其实不单只是这个变量，类里的其他变量都多多少少无法使用了，说明通过反射来修改一些私有变量在 Android Q 中其实并不是太可靠了，那没办法了，只能用最后一步了，直接复制整个类，然后改掉想要改掉的部分，然后替换掉原来的 ScaleGestureDetector 123456public ScaleGestureModifyDetector(Context context, OnScaleGestureListener listener, Handler handler) &#123; ··· // mMinSpan = viewConfiguration.getScaledMinimumScalingSpan(); mMinSpan = 50; // 直接赋予为 50，单位为像素 ···&#125; No.3 Android 14 适配 Intent 相关最近把 HoshiCore 库进行了一下 Android 14 的适配，起因是我的另一个项目里，提升 targetSdk 到 14 后，所有页面跳转都失效了，查了一下资料，原来是 Intent 有一些安全性调整，有如下一大段描述，原文点击这里跳转 对于面向 Android 14 的应用，Android 通过以下方式限制应用向内部应用组件发送隐式 intent：隐式 intent 仅传递给导出的组件，应用必须使用明确的 intent 来交付给未导出的组件，或者将组件标记为已导出（exported）。 如果应用创建一个 mutable pending intent ，但 intent 未指定组件或包，系统现在会抛出异常。 这些更改可防止恶意应用拦截只供给用内部组件使用的隐式 intent，例如： 12345678&lt;activity android:name=&quot;.AppActivity&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.action.APP_ACTION&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 如果应用尝试使用隐式 intent 启动该 activity，则会抛出异常： 12// Throws an exception when targeting Android 14.context.startActivity(Intent(&quot;com.example.action.APP_ACTION&quot;)) 要启动未导出的 Activity，应用应 改用显式 Intent 给 Intent 对象设置 package 123456// This makes the intent explicit.val explicitIntent = Intent(&quot;com.example.action.APP_ACTION&quot;)explicitIntent.apply &#123; package = context.packageName&#125;context.startActivity(explicitIntent) 上述描述中，原版的描述是 “改用显式 Intent”，而我认为应该是 “给 Intent 对象设置 package” 即可，在一开始我们的认知里，显式 Intent 指的是明确写出了 Activity 的 Intent，应该也可以说是用了以下这个构造函数的情形： 1public Intent(Context packageContext, Class&lt;?&gt; cls) &#123; ... &#125; 而隐式 Intent 指不像显式那样直接指定需要调用的 Activity 的一种 Intent，它是设置 Action、Data、Category 等参数，让系统来筛选出合适的 Activity 的一种 Intent，筛选是根据 &lt;intent-filter&gt; 来进行的 官方的例子里很明显就是调用了以下这种构造函数，是用了 Action 的，应该是属于隐式声明的 1public Intent(String action) &#123; ... &#125; 所以我认为并没有改成了显式声明，只是在原来的隐式声明上作了一些调整，也可能是我理解出了偏差，官方可能把这种指定了 package 的 Intent 认为是显式的，因为它指定的东西足够多了 当然，咬文嚼字多说无益，解决问题最重要，这里记录一些思考，旨在避免这类随意的文档描述混淆视听，搞乱了原来的理解，如果以后有新的认识，可以再作记录 No.4 提升 minSdkVersion 后 APK 变大公司项目引入了一个第三方的远程预览库，最近需要提升版本，版本提升后发现需要同步提升 minSdkVersion，于是又把 minSdkVersion 提升到 23，结果打包后发现 APK 增大了 70M。把新旧 APK 都拉到 AS 里面一看，发现 lib 文件夹下的各个 .so 库的体积都翻了一倍 网上搜索了一下相关症状，发现是因为 minSdkVersio 23 以下时，android:extractNativeLibs 默认为 true，而 minSdkVersion 大于等于 23 时，android:extractNativeLibs 默认为 false，下面是 google 对这个属性的一些解析 此属性指示软件包安装程序是否将原生库从 APK 提取到文件系统。如果设置为 “false”，则原生库以未压缩的形式存储在 APK 中。虽然您的 APK 可能较大，但应用加载速度更快，因为库是在应用运行时直接从 APK 加载。extractNativeLibs 的默认值取决于 minSdkVersion 和您使用的 AGP 版本。在大多数情况下，默认行为很可能符合您的预期，您无需显式设置此属性。 从 AGP 4.2.0 开始，DSL 选项 useLegacyPackaging 取代了 extractNativeLibs 清单属性。请使用应用的 build.gradle 文件中的 useLegacyPackaging（而非清单文件中的 extractNativeLibs）来配置原生库压缩行为。如需了解详情，请参阅版本说明使用 DSL 打包压缩的原生库。 所以，可以手动设置一下 android:extractNativeLibs 或者 useLegacyPackaging，即可避免提升 minSdkVersion 后 APK 包体积变大的问题 No.5 提升 AGP 版本后，BuildConfig 不生成在版本适配过程中，有时候需要提升 AGP（Android Gradle Plugin）版本，在把 AGP 版本从较旧版本提升到 8.0.0 之后，发现 BuildConfig 都提示找不到了，这是因为 8.0.0 之后，默认不会生成 BuildConfig 了，需要做以下配置 12345android &#123; buildFeatures &#123; buildConfig = true // 配置开启 buildConfig 构建特性，新版本 AGP 需要配置 &#125;&#125; 相关官方文档，可以查看这里","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"版本适配","slug":"版本适配","permalink":"https://enderhoshi.github.io/tags/%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"}]},{"title":"开发笔记-疑难杂症","slug":"开发笔记-疑难杂症","date":"2024-03-05T07:35:26.000Z","updated":"2025-07-09T09:33:16.190Z","comments":true,"path":"2024/03/05/开发笔记-疑难杂症/","link":"","permalink":"https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/","excerpt":"一些疑难杂症的笔记记录，汇集到一定量后可以再分类存放","text":"整理之前的近期小记时，发现有一些笔记不太好归类，且可能比较偏门，统一放到这里，汇集到一定量后可以再分类存放 No.1 听云集成报错 No virtual method isVisible()1java.lang.NoSuchMethodError: No virtual method isVisible()Z in class Lcom/xxxx/xxxxxx/containers/xxxxxx; or its super classes (declaration of &#x27;com.xxxxxx.xxxxxxx.containers.xxxxxx&#x27; appears in /data/app/com.myapp.app-JUxpxJQv7z6s5jkYdS3yHw==/base.apk!classes3.dex) 报错信息如上图，初步推断为听云嵌码插桩逻辑有些问题，部分类应该跳过插桩的过程，搜索相关内容寥寥无几，且不相关，听云客服疑似空号，添加失败，客服群也加不进去，最后从非常旧和凌乱的文档中看到一个不太起眼的描述： 12# 等号“=”后替换为需要过滤听云嵌码的类的路径，如有多个路径，使用英文逗号隔开noInstrumentedClasses=com/xxxxxx/xxxxxxx/containers/xxxxxxx 把报错中指出的类填入这个 noInstrumentedClasses 中，再次编译，还是不行，后来发现是他的配置内容有缓存在本地，clean project 再重新跑就可以了，记录这个不是为了下次接入再查阅，而是提醒自己需要提升信息搜集能力和文档查阅能力，同时多从报错中推断；处理类似的第三方接入问题时，更改配置要 clean project，避免部分配置缓存在本地造成误判，认为自己的写法有误；另外，接入第三方库时尽量选取维护比较积极，售后比较靠谱的 相关链接 No.2 Mac 处理 Adobe Genuine Software Integrity Service使用”不明来路”的 ps, 某一天突然弹出个窗，必须点一下才能关掉，而且过一会又弹出来，无法彻底关闭 解决方法: 关闭所有 Adobe 软件 $ sudo rm &#x2F;Library&#x2F;Application\\ Support&#x2F;Adobe&#x2F;AdobeGCClient&#x2F;AdobeGCClient.app&#x2F;Contents&#x2F;MacOS&#x2F;AdobeGCClient 启动 ps，就正常了 No.3 Android SSL 验证服务器证书 Hostname 不匹配错误有时候开发需要改动 host，然后会报 host name 不匹配的错误， 112-24 16:37:04.801: W/System.err(26380): java.io.IOException: Hostname &#x27;74.208.145.100&#x27; was not verified 错误原因是验证证书时发现真正请求和服务器的证书域名不一致，这时就可以在客户端代码中增加如下代码，忽略hostname 的验证 12345HttpsURLConnection.setDefaultHostnameVerifier( new HostnameVerifier()&#123; public boolean verify(String string,SSLSession ssls) &#123; return true; &#125;&#125;); No.4 电脑可以科学上网但是模拟器不能的情况自己胡乱鼓捣的时候，发现有这样一种情况：电脑已经开启了科学上网，模拟器可以上网，但是不能浏览外网 解决方法: 打开模拟器配置，找到 proxy 选项 ip 写 127.0.0.1，端口写代理的端口（如果使用的是 Clash，打开 Clash 主界面 -&gt; General 应该就可以看到） 保存设置，再尝试一下 No.5 AS 4.2 Gradle 面板中 Tasks 不见了某次想要执行一些 Gradle 命令，点开 Gradle 面板时，发现其中的 Tasks 不见了 解决办法如下： 参考文章 No.6 gradle.properties 中文乱码如果发现 gradle.properties 原本应该是中文的一些注释变成了乱码，可以留意一下 IDE 右下方的编码是什么格式，如果是 ISO-8859-1，那么就可以到设置里找到 Editor -&gt; File Encodings 选项，把默认的 properties 格式改成 UTF-8，如下图 No.7 返回手势需要执行两次我们平时使用返回手势时，手机边缘会出现一个返回箭头以示成功触发，松开手指就会执行返回操作，但是我开发时发现我的 App 存在一个问题，返回手势第一次触发无反应，第二次才会出现箭头，此时把手指移回边缘，也就是把返回操作取消掉，再执行，又是无反应，再触发一次才能成功。简而言之就是我每次想触发返回，都要执行两次手势 看了一下 Logcat，发现频繁打印 Android handleResized abandoned!，问问 AI，得到这样的答复：这个日志通常由 SurfaceFlinger 或 ViewRootImpl 打印，表示在处理窗口大小变化时遇到问题，导致一些窗口调整操作被中止或放弃 检查代码发现，注释掉处理全屏的代码后，这个现象就不再会发生，再继续追问，得到这样的答复：如果你观察到 Android handleResized abandoned! 频繁出现在全屏模式下，这通常与窗口大小调整、系统栏状态变化或 SurfaceView 的 Surface 变化有关 我又多尝试了一下，发现这个与全屏情况下，触碰边缘后弹出状态栏有一点像，类似于正常情况下第一次触碰手机屏幕边缘时，状态栏弹出来，然后才能响应接下来第二次的操作。之所以我不能第一时间发现，就是因为我的全屏代码似乎没有生效，导致状态栏一直显示着，但是却需要两次去触发返回 我的设置全屏代码如下，有很多已经被废弃的属性，可能是因为我提升了 Android 版本，其中有一些属性已经无效了导致出现问题。我想替换 ImmersionBar 库来做全屏，发现它的 fullScreen 方法也失效了，应该也是因为同样的原因。于是换用了 ImmersionBar 库的 hideBar 方法，隐藏状态栏和导航栏来实现全屏，暂告一段落，这里先记录一下，具体的原因后续有兴趣再研究了 123456789101112131415161718192021222324252627/** * 设置是否全屏 * * @param enabled 是否全屏显示 */fun Activity.setFullscreen(enabled: Boolean = true) &#123; if (enabled) &#123; window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN) &#125; else &#123; val lp: WindowManager.LayoutParams = window.attributes // LayoutParams.FLAG_FULLSCREEN 强制屏幕状态条栏弹出 lp.flags = lp.flags and WindowManager.LayoutParams.FLAG_FULLSCREEN.inv() window.attributes = lp // 不允许窗口扩展到屏幕之外 clear掉了 window.clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS) &#125; window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_STABLE window.decorView.systemUiVisibility = systemUiVisibility window.statusBarColor = Color.TRANSPARENT&#125;","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://enderhoshi.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"}]},{"title":"开发笔记-Fragment","slug":"开发笔记-Fragment","date":"2024-03-05T07:33:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2024/03/05/开发笔记-Fragment/","link":"","permalink":"https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-Fragment/","excerpt":"关于 Fragment 的一些开发中的笔记","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 Fragment not attached to a context可以检查以下是否是下面的情况产生的 1234567891011val dialog = SquareConfirmDialog().apply &#123; // 以下代码会报错 not attached to a context // 因为调用的是 Dialog 的 Fragment.getString() 方法，而此时 dialog 并未 attached to a context positive = getString(R.string.ai_base_policy_agree_and_continue) // 以下代码是正确用法，调用当前 Activity 的 Context.getString() 方法 negative = this@CurrentActivity.getString(R.string.somt_string) contentView = view onPositiveListener = &#123; &#125; onNegativeListener = &#123; finish() &#125;&#125; No.2 相邻的 Fragment 中使用 webview，出现加载异常的问题在项目中，一个页面中同时使用多个不同的 Fragment，比如 ViewPager 中有几个 Fragment 的场景，这几个 Fragment 同时加载，且其中有几个是有 WebView 的，这个时候就会出现当中的某一个或者几个出现异常的情况，原因是使用 Webview 加载不同的 url 时，会存在 js 及 css 动画执行异常的问题，当时使用的布局，Viewpager 中存在两个不同的 Fragment，在这两个 Fragment 中分别使用 Webview 加载了不同的页面（页面中使用了比较接近的js及样式），这个问题最后的解决办法是，当需要加载 Viewpager 时，只加载一个 Fragment 或者一个 Webview，切换 tab 标签时，再去动态更换加载其他的 URL，也就是懒加载 No.3 commit 和 commitAllowingStateLoss 区别及应用场景做 Android 开发，Fragment 是我们经常用的，我们在使用 Fragment 时，会像如下这样写： 1234567FragmentManager fm = getFragmentManager();testFragment = (TestFragment) fm.findFragmentById(R.id.fragment_container);if (testFragment == null) &#123; testFragment = new TestFragment(); fm.beginTransaction().add(R.id.fragment_container, testFragment).commit();&#125; 我们偶尔会碰到这样一个异常： 1Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState 大意是在 activity 的 onSaveInstanceState 调用过后，再 commit 的 Transaction 导致的异常，看到网上一些建议用 commitAllowingStateLoss 来代替 commit，那么 commit 和 commitAllowingStateLoss 有什么区别呢？查看下相关的代码： 1234567public int commit() &#123; return commitInternal(false);&#125;public int commitAllowingStateLoss() &#123; return commitInternal(true);&#125; 发现他们都是调用了commitInternal()方法，只是一个传了false，一个传了true，接着往下看： 1234567891011121314int commitInternal(boolean allowStateLoss) &#123; if (mCommitted) &#123; throw new IllegalStateException(&quot;commit already called&quot;); &#125; ... mCommitted = true; if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; mManager.enqueueAction(this, allowStateLoss); return mIndex;&#125; 主要是 mManager.enqueueAction(this, allowStateLoss) 来执行这个任务，根据传入的参数继续往下走，可以看到： 123456789101112131415161718public void enqueueAction(Runnable action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; throw new IllegalStateException(&quot;Activity has been destroyed&quot;); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;Runnable&gt;(); &#125; mPendingActions.add(action); if (mPendingActions.size() == 1) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125;&#125; 这里就是最后了，可以看到最开始传进来的 allowStateLoss 在这里只做了检查状态的操作 12345678private void checkStateLoss() &#123; if (mStateSaved) &#123; throw new IllegalStateException(&quot;Can not perform this action after onSaveInstanceState&quot;); &#125; if (mNoTransactionsBecause != null) &#123; throw new IllegalStateException(&quot;Can not perform this action inside of &quot; + mNoTransactionsBecause); &#125;&#125; 如果activity的状态被保存了，这里再提交就会检查这个状态，符合条件就抛出一个异常来终止应用进程，也就是说在 activity 调用了 onSaveInstanceState()之后，再 commit 一个事务就会出现该异常，那如果不想抛出异常，也可以很简单调用 commitAllowingStateLoss() 方法来略过这个检查就可以了，但是 Google 说这是危险的，在官方文档上有如下描述： Like {@link #commit} but allows the commit to be executed after an activity’s state is saved. This is dangerous because the commit can be lost if the activity needs to later be restored from its state, so this should only be used for cases where it is okay for the UI state to change unexpectedly on the user. 大意是如果 activity 随后需要从它保存的状态中恢复，这个 commit 是会丢失的，因此它仅仅适用在ui状态的改变对用户来说是可以接受的 因此可以得出几点结论： 在 activity 的生命周期方法中提交事务要小心，越早越好，比如 onCreate，也可以在接收用户的输入时来提交，尽量避免在 onActivityResult() 方法中提交 避免在异步的回调方法中执行 commit，因为他们感知不到当前 activity 生命周期的状态 使用 commitAllowingStateLoss() 代替 commit()，相比于 crash，我觉得 ui 状态的改变对用户来说是可以接受的，但是也要看场景，比如涉及到金融相关的场景，用户可能突然觉得钱没了(从ui上看)，那还不如crash让系统再重新拉起 App 呢 原文：Android commit和commitAllowingStateLoss区别及应用场景","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"https://enderhoshi.github.io/tags/Fragment/"}]},{"title":"开发笔记-UI","slug":"开发笔记-UI","date":"2024-03-05T07:00:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2024/03/05/开发笔记-UI/","link":"","permalink":"https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-UI/","excerpt":"关于 UI 实现的一些开发中的笔记","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 RecyclerView 隐藏 item（多布局）的所在区域显示空白在 RecyclerView 是多种布局的情况下，需要把 RecyclerView 的其中一个条目 GONE 掉，若只是把内容隐藏，这样就会出现一片空白区域，高度不会改变，解决方法是，隐藏时把 item 的高度宽度设置为 0，需要显示的时候再设置回来 12345678910111213if (type == TYPE1) &#123; // 某个类型，反正就是要隐藏的类型或者状态 val param = holder.itemView.layoutParams param.height = 0 param.width = 0 holder.itemView.layoutParams = param ...&#125; else &#123; // 其他类型，要显示的类型或者状态，恢复宽高 val param = holder.itemView.layoutParams param.height = ScreenUtil.dp2px(context, 46F) param.width = RelativeLayout.LayoutParams.MATCH_PARENT holder.itemView.layoutParams = param ...&#125; No.2 ListView getChildAt() 取得位置错误问题有时候我们需要获取 ListView 或 RecycleView 的某个 item 的 view 对象来做一些处理，发现使用 getChildAt(position: Int) 这个方法取到的不是想要的 item，而是可视的第 position 位置的 item，也就是说 position 只是从第一个可以看到的 item 算起的，这样就和实际列表中的第 position 个是不一样的，这样就需要使用如下代码来取得实际的位置 123val itemPosition = 1 // 想要修改的 item positionval targetPosition = itemPosition - listView.getFirstVisiblePosition() // 实际的目标 item positionval itemView = listView.getChildAt(targetPosition) 这里需要注意的是 itemView 在可视范围上方时，会返回 null，在源码中可以看到： 12345678910111213/** * Returns the view at the specified position in the group. * * @param index the position at which to get the view from * @return the view at the specified position or null if the position * does not exist within the group */public View getChildAt(int index) &#123; if (index &lt; 0 || index &gt;= mChildrenCount) &#123; return null; &#125; return mChildren[index];&#125; 所以需要对空值做一下处理 No.3 performClick 和 callOnclick 的区别View 类的 performClick 和 callOnclick 函数都可以实现点击，不用用户手动点击，直接触发 View 的点击事件。区别有如下两点： API 等级 performClick 是在 API 1 中加入，callOnClick 是在 API 15 中加入 代码实现层面 看两个方面的代码实现，如下： 1234567891011121314151617181920212223242526272829303132333435363738/*** Directly call any attached OnClickListener. Unlike &#123;@link #performClick()&#125;,* this only calls the listener, and does not do any associated clicking* actions like reporting an accessibility event.** @return True there was an assigned OnClickListener that was called, false* otherwise is returned.*/public boolean callOnClick() &#123; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; li.mOnClickListener.onClick(this); return true; &#125; return false;&#125;/** * Call this view&#x27;s OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 从代码中可以看出，callOnClick 是 performClick 的简化版，不包含点击播放声音，不具有辅助功能，辅助功能官方介绍如下： 许多 Android 用户有不同的能力（限制），这要求他们以不同的方式使用他们的 Android 设备。这些限制包括视力，肢体或与年龄有关，这些限制阻碍了他们看到或充分使用触摸屏，而用户的听力丧失，让他们可能无法感知声音信息和警报，Android 提供了辅助功能的特性和服务帮助这些用户更容易的使用他们的设备，这些功能包括语音合成、触觉反馈、手势导航、轨迹球和方向键导航。Android 应用程序开发人员可以利用这些服务，使他们的应用程序更贴近用户 No.4 android ems 具体意义在 android 里 setEms() 作用是设置 TextView 的字符宽度，em 是一个印刷排版的单位，表示字宽的单位，em 字面意思为：equal M（和M字符一致的宽度为一个单位）简称 em，而 ems 是 em 的复数表达，所以 ems 和字节什么的都是没关系的，只是和字宽度有关系，而且由于各个手机版本自定义字体等问题，所以设置 ems 意义不大，只能作为参考，当设置该属性后，控件显示的长度就为10个字符的长度，超出的部分将不显示，而且 EditText 的属性，只有在android:layout_width=&quot;wrap_content&quot; 时，才会显示，如果是 android:layout_width=&quot;match_parent&quot; 时，则不会有变化 No.5 图片显示上下有空白的解决办法在使用 ImageView 时，采用不同的 scaleType 属性可以调整图片的缩放类型，但是有时会导致图片上下方出现空白，这时就要设置 android:adjustViewBounds=&quot;true&quot; 关于 ImageView 的 adjustViewBounds 属性取值为 true 时： Adjust the ImageView’s bounds to preserve the aspect ration of its drawable. 调整 ImageView 的界限来保持图像纵横比不变。这并不意味着 ImageView 的纵横比就一定和图像的纵横比相同，XML定义里的 android:adjustViewBounds=&quot;true&quot; 会将这个 ImageView 的 scaleType 设为 fitCenter，不过这个 fitCenter 会被后面定义的 scaleType 属性覆盖（如果定义了的话），除非在 Java 代码里再次显式调用 setAdjustViewBounds(true) 1. 如果设置的 layout_width 与 layout_height 都是定值那么设置 adjustViewBounds 是没有效果的，ImageView 将始终是设定的定值的宽高 2. 如果设置的 layout_width 与 layout_height 都是 wrap_content那么设置 adjustViewBounds 是没有意义的，因为 ImageView 将始终与图片拥有相同的宽高比（但是并不是相同的宽高值，通常都会放大一些） 3. 如果两者中一个是定值，一个是 wrap_content比如 android:layout_width=&quot;100px&quot;，android:layout_height=&quot;wrap_content&quot; 时，ImageView 的宽将始终是 100px，而高则分两种情况： 当图片的宽小于 100px 时，layout_height 将与图片的高相同，即图片不会缩放，完整显示在 ImageView 中，ImageView 高度与图片实际高度相同，图片没有占满 ImageView，ImageView 中有空白 当图片的宽大于等于 100px 时，此时 ImageView 将与图片拥有相同的宽高比，因此 ImageView 的 layout_height 值为：100 除以图片的宽高比，比如图片是 500X500 的，那么 layout_height 是 100，图片将保持宽高比缩放，完整显示在 ImageView 中，并且完全占满 ImageView No.6 硬件加速导致画线不显示（有待深入研究，先总结现象） Android 9.0 drawLine drawPath 都可以正常实现画线，抗锯齿，实现虚线 Android 9.0 以下 drawLine 一定能画出线，但是不能画出虚线 (抗锯齿有效) drawPath 一定能画出虚线，但是大斜率的时候线会消失 (抗锯齿无效) 因为x y值过大，不进行绘制了 No.7 在约束布局中使用 include 标签报错在约束布局 ConstraintLayout 中引入了一个布局，然后给引入布局添加了底部约束，让它距离底部 8dp，但是引入布局仍然出现在顶部，并报错如下： 1Layout parameter layout_marginBottom ignored unless both layout_width and layout_height are also specified on &lt;include&gt; tag 在约束布局中引入新的控件或者布局时，若不重新指定一下控件或者布局的宽高，那么给它添加的约束便会失效，给 include 标签中添加上 layout_width 和 layout_height 属性即可 No.8 BottomSheetDialog 输入框输入文字时上下跳动开发中遇到一个问题，一个 BottomSheetDialog 里面有上下两个输入框，上方的输入框在软键盘弹出时，并没有被软键盘顶着，所以输入时，BottomSheetDialog 表现正常，但是下方的输入框，是被软键盘顶的，在输入时，BottomSheetDialog 中的 TextView 要根据输入的内容作出变化，这时，一旦 TextView 的属性为 wrap_parent ，他的的文字发生变化时，高度宽度随之发生变化，BottomSheetDialog 就会上下跃动，体验比较差，后来发现只要给定 TextView 的高度和宽度，就可以避免这个问题，比较低版本的 Android 系统中似乎不会出现，后续有待排查 No.9 关于 ViewPager 嵌套 RecyclerView，当 RecyclerView 滑动到尽头后，不希望 ViewPager 被连带拖动的情况有下面两种情况 当 RecyclerView 外部是一个自定义的 View，你可以在这个自定义的 View 中加入下面的代码，这样，外部可以判断如果 rv 不可滑动，就做一个类似拦截的操作，避免引起滑动（还需要研究 dispatchTouchEvent 相关内容，弄明白这样为什么有效）12345678910111213141516171819202122232425262728293031323334353637383940414243444546private int lastX = 0;private int lastY = 0;@Overridepublic boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean intercept = super.dispatchTouchEvent(ev); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: intercept = needIntercept(ev); break; default: &#125; lastX = (int)ev.getX(); lastY = (int)ev.getY(); return intercept;&#125;private boolean needIntercept(MotionEvent ev)&#123; // 水平滚动距离大于垂直滚动距离则拦截 float deltaX = ev.getX() - lastX; float deltaY = ev.getY() - lastY; boolean isHorizontal = Math.abs(deltaX) &gt; Math.abs(deltaY); if (isHorizontal) &#123; if (deltaX &gt; 0) &#123; // 往右滑动 return !recyclerView.canScrollHorizontally(-1); &#125; else &#123; // 往左滑动 return !recyclerView.canScrollHorizontally(1); &#125; &#125; else &#123; return true; &#125;&#125; 自定义一个 View 继承 RecyclerView，写如下代码，有点像内部拦截法，需要弄懂 requestDisallowInterceptTouchEvent 相关内容12345678@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; /*---解决垂直 ViewPager 嵌套水平 RecyclerView 横向滑动到底后不滑动 ViewPager start ---*/ ViewParent parent = this; while(!((parent = parent.getParent()) instanceof ViewPager)); // 循环查找 ViewPager parent.requestDisallowInterceptTouchEvent(true); return super.dispatchTouchEvent(ev);&#125; No.10 View 的一些踩坑1. GestureDetector 无反应使用 GestureDetector 时，无论什么手势，均无反应，解决方法：需要重写 onDown 方法，可看参考文章 2. 界面闪烁View 的逻辑不能太重，运算不能太多，重复调用的的 path 相关操作要记得 reset，可看参考文章 No.11 SurfaceView 重叠问题有时候我们会遇到页面内有两个 SurfaceView 的场景，比如有一个视频播放器在上方，下方是一个地图控件。正常使用时问题不大，一旦涉及到一些要设置显隐（View.VISIBLE、View.GONE）以及离开页面又回来的情形时，在某些 Android 高版本手机（测试时用的是）就会有一些异常出现，地图控件的内容会显示在视频播放器上，即使这两个控件本来的位置并不重合，这时候如果再设置一下控件的显隐或者位置（总之就是让它再发生一些布局变化刷新一下），又会恢复正常 初步猜测，经过离开页面又返回的这个过程后，控件位置会产生一些未知变化，然后两个 SurfaceView 显示会出现异常，页面内有这种情况，要注意规避，有以下的一些方案： 不能用 GONE 和 VISIBLE 控制显隐，需要使用 alpha 来控制（xml 中设置为 gone 都不行）；原理就是让空间不存在 GONE 或者 INVISIBLE 这种可能导致异常的状态。但是这样之后，点击事件不好处理，因为以前用了 GONE 和 INVISIBLE 之后，控件就点击不到了，用 alpha 控制的话，还要另外处理 想办法设置 SurfaceView 的背景色，遮盖掉底部地图不让其透出来；要注意等视频播放器出图像后又把背景色移除掉，否则背景色会一直存在导致视频内容被遮盖，这个方案缺点在于你要控制好设置背景色和移除背景色的时机，否则会有一瞬间出现底部的控件，看起来还是有些怪 用弹窗尝试改造页面；如果你的地图控件是弹出来的或者是点击后再显示的，这种方案其实是最佳的，可以把它写在另一个弹窗页面内，一方面和页面解耦，另一方面可以避免重叠问题 还有一种方案是设置 surfaceView.setZOrderOnTop(true)；这样可以让你想要放在顶层的 SurfaceView 始终位于顶层，但是要注意这样之后它就是最顶层的，没有其他控件能遮盖它了，看到有文章说再调用一下 surfaceView.setZOrderMediaOverlay(true) 可以解决，然而实际并没有用 No.12 补间动画重置问题因为公司代码框架的问题，切换 Tab 时，补间动画（也可以叫做 View 动画）没有保留在最后一帧，而是重置到第一帧了，一般情况下好像不会这样，但是现在出现了这个问题又不好改公司代码，所以换属性动画来实现，就解决了问题，这是因为属性动画是基于对象的实际属性进行修改，从而体现出动画，而补间动画只是 View 的一些动画体现，实际上 View 没有变化，所以不知道怎么就被重置了。这里简单记录一下，加深对两种动画之间的区别的认识。","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"UI","slug":"UI","permalink":"https://enderhoshi.github.io/tags/UI/"}]},{"title":"开发笔记-TextView & EditText","slug":"开发笔记-TextView & EditText","date":"2024-03-05T06:15:55.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2024/03/05/开发笔记-TextView & EditText/","link":"","permalink":"https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-TextView%20&%20EditText/","excerpt":"关于 TextView 和 EditText 的一些开发中的笔记","text":"开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅 No.1 TextView 添加 SpannableString 点击事件，并添加点击色12tv.movementMethod = LinkMovementMethod.getInstance() // 必须设置否则无法点击tv.highlightColor = SkinManager.resourcesTool.getColor(android.R.color.transparent) // 设置点击后的高亮颜色，这里设置为透明，即点击后无反应 No.2 TextView 添加下划线并抗锯齿1textView.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG); No.3 TextView 中 Emoji 变淡TextView 中有 Emoji 时，Emoji 会变淡发白，具体的表现如该文章中后半部分图片所示，评论中也有人提及 具体的解决办法：设置 textColor 后即可，可能与文字颜色相关，具体原理未知 No.4 EditText maxLines 不生效的问题这是由于 android:inputType 属性默认值为 none 的缘故，设置 maxLines 后，再设置一下 inputType，就可以正常生效了 如果要设置单行的话，设置 singleLine 为 true 可以生效，但是 singleLine 已经过期了，提示用使用 android:maxLines=&quot;1&quot; 代替，设置之后也要记得设置一下 inputType，否则会没有效果。同理 TextView 应该也是一样 No.5 EditText showSoftInput 不起作用有的时候需要在界面一显示时就让输入框处于焦点状态，并且需要键盘弹出，方便用户输入，需要以下代码 12android:focusable=&quot;true&quot;android:focusableInTouchMode=&quot;true&quot; 123editText.requestFocus()val inputManager = editText.context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManagerinputManager.showSoftInput(editText, InputMethodManager.SHOW_IMPLICIT) 有时当该 EditText 还未被绘制出来，InputMethodManager 还不能获取到该控件的焦点，软键盘不会弹出，manager.showSoftInput() 函数返回 false，告诉你键盘并未显示，而当 EditText 完全被绘制出来了，就可以去获取焦点了，所以需要添加绘制完毕监听，当 EditText 被绘制完毕时，调用 onGlobalLayoutListener.onGlobalLayout，正确展示键盘 123editText?.viewTreeObserver?.addOnGlobalLayoutListener &#123; showKeyboard(editText)&#125; 相关链接 No.6 EditText 输入中文时出现下划线拼音处理在开发过程中，有时候会需要监听 EditText 输入内容长度做出反应的操作，但是像某些手机如小米的输入机制，会在输入中文的时候出现带下划线的拼音，这种情况影响了 EditText 输入长度监听 处理方法： 123456789101112131415161718192021222324// 首先新建一个 自定义 InputFilter 继承 InputFilter// 重写 filter() 方法，在filter 中过滤带下划线的字符/** * @param start 新输入的字符串起始下标，一般为0 * @param end 一次性输入的长度，删除为 0 * @param dest 原内容起始坐标 * @param dstart 原内容终点坐标 */override fun filter(source: CharSequence?, start: Int, end: Int, dest: Spanned?, dstart: Int, dend: Int): CharSequence &#123; // 下划线字符不输入，避免输入中文的时候出现带下划线的拼音，这种情况影响了 EditText 输入长度监听 val spannableString = SpannableString(source) val spans = spannableString.getSpans(0, spannableString.length, Any::class.java) if (spans != null) &#123; for (span in spans) &#123; if (span is UnderlineSpan) &#123; // 带下划线的 span return &quot;&quot; &#125; &#125; &#125;&#125;// 最后把 filters 设置到 editText 中 see MaxLengthInputFilterdialog_edit.filters = arrayOf(MaxLengthInputFilter(5)) InputFilter 是系统提供的一个接口类，里面只有一个方法 filter()，用于过滤输入&#x2F;插入的字符串，返回值为 CharSequence 12345678910111213141516171819202122232425262728293031public interface InputFilter &#123; CharSequence filter(CharSequence var1, int var2, int var3, Spanned var4, int var5, int var6); public static class LengthFilter implements InputFilter &#123; public LengthFilter(int max) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; public int getMax() &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; &#125; public static class AllCaps implements InputFilter &#123; public AllCaps() &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; public AllCaps(@NonNull Locale locale) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; &#125;&#125; No.7 Edittext 设置 inputType 为密码不能生效1234567891011// 设置密文的时候，需要同时设置 TYPE_CLASS_TEXT 才能生效et_price.setInputType(InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD）// 设置小数et_price.setInputType(InputType.TYPE_NUMBER_FLAG_DECIMAL or InputType.TYPE_CLASS_NUMBER）// 设置无符号小数et_price.setInputType(InputType.TYPE_NULL or InputType.TYPE_CLASS_NUMBER or InputType.TYPE_NUMBER_FLAG_DECIMAL)// 设置有符号小数et_price.setInputType(InputType.TYPE_NUMBER_FLAG_SIGNED or InputType.TYPE_CLASS_NUMBER or InputType.TYPE_NUMBER_FLAG_DECIMAL) No.8 EditText 全角半角问题密码默认全角，需要设置半角以免影响 hint 的字体，设置半角需要在设置 inputType 之后，且全角半角可能会影响行数，出现即使设置了 maxLines 也无效的情况，切换明文密文显示，会让 digits 设置无效，需要另外实现 InputFilter","categories":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"TextView","slug":"TextView","permalink":"https://enderhoshi.github.io/tags/TextView/"},{"name":"EditText","slug":"EditText","permalink":"https://enderhoshi.github.io/tags/EditText/"}]},{"title":"Git 速查","slug":"Git 速查","date":"2022-03-09T08:06:28.000Z","updated":"2025-07-09T09:33:16.187Z","comments":true,"path":"2022/03/09/Git 速查/","link":"","permalink":"https://enderhoshi.github.io/2022/03/09/Git%20%E9%80%9F%E6%9F%A5/","excerpt":"Git 相关日常用法查阅","text":"日常开发中，我们会用到一些 Git 的指令，有的比较常用，已经烂熟于心了，但是还有一些比较重要但是没有那么常用的，每次要用时记忆总有偏差，需要重新 Google 具体的用法，现在统一记录一下，方便以后查阅 1. 关于 Tag删除本地 Tag 的指令比较简单，如下 1git tag -d your-tag 如果要推送某个标签到远程，使用命令 1git push origin your-tag 或者，一次性推送全部尚未推送到远程的本地标签 1git push origin --tags 但是，如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 1git tag -d your-tag 然后，从远程删除，比较怪异和难记的就是这个，删除命令也是 push，但是格式如下： 1git push origin :refs/tags/your-tag 参考文章1 参考文章2 2. 设置 AS 内 git 环境为 git-bashgit-bash 的命令窗口操作，界面比 cmd 或 AS Terminal 美观，功能也强大，如果想要在 AS 内使用，可以设置一下 设置路径为 Settings… -&gt; Tools -&gt; Terminal，将其中的 Shell path 设置为你电脑中 git 目录下的 X:\\Program Files\\Git\\bin\\bash.exe，注意这个是让 Terminal 直接变成 git-bash 模式的，如果直接选择 git 目录下即 X:\\Program Files\\Git\\git-bash.exe 的话，会变成弹窗模式 参考文章 3. git-bash 中文乱码解决方法打开 git-bash，输入平时常用的命令如 ipconfig、systeminfo 等，输出的结果中英文是正常的，但是中文是乱码，可以做如下操作 打开 GitBash（git-bash.exe）后，对窗口右键 -&gt; Options -&gt; Text -&gt; Locale 改为 zh_CN，Character set 改为 GBK 键入 exit 退出关闭再打开即可 参考文章 4. 撤销 merge、amend撤销上一次 merge 的命令 1git reset --hard HEAD~ 撤销上一次 amend 1git reset HEAD@&#123;1&#125; 5. 生成 SSH Key这个也算重要和常见，但是有时一旦弄好环境，很久都不需要再次使用，所以又会记不太住，基本步骤如下： 生成 ssh key 1ssh-keygen -o 进入相关目录查看文件 12cd ~/.sshls 输出 key 的内容 1cat ~/.ssh/id_rsa.pub 具体效果演示如下 12345678910111213141516171819202122232425262728293031323334DDP@DESKTOP-EP4ME0S MINGW64 ~$ ssh-keygen -oGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/DDP/.ssh/id_rsa):Created directory &#x27;/c/Users/DDP/.ssh&#x27;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/DDP/.ssh/id_rsaYour public key has been saved in /c/Users/DDP/.ssh/id_rsa.pubThe key fingerprint is:SHA256:kQEwgBu5dCyJVCdXtqou2dpqeUfs8hgZvL8/q9UOuqk DDP@DESKTOP-EP4ME0SThe key&#x27;s randomart image is:+---[RSA 3072]----+|o+=+o+o+. ||=+ o+.. .o ||.+o .o ||o . . . || o.. S || =o . || +=o o . || =o++o+.o ||.o=E=O=oo. |+----[SHA256]-----+DDP@DESKTOP-EP4ME0S MINGW64 ~$ cd ~/.sshDDP@DESKTOP-EP4ME0S MINGW64 ~/.ssh$ lsid_rsa id_rsa.pubDDP@DESKTOP-EP4ME0S MINGW64 ~/.ssh$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDDPLcVlpXBAQ0/Gld6PXI3DxvduQu0nFc06dOionC2IfEp54EJvNWizS487wQnJj1Esg8vMVr7i2sM8imc2FyP2QXb8YCIZLhtjeXDk+Ihaq62f5/CfrgZNPVOj7xk73W0AlAxmfaV5GjJGejrC0+RtHkhLxeayGMwaNZrPaRbkv0PzA7mEglN8yNenzNaheHXe2bYvrVulTXg1YZUDZlDkzo4vwbOHCevVNxol3Q3UHq903KZsW/AM17CFk2fhNxvhbtHQWtfEoBQ3xvDQJqQLXnZCMw6rFsgpXxH4oB1HmuQOlwS3M8skDj9ogVrzZx1+TM3R215bzwzaco9iQVJRB4JD7TbV6XRKYUd7pHwn5GZe5xcb9LZYkrv2QGtjsf8Rimjd6//NJ2blZ5cnQRc8eMsGSTJoigS0N3VNPfa9ERGGj1ek9yZ9ZGcQN8gOPZl0oFFTlEy0MjWCq9Vddfp4vKhmvJ8OTSQ2OvPuhHcLDKSeVvLMFYXAIcFA05kCTU= DDP@DESKTOP-EP4ME0S 6. 切换 ssh 和 http 协议 查看当前 remote 1git remote -v 切换到 http： 1git remote set-url https://github.com/username/repository.git 切换到ssh： 1git remote set-url git@github.com:username/repository.git 也可以直接改当前 git 目录里面有个配置文件，路径是 .git/config，大致如下，修改 url 即可，有时候 fetch 和 push 的 url 会不一样，如果没额外写出来的话，应该就是默认一致的 1234567891011121314151617[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = git@github.com:EndeRHoshI/hoshi-blog.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[gui] wmstate = normal geometry = 841x483+156+156 189 218 据评论说不正确，暂时还未做验证，如果有问题，还可参考下面的 先增加新的协议 1git remote set-url --add origin https://gitee.com/zjZSTU/zjzstu.gitee.io.git 再删除原先的协议 1git remote set-url --delete origin git@gitee.com:zjZSTU/zjzstu.gitee.io.git 参考文章 7. 解决 The authenticity of host ‘gitee.com (180.97.125.228)’ can’t be established. 问题具体情形如下： 1234567HoShI@DESKTOP-050RN3C MINGW64 /f/RiskOfRainPhoto (master)$ ssh -T git@gitee.comThe authenticity of host &#x27;gitee.com (180.97.125.228)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;gitee.com,180.97.125.228&#x27; (ECDSA) to the list of known hosts.Hi Hoshi! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access. 其原因为：在新生成密钥之后，在 .ssh 文件夹中少了一个 known_hosts 文件，本来密钥文件应该是三个，现在是两个，便报了这样的错误，此时选择 yes 回车之后，便可，会生成缺少了的 known_hosts 文件 参考文章 8. github action 签名问题：如何保证自己的 keystore 文件安全？ 如果整个项目都是私有的，你不会开放它，那么你可以直接上传你的 keystore 如果你的项目是公开的，有以下两个方法 上传一个加密过的 keystore 文件，将你的密钥写到 github secret 里面，要使用的时候再解密 上传 keystore 到一个私有库中，要使用的时候，再从私有库拉取，把私有库的凭证例如账号密码之类的写到 github secret 里面 9. 修改 Git 用户名或邮箱查看用户名和邮箱： 1234567# 当前项目git config user.namegit config user.email# 全局git config --global user.namegit config --global user.email 如果要修改，则直接在后面加上目标字符串，如下： 1234567# 当前项目git config user.name targetNamegit config user.email targetName# 全局git config --global user.name targetNamegit config --global user.email targetName 参考文章 10. 修改远端提交记录修改提交信息修改最近一次 commit 信息，可以直接用 amend，使用后，你会进入文本编辑器，修改 commit 信息保存后就可以更新 commit 信息 1git commit --amend 修改多条 commit 信息，例如想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 HEAD~2 或 HEAD~3 1git rebase -i HEAD~3 使用上述命令后，会出现类似的界面 123456789101112131415161718192021pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file# Rebase 710f0f8..a5f4a0d onto 710f0f8## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 如果你想更改第一条 commit 信息，把第一条 commit 信息对应的 pick 更改为 edit 然后 ESC + :wq 保存退出，运行 1git rebase --amend 运行上述命令后在弹出文本编辑界面重新提交 commit 信息，完成后保存退出。运行 1git rebase --continue 所有的 commit 信息都修改完之后运行一下命令将更改推送到远程 1git push origin master --force 参考文章 修改提交记录用户名12345678910111213# 第一步，（n）代表提交次数git rebase -i HEAD~n # 第二步然后按`i`编辑，把`pick` 改成 `edit`，按&#x27;Esc&#x27;退出编辑，按`:wq`保存退出 # 第三步git commit --amend --author=&quot;作者 &lt;邮箱@xxxx.com&gt;&quot; --no-edit # 第四步git rebase --continue # 第五步git push --force 要注意，如果 master 分支是受保护的，无法直接强制推上去，那就需要分开其他分支如 develop 分支，方便此类操作以及后续的分支管理 参考文章 11. Git 远程仓库地址变更本地如何修改由于各种原因，作为 Git 仓库的服务器 IP 地址变了，本地代码太多，重新检出会花很多时间，这时就可以修改一下配置让本地仓库和新的远程仓库建立关联 方法有很多，这里简单介绍几种，以下均以项目 git_test 为例： 123老地址：http://192.168.1.12:9797/hoshi/git_test.git新地址：http://192.168.100.235:9797/hoshi/git_test.git远程仓库名称： origin 方法一 通过命令直接修改远程地址 进入 git_test 根目录 git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 git remote set-url origin http://192.168.100.235:9797/hoshi/git_test.git 方法二 通过命令先删除再添加远程仓库 进入 git_test 根目录 git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 git remote rm origin git remote add origin http://192.168.100.235:9797/hoshi/git_test.git 方法三 直接修改配置文件 进入 git_test&#x2F;.git vim config 1234567891011[core]repositoryformatversion = 0filemode = truelogallrefupdates = trueprecomposeunicode = true[remote &quot;origin&quot;]url = http://192.168.100.235:9797/shimanqiang/assistant.gitfetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;]remote = originmerge = refs/heads/master 修改 [remote “origin”] 下面的 url 即可 方法四 通过第三方git客户端修改。以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件，同样可以完成方法三 摘自他人的文章，原文链接 12. git reflog 以及 git reset有时候我们做了一些错误的操作，可以使用 git reflog 查看操作日志以及 git reset 来进行撤回 执行 git reflog，可以查看所有操作日志： 123456789101112131415161718git reflog8dd0780f2e (HEAD -&gt; temp/extend_warranty_2) HEAD@&#123;0&#125;: rebase (continue) (finish): returning to refs/heads/temp/extend_warranty_28dd0780f2e (HEAD -&gt; temp/extend_warranty_2) HEAD@&#123;1&#125;: rebase (continue) (pick): 初步实现积分中心框架cb5b611664 HEAD@&#123;2&#125;: rebase (continue): 初步实现单设备、多设备界面框架5e60393df3 HEAD@&#123;3&#125;: rebase (pick): 增加激励广告cdc046373e HEAD@&#123;4&#125;: rebase (pick): 调整异步工具类；调整 Span 工具类d887d18e29 HEAD@&#123;5&#125;: rebase (pick): 移除本地冗余 MagicIndicator；初步实现 πStore 页面框架c894b70de3 (origin/temp/dev-7.1.5, temp/dev-7.1.5) HEAD@&#123;6&#125;: rebase (start): checkout origin/temp/dev-7.1.5b89a45651b HEAD@&#123;7&#125;: reset: moving to HEADb89a45651b HEAD@&#123;8&#125;: checkout: moving from temp/dev-7.1.5 to temp/extend_warranty_2c894b70de3 (origin/temp/dev-7.1.5, temp/dev-7.1.5) HEAD@&#123;9&#125;: checkout: moving from ui7.0-kotlin-lvqx to temp/dev-7.1.5496ffa9056 (ui7.0-kotlin-lvqx) HEAD@&#123;10&#125;: commit (amend): 调整 Gradle 版本，初步引入 Kotlin，并编写 Kotlin 示例类3d81c02df2 HEAD@&#123;11&#125;: checkout: moving from temp/dev-admin-lvqx to ui7.0-kotlin-lvqx3732cde39b HEAD@&#123;12&#125;: checkout: moving from temp/extend_warranty_2 to temp/dev-admin-lvqxb89a45651b HEAD@&#123;13&#125;: commit: 初步实现积分中心框架d9b3616a1f HEAD@&#123;14&#125;: commit: 初步实现单设备、多设备界面框架47f0792ecf HEAD@&#123;15&#125;: commit: 增加激励广告 仔细查看记录，比如我想撤回到从分支 dev-7.1.5 切换到 extend_warranty_2 的那个状态，即 HEAD@{8} 的内容 执行命令 git reset --hard 回到初始状态 123git reset --hard HEAD@&#123;26&#125;或者git reset --hard bbc9da41b5 如果错误地使用了 git commit –amend，也就是在 AS 中提交时，手滑点了右上角的 Amend commit，导致上一次的提交被覆盖了，丢失了提交记录，或者导致分支状况不一致无法上传到远端服务器，这时就要想办法撤销掉这个错误的 amend commit，回到之前的状态，解决方法如下： 首先使用 git reflog 命令查看操作记录： 123$ git reflog6889e84 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (amend): modified 1/2/3.txtb82585f HEAD@&#123;1&#125;: commit: modified 1/2.txt 然后可以看到你的 amend commit，之后再使用 git reset，其中 reset 后面的就是你在 reflog 命令中查到的 id，或者后面的 HEAD@{x} 1$ git reset b82585f 不使用 git reset --hard 的目的就是为了保留本地修改，否则修改就会被丢弃，如果一个 commit 被 amend 了多次, 也可以用这种方法撤销到任意一次 amend 处: 1234567$ git reflog937fd53 HEAD@&#123;0&#125;: commit (amend): add blank line to index.html7589755 HEAD@&#123;1&#125;: commit (amend): add blank line to index.htmlf7ade82 HEAD@&#123;2&#125;: commit (amend): add blank line to index.htmlc1c1b21 HEAD@&#123;3&#125;: commit (amend): add blank line to index.html9ff821d HEAD@&#123;4&#125;: commit: add blank line to index.html$ git reset --soft HEAD@&#123;2&#125; 由此看来，不只是 rebase 可以撤回，很多操作都可以通过这个方法撤回 参考文章 13. 端口 22 超时端口 22 超时问题，报错如下，解决方法，另外的参考文章，终极解决问题文章，修改 host 12345ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 注意整完之后，好像用 https 协议不行了，报错 https 地址 + Failed to connect to github.com port 443 after 21077 ms: Timed out 14. git gc 相关问题在对 Git 库执行一些操作命令时（比如 git am，git pull，git push 等操作）的时候，会出现类似如下提示（作者是在用 git am 打 patch 时出现的，其他情况也是一回事）： 12345ronny@ronny:~/tmpgitrepol$ git am ~/03patch/kernel/0001-add-kernel-version.patch --keep-crApplying: add kernel version for compileAuto packing the repository for optimum performance. You may alsorun &quot;git gc&quot; manually. See &quot;git help gc&quot; for more information.Counting objects: 84286, done. 而且 git am 后不退出，必须要 Ctrl + C 退出。（其实是 git 在将松散对象打包，这个需要时间，没有执行完打包，所以没退出） 里面主要关心如下两句： 12Auto packing the repository for optimum performance. You may alsorun &quot;git gc&quot; manually. See &quot;git help gc&quot; for more information. 当有这个提示的时候，直接运行 git gc，就可以了。 原因：Git 往磁盘保存对象时默认使用的格式叫松散对象 (loose object) 格式。Git 时不时地将这些对象打包至一个叫 packfile 的二进制文件以节省空间并提高效率。当仓库中有太多的松散对象则就会提示你运行 git gc 我们可以运行 find .git/objects -type f 命令，查看一下 objects 目录里有多少对象，然后运行 git gc 之后再看看剩下多少对象 git gc 后，接下来再执行 git 命令的时候就没有出现提示的情况了 摘自他人的文章，原文链接 15. 修改历史 commit平时如果我们刚刚提交完，发现有问题，可以用 amend 的方法来修改上一次的提交，但是如果是前几个提交中有需要修改的地方，就要用到下面的方法 首先 git rebase -i HEAD~10 查看最近十条提交记录（也可以指定其他条数），会得到下面的结果： 然后我们按 i 进入编辑模式，把需要修改的那一条提交前面的 pick 改为 edit，再按 ESC 退出编辑模式，:wq 退出当前编辑器 这时我们回到终端界面，再用指令 git commit --amend 更新提交信息，然后 git rebase --continue 结束当前这条的修改，进行下一条，循环执行这两条指令，直到最后提示你 rebase successfully，就全部完成了，下面是前后对比，我把第二第三条提交的 :bugfix: 改成 :bug: 了","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"git","slug":"git","permalink":"https://enderhoshi.github.io/tags/git/"}]},{"title":"OkHttp 的一个 IllegalStateException 探索","slug":"OkHttp 的一个 IllegalStateException 探索","date":"2020-01-15T02:09:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2020/01/15/OkHttp 的一个 IllegalStateException 探索/","link":"","permalink":"https://enderhoshi.github.io/2020/01/15/OkHttp%20%E7%9A%84%E4%B8%80%E4%B8%AA%20IllegalStateException%20%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"在使用 OkHttp 框架处理请求时，容易会有如下写法： 12val responseBody = response.body() ?: return nullLog.d(&quot;responseBody = &quot; + response.body()) 有时候，我们会直接写 response.body()，而不会再创建一个 String 对象，如果能确保只调用一次，这个是没什么问题的，但是如果向上面那样，在 Log 中又调用了一次，或者这个方法被多次调用，而且 response 是同一个，那么就会报如下错误： 1java.lang.IllegalStateException: closed 那么为何 response.body().string() 只能调用一次？ 拆解来看，先通过 response.body() 得到 ResponseBody 对象（是一个抽象类，在此我们不需要关心具体的实现类），然后调用 ResponseBody 的 string() 方法得到响应体的内容 分析后 body() 方法没有问题，我们往下看 string() 方法： 123public final String string() throws IOException &#123; return new String(bytes(), charset().name());&#125; 很简单，通过指定字符集（charset）将 byte() 方法返回的 byte[] 数组转为 String 对象，构造没有问题，继续往下看 byte() 方法： 123456789101112public final byte[] bytes() throws IOException &#123; //... BufferedSource source = source(); byte[] bytes; try &#123; bytes = source.readByteArray(); &#125; finally &#123; Util.closeQuietly(source); &#125; //... return bytes;&#125; 在 byte() 方法中，通过 BufferedSource 接口对象读取 byte[] 数组并返回，结合上面提到的异常信息 closed，可以注意到 finally 代码块中的 Util.closeQuietly() 方法，就是在执行完后，他会默默地关闭 再来看看这个方法 12345678910public static void closeQuietly(Closeable closeable) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (RuntimeException rethrown) &#123; throw rethrown; &#125; catch (Exception ignored) &#123; &#125; &#125;&#125; 原来，上面提到的 BufferedSource 接口，根据代码文档注释，可以理解为资源缓冲区，其实现了 Closeable 接口，通过复写 close() 方法来 关闭并释放资源，接着往下看 close() 方法做了什么（在当前场景下，BufferedSource 实现类为 RealBufferedSource）： 12345678910//持有的 Source 对象public final Source source;@Overridepublic void close() throws IOException &#123; if (closed) return; closed = true; source.close(); buffer.clear();&#125; 很明显，通过 source.close() 关闭并释放资源，说到这儿， closeQuietly() 方法的作用就不言而喻了，就是关闭 ResponseBody 子类所持有的 BufferedSource 接口对象 分析至此，我们恍然大悟：当我们第一次调用 response.body().string() 时，OkHttp 将响应体的缓冲资源返回的同时，调用 closeQuietly() 方法默默释放了资源。 如此一来，当我们再次调用 string() 方法时，依然回到上面的 byte() 方法，这一次问题就出在了 bytes &#x3D; source.readByteArray() 这行代码，继续看看 RealBufferedSource 的 readByteArray() 方法： 12345@Overridepublic byte[] readByteArray() throws IOException &#123; buffer.writeAll(source); return buffer.readByteArray();&#125; 继续往下看 writeAll() 方法： 123456789@Overridepublic long writeAll(Source source) throws IOException &#123; //... long totalBytesRead = 0; for (long readCount; (readCount = source.read(this, Segment.SIZE)) != -1; ) &#123; totalBytesRead += readCount; &#125; return totalBytesRead;&#125; 问题出在 for 循环的 source.read() 这儿。还记得在上面分析 close() 方法时，其调用了 source.close() 来关闭并释放资源，那么，再次调用 read() 方法会发生什么呢： 1234567@Overridepublic long read(Buffer sink, long byteCount) throws IOException &#123; //... if (closed) throw new IllegalStateException(&quot;closed&quot;); //... return buffer.read(sink, toRead);&#125; 所以就抛出了上面所说的异常了，为什么要这么设计呢？因为在实际开发中，响应主体 RessponseBody 持有的资源可能会很大，所以 OkHttp 并不会将其直接保存到内存中，只是持有数据流连接，只有当我们需要时，才会从服务器获取数据并返回。同时，考虑到应用重复读取数据的可能性很小，所以将其设计为一次性流(one-shot)，读取后即“关闭并释放资源”。 原文：OkHttp踩坑记：为何 response.body().string() 只能调用一次？","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"OkHttp","slug":"OkHttp","permalink":"https://enderhoshi.github.io/tags/OkHttp/"}]},{"title":"Android TextToSpeech 使用指南","slug":"Android TextToSpeech 使用指南","date":"2019-11-25T12:06:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2019/11/25/Android TextToSpeech 使用指南/","link":"","permalink":"https://enderhoshi.github.io/2019/11/25/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"最近要做一个资讯朗读功能，当用户点击播放按钮时，把文章中的文字转化成声音播报出来 搜索了一番，类似的功能实现有如下几种： 科大讯飞 百度语音 云知声 ROKID Google Cloud 以上的产品，要么就是收费，要么就是接入和维护相对这样的一个小功能来说，比较困难，性价比低，所以最后决定动用 Android 原生提供的 TextToSpeech 来处理文字转语音的功能 Android 原生的 TextToSpeech 目前已经支持中文播放，而在一些国产测试机如小米、华为、vivo上跑了 TextToSpeech 的测试 demo，也是可以播报中文的，不过只是语音引擎不一样而已 查看小米手机的系统设置，发现其默认的 tts 是小爱同学引擎，那么其实只要使用不同的引擎搭配不同的语音包，一样可以实现文字转语音功能，但是考虑到安装包大小的问题，还是老老实实使用原生的 TextToSpeech 了 谷歌的详细设置 小米的详细设置 华为的详细设置 Android文字转语音引擎（TTS）简单比较及下载 工具类代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 文本阅读（TTS） 管理器 * @author lv.qx on 2019/11/25 */class TextToSpeechManager(context: Context) &#123; private var ttsErrorStatus: Int = 0 private var tts: TextToSpeech? = null init &#123; tts = TextToSpeech(context) &#123; status -&gt; ttsErrorStatus = if (status == TextToSpeech.SUCCESS) &#123; TextToSpeech.SUCCESS &#125; else &#123; TextToSpeech.ERROR &#125; &#125; val tts = tts if (ttsErrorStatus == TextToSpeech.SUCCESS &amp;&amp; tts != null) &#123; // 默认设定语言为中文，原生的 android 貌似不支持中文。 ttsErrorStatus = when &#123; tts.availableLanguages == null -&gt; TextToSpeech.LANG_NOT_SUPPORTED tts.availableLanguages.contains(Locale.CHINESE) -&gt; tts.setLanguage(Locale.CHINESE) tts.availableLanguages.contains(Locale.SIMPLIFIED_CHINESE) -&gt; tts.setLanguage(Locale.SIMPLIFIED_CHINESE) tts.availableLanguages.contains(Locale.TRADITIONAL_CHINESE) -&gt; tts.setLanguage(Locale.TRADITIONAL_CHINESE) else -&gt; TextToSpeech.LANG_NOT_SUPPORTED &#125; &#125; &#125; /** * 设置音调，值越大声音越尖（女生），值越小则变成男声，默认值为 1.0 */ fun setPitch(pitch: Float) &#123; val tts = tts ?: return tts.setPitch(pitch) &#125; /** * 设置语速，默认值为 1 */ fun setSpeechRate(rate: Float) &#123; val tts = tts ?: return tts.setSpeechRate(rate) &#125; /** * 读文本 * @param content 文本内容 * @param utteranceProgressListener 阅读进度监听 */ fun speak( content: String, utteranceProgressListener: GetLastSegUtteranceProgressListener ) &#123; val tts = tts ?: return tts.setOnUtteranceProgressListener(utteranceProgressListener) when (ttsErrorStatus) &#123; TextToSpeech.LANG_MISSING_DATA -&gt; showToast(R.string.voice_missing_data) TextToSpeech.LANG_NOT_SUPPORTED -&gt; showToast(R.string.voice_lang_not_supported) ANDROID_VERSION_NOT_SUPPORT -&gt; showToast(R.string.voice_android_version_not_supported) else -&gt; &#123; if (tts.isSpeaking) &#123; tts.stop() &#125; else &#123; val textSeg = genSegment(content, 10) utteranceProgressListener.setLastSegId(SEG_PREFIX + (textSeg.size - 1)) for (i in textSeg.indices) &#123; // QUEUE_ADD：播放完之前的语音任务后才播报本次内容，QUEUE_FLUSH：丢弃之前的播报任务，立即播报本次内容 tts.speak(textSeg[i], TextToSpeech.QUEUE_ADD, null, SEG_PREFIX + i) &#125; &#125; &#125; &#125; &#125; /** * 将源文本分段 * * @param segmentLength 每一段的长度，最大设置 3999，大于 3999 将阅读出错 * @param originStr 源文本 * @return 分成的文本段 */ private fun genSegment(originStr: String, segmentLength: Int = 3999): Array&lt;String?&gt; &#123; val originLength = originStr.length val arraySize = originLength / segmentLength + 1 val result = arrayOfNulls&lt;String&gt;(arraySize) for (i in 0 until arraySize) &#123; result[i] = originStr.substring(i * segmentLength, min((i + 1) * segmentLength, originLength)) &#125; return result &#125; /** * 取得文本内容大约分钟长度 */ fun getSpeechLength(content: String): Int &#123; val totalSecond = (content.length / 3.7).toInt() return totalSecond / 60 &#125; /** * 扩展 onDone 方法的进度监听 */ @SuppressLint(&quot;NewApi&quot;) abstract class GetLastSegUtteranceProgressListener : UtteranceProgressListener() &#123; private var lastSegId = &quot;&quot; /** * 设置最后一段的 id */ fun setLastSegId(lastSegId: String) &#123; this.lastSegId = lastSegId &#125; override fun onDone(utteranceId: String?) &#123; onDone(utteranceId, lastSegId == utteranceId) &#125; /** * @param isLastSeg 是否是最后一段 */ abstract fun onDone(utteranceId: String?, isLastSeg: Boolean) &#125; companion object &#123; private const val SEG_PREFIX = &quot;seg&quot; // 段落前缀 private const val ANDROID_VERSION_NOT_SUPPORT = -3 // 版本不支持 &#125;&#125; 简单使用如下 1234567891011121314151617181920212223242526val ttsManager = TextToSpeechManager(this)···ttsManager.speak( binding.voiceText.text.toString(), object : TextToSpeechManager.GetLastSegUtteranceProgressListener() &#123; override fun onStart(utteranceId: String?) &#123; // 开始阅读 &#125; override fun onStop(utteranceId: String?, interrupted: Boolean) &#123; // 停止阅读 &#125; override fun onDone(utteranceId: String?, isLastSeg: Boolean) &#123; // 每一段结束时调用，通过 stop() 停止则不会调用这里 if (isLastSeg) &#123; // 这里是最后一段 &#125; &#125; override fun onError(utteranceId: String?) &#123; // 阅读出错 &#125; &#125;) 参考文章 Android TTS TextToSpeek 的使用记录 Android 原生 TTS 的基本使用以及配合中文语音包实现中文 TTS","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"}]},{"title":"如何正确终止 forEach | Kotlin操作符（run、with、let、also、apply）的差异","slug":"如何正确终止 forEach Kotlin 操作符(run、with、let、also、apply)的差异与选择","date":"2019-11-14T13:16:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2019/11/14/如何正确终止 forEach Kotlin 操作符(run、with、let、also、apply)的差异与选择/","link":"","permalink":"https://enderhoshi.github.io/2019/11/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2%20forEach%20Kotlin%20%E6%93%8D%E4%BD%9C%E7%AC%A6(run%E3%80%81with%E3%80%81let%E3%80%81also%E3%80%81apply)%E7%9A%84%E5%B7%AE%E5%BC%82%E4%B8%8E%E9%80%89%E6%8B%A9/","excerpt":"","text":"如何正确终止 forEach在一次编码中，我发现我的 forEach 函数使用 return@forEach 无法跳出遍历，而是会把所有元素都遍历完，使用 return 的话会直接跳出整个函数体，自然是不符合的，于是我做了些试验，想要得出真正跳出 forEach 遍历的方法 假设我们需要输出一个列表的一部分内容，可以用到 for 循环加个 break 来处理，如下： 12345val list = listOf(1, 3, 5, 7, 9)for (e in list) &#123; if (e &gt; 3) break println(e)&#125; 很简单，当 e 大于 3 时，就会跳出 for 循环，也就是说，会输出 1 和 3 两个数字： 如果改成用 forEach 呢，就会是下面这样： 12345val list = listOf(1, 3, 5, 7, 9)list.forEach &#123; if (it &gt; 3) ??? println(it)&#125; 这里的 ??? 应当填写什么呢，我第一反应就写了个 return@forEach，跑起来之后发现，确实达到了我们的效果 那么为什么我在程序中就不行呢？观察之后，我做了下面的变化： 12345val list = listOf(1, 3, 5, 7, 9)list.forEach &#123; println(it) if (it &gt; 3) return@forEach&#125; 这样之后呢，有一些细微的不同，就是会多输出一个 5 而已，因为输出了 5 才执行到 return@forEach 语句，这个也是很简单的 但是跑起来之后就不一样了，居然是下面这样的 原来，上面的例子只是每次大于 3 的时候都跳过了，最多相当于一个 continue，而没有达到 break 的效果，也就是说，在 Lambda 表达式中，return 返回的是所在函数，return@xxx 返回的是 xxx 标签对应的代码块，由于 forEach 后面的这个 Lambda 实际上被调用了多次，因此我们没有办法像 for 循环那样直接 break 实际上我们在 Kotlin 当中用到的 forEach、map、flatMap 等等这样的高阶函数调用，都是流式数据处理的典型例子，重新理一下需求，遇到某一个大于 3 的数，我们就终止遍历，这样的代码用流式 api 写出来应该是这样的： 123val list = listOf(1, 3, 5, 7, 9)list.takeWhile &#123; it &lt;= 3 &#125;.forEach(::println)println(&quot;Hello&quot;) 首先通过 takeWhile 来筛选出前面连续不大于 3 的元素，也就是说一旦遇到一个大于 3 的元素我们就丢弃从这个开始所有后面的元素；接着，我们把取到的这些不大于 3 的元素通过 forEach 打印出来，这样的话，程序的效果与最开头的 for 循环 break 的实现就完全一致了 但是在 filter 的时候就调用了一次完整的 for-loop，而后面的 forEach 同样再来一遍，也就是说用传统的 for-loop 一遍搞定的事，用流式 api 写了两遍，如果条件比较复杂，出现两遍三遍的情况也是比较正常的，这样就导致了流式 api 性能会比一般 loop 差 除了性能问题，这个实现其实还不是最终的通用的实现，这里只能针对这一个数组做到类似 break 的效果，试想一下，如果我这个数组是无序的，我需要输出数字 3 之前的所有数字，比如： 1val list = listOf(13, 2, 3, 7, 4) 那肯定不能用上面的写法了，下面这个应该才是最终的解决方案 或者简化为 可能语义不够清晰，一下子比较难看懂，所以也可以用 run 函数写，如下： Kotlin操作符(run、with、let、also、apply等)的差异上面提到了几个不同的操作符 run、apply、any、takeWhile，其中 any、takeWhile 是 Kotlin 的 _Collections 扩展中的，源码如下： 12345678910111213141516171819202122232425/** * Returns `true` if at least one element matches the given [predicate]. * * @sample samples.collections.Collections.Aggregates.anyWithPredicate */public inline fun &lt;T&gt; Iterable&lt;T&gt;.any(predicate: (T) -&gt; Boolean): Boolean &#123; if (this is Collection &amp;&amp; isEmpty()) return false for (element in this) if (predicate(element)) return true return false&#125;/** * Returns a list containing first elements satisfying the given [predicate]. * * @sample samples.collections.Collections.Transformations.take */public inline fun &lt;T&gt; Iterable&lt;T&gt;.takeWhile(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123; val list = ArrayList&lt;T&gt;() for (item in this) &#123; if (!predicate(item)) break list.add(item) &#125; return list&#125; 而 run、apply 等函数则位于 Kotlin 标准库 StandardKt.kt 中，源码位于 kotlin-stdlib-common&#x2F;kotlin 包下，基本都由内联函数 inline 修饰 run run 函数在标准库有两个，两个逻辑一样，但是第二个是 T 的扩展函数，入参是一个 block 函数，类型是一个 T 的扩展函数 T.()-&gt;R，无参，返回值是 R 类型 ，也可以传入 lambda 表达式 12345678910111213141516171819202122232425262728/** * Calls the specified function [block] and returns its result. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run). */@kotlin.internal.InlineOnlypublic inline fun &lt;R&gt; run(block: () -&gt; R): R &#123; // Kotlin 契约的写法，告诉编译器： // “这个函数会在此时此处调用‘block’，并且刚好只调用一次” // 这里不用管这一段，主要看 return 的部分 contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block()&#125;/** * Calls the specified function [block] with `this` value as its receiver and returns its result. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run). */@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block()&#125; let 仔细观察，let 函数和 run 函数的区别在于 T.let 入参传入的 block 函数，其参数是虽然是 T，返回值依旧是 R，block 在内部调用时传入 T.this，调用时用 it 调用 123456789101112/** * Calls the specified function [block] with `this` value as its argument and returns its result. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let). */@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block(this)&#125; with with 函数有两个入参 receiver:T，block 函数，关于 T 的扩展函数，返回 R，return receiver 运行 block 函数后的返回值 123456789101112/** * Calls the specified function [block] with the given [receiver] as its receiver and returns its result. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with). */@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123; contract &#123; allsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return receiver.block()&#125; also also 函数和 let 函数的区别在于，also 返回的是自身，且入参 block 函数无返回值，和 let 一样，block 在内部调用时传入 T.this，调用时用 it 调用 1234567891011121314/** * Calls the specified function [block] with `this` value as its argument and returns `this` value. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also). */@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block(this) return this&#125; apply apply 函数十分常用，它可以轻松实现 java 的链式调用，在一些比较简单的应用场景就不用很麻烦地写 build 模式了，apply 函数和 also 函数很相似，不同的是，对于 lambda 内部，apply 函数中直接持有 T 的引用，this 可以省略，所以可以直接调用关于 T 的所有 api，而 also 持有的是外部传入的 T 的引用，用 it 表示，所以需要用 it 来调用关于 T 的所有 api 12345678910111213/** * Calls the specified function [block] with `this` value as its receiver and returns `this` value. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply). */@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; takeIf、takeUnless takeIf 和 takeUnless 只是断言相反，takeIf 也是十分实用的标准函数，传入的 predicate 断言函数，返回值 Boolean，对于 takeIf 而言，符合条件则返回 T，否则返回 null 1234567891011121314151617181920212223/** * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn&#x27;t. */@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? &#123; contract &#123; callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) &#125; return if (predicate(this)) this else null&#125;/** * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does. */@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? &#123; contract &#123; callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) &#125; return if (!predicate(this)) this else null&#125; repeat repeat 标准函数可以轻松实现循环任务，time是循环的次数，action 函数指定具体循环的动作 123456789101112131415/** * Executes the given function [action] specified number of [times]. * * A zero-based index of current iteration is passed as a parameter to [action]. * * @sample samples.misc.ControlFlow.repeat */@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) &#123; contract &#123; callsInPlace(action) &#125; for (index in 0 until times) &#123; action(index) &#125;&#125; 用一张流传甚广的图来简单说明，就是如下这样： 参考文章 Kotlin StandardKt 标准库源码走一波 Kotlin 操作符：run、with、let、also、apply 的差异与选择 loops foreachindexed 在Kotlin的功能循环中,如何“中断”或“继续”?","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://enderhoshi.github.io/tags/Kotlin/"}]},{"title":"Android 版本适配","slug":"Android 版本适配","date":"2019-08-12T09:16:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2019/08/12/Android 版本适配/","link":"","permalink":"https://enderhoshi.github.io/2019/08/12/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/","excerpt":"","text":"前言前阵子适配 Android 9.0 时，遇到一些坑，感觉适配准备得不够充分就上线，会遇到非常多的问题，而现在再过几周，Android Q 正式版就要发布了，今天 Google 宣布发布最后一个 Beta 测试版 Android Q Beta 6 了，所以适配 Android Q 的工作也要尽早完成，Android Q Beta 6 发布文章 适配 Android 9.0 的坑 Android 9 功能和 API 适配 Android 10.0 应当注意的事项 Android Q 测试版 Android 10 功能和 API Android Q 适配指南 让你少走一堆弯路 实际操作总之，先搞到 Android Q 的手机或者模拟器先，可以查看获取 Android Q 测试版 成功打开 Android Q 版本的模拟器之后，先打开设置看一看，可以看到当前的系统版本号 支持与版本说明 代号、标记和细分版本号 关于代号官方文档 然后直接在 Android Q 上运行应用，查看应用的运行情况，是否存在打不开，卡顿，闪退等比较明显的现象 上面的操作没问题了，于是直接把 targetSdkVersion 改为 29 如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion 编译运行，发现出现了非常多的报错，都是类型错误，原本没有说明是可为空的对象，现在变成了可为空的，比如 Parcel 的 readString() 方法，Class 的 cast() 方法等 使用 Kotlin 开发 Android 应用 Parcel readString 可为空 所以要对这些可为空的对象进行处理，让代码可以正常编译运行，最后可以正常运行在 Android Q 的模拟器上 扫描非 SDK 接口所谓非 SDK 接口，在 iOS 开发中类似于“私有 API”，通俗的说，两者都是官方提供的接口，但前者明文包含在 SDK 中，允许开发者调用；后者出于各方面原因（比如还在测试中或是这个接口仅供系统内部调用），不鼓励甚至禁止开发者调用 当你调用了非 SDK 接口时，会有类似 Accessing hidden XXX 的日志，还指示了访问方式：直接，通过反射或通过 JNI 12Accessing hidden field Landroid/os/Message;-&gt;flags:I (light greylist, JNI)Accessing hidden method Landroid/app/ActivityThread;-&gt;currentActivityThread()Landroid/app/ActivityThread; (dark greylist, reflection) light greylisted ：包含方法和字段，它们继续在 Android P 预览版中运行，但 Google 无法保证在未来版本的平台上访问这些方法和字段 dark greylist：开发人员预览版本中无法访问的方法，这些日志消息可以使用 adb logcat 访问，并且会显示在正在运行的应用程序的 PID 下 但是一个大项目到底哪里使用了这些方法，靠自己 review 代码和看日志是不现实的，谷歌官方提供了官方检查器 veridex 来检测一个 apk 中哪里使用了非 SDK 接口，veridex下载 下载完毕后解压，解压后目录结构如下： 可以看到它里面包含了各名单的 txt 文件，其中 appcompat.sh 就是运行脚本 把需要扫描的 apk 放到同一目录下，使用终端 cd 到该目录，运行以下命令：(test.apk 为目标 apk，imprecise：不精确) 12345./appcompat.sh --dex-file=test.apk./appcompat.sh --dex-file=test.apk &gt;&gt; happy.txt./appcompat.sh --dex-file=test.apk --imprecise &gt;&gt; happy2.txt 对项目中的条目分类了一下，得到如下列表，观察详细内容，发现 veridex 把 Android 自己调用的也检测出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163Rxjava:#2: Linking greylist Lsun/misc/Unsafe;-&gt;arrayBaseOffset(Ljava/lang/Class;)I use(s): (io.reactivex:rxjava:1.2.1@jar) Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray;-&gt;&lt;clinit&gt;()V Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;&lt;clinit&gt;()V Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;&lt;clinit&gt;()V Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;&lt;clinit&gt;()V Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;&lt;clinit&gt;()V#3: Linking greylist Lsun/misc/Unsafe;-&gt;arrayIndexScale(Ljava/lang/Class;)I use(s): (io.reactivex:rxjava:1.2.1@jar) Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray;-&gt;&lt;clinit&gt;()V Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;&lt;clinit&gt;()V Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;&lt;clinit&gt;()V Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;&lt;clinit&gt;()V Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;&lt;clinit&gt;()V#5: Linking greylist Lsun/misc/Unsafe;-&gt;compareAndSwapLong(Ljava/lang/Object;JJJ)Z use(s): Lcom/google/common/cache/Striped64$Cell;-&gt;a(JJ)Z Lcom/google/common/cache/Striped64;-&gt;b(JJ)Z Lrx/internal/util/unsafe/MpmcArrayQueueConsumerField;-&gt;b(JJ)Z Lrx/internal/util/unsafe/MpmcArrayQueueProducerField;-&gt;c(JJ)Z Lrx/internal/util/unsafe/SpmcArrayQueueConsumerField;-&gt;b(JJ)Z#6: Linking greylist Lsun/misc/Unsafe;-&gt;compareAndSwapObject(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z use(s): Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture;Lcom/google/common/util/concurrent/AbstractFuture$Listener;Lcom/google/common/util/concurrent/AbstractFuture$Listener;)Z Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture;Lcom/google/common/util/concurrent/AbstractFuture$Waiter;Lcom/google/common/util/concurrent/AbstractFuture$Waiter;)Z Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture;Ljava/lang/Object;Ljava/lang/Object;)Z Lrx/internal/util/unsafe/MpscLinkedQueue;-&gt;c(Lrx/internal/util/atomic/LinkedQueueNode;)Lrx/internal/util/atomic/LinkedQueueNode;#8: Linking greylist Lsun/misc/Unsafe;-&gt;getLongVolatile(Ljava/lang/Object;J)J use(s): Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;a([JJ)J Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;a()J Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;b()J Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a()J Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;b()J#9: Linking greylist Lsun/misc/Unsafe;-&gt;getObject(Ljava/lang/Object;J)Ljava/lang/Object; use(s): Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;a([Ljava/lang/Object;J)Ljava/lang/Object;#10: Linking greylist Lsun/misc/Unsafe;-&gt;getObjectVolatile(Ljava/lang/Object;J)Ljava/lang/Object; use(s): Lrx/internal/util/unsafe/BaseLinkedQueueConsumerNodeRef;-&gt;a()Lrx/internal/util/atomic/LinkedQueueNode; Lrx/internal/util/unsafe/BaseLinkedQueueProducerNodeRef;-&gt;c()Lrx/internal/util/atomic/LinkedQueueNode; Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;b([Ljava/lang/Object;J)Ljava/lang/Object; Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a([Ljava/lang/Object;J)Ljava/lang/Object;#12: Linking greylist Lsun/misc/Unsafe;-&gt;objectFieldOffset(Ljava/lang/reflect/Field;)J use(s): Lcom/google/common/cache/Striped64$Cell;-&gt;&lt;clinit&gt;()V Lcom/google/common/cache/Striped64;-&gt;&lt;clinit&gt;()V (2 occurrences) Lcom/google/common/hash/Striped64$Cell;-&gt;&lt;clinit&gt;()V Lcom/google/common/hash/Striped64;-&gt;&lt;clinit&gt;()V (2 occurrences) Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;&lt;clinit&gt;()V (5 occurrences) Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;&lt;clinit&gt;()V (2 occurrences) Lrx/internal/util/unsafe/UnsafeAccess;-&gt;a(Ljava/lang/Class;Ljava/lang/String;)J#13: Linking greylist Lsun/misc/Unsafe;-&gt;putObject(Ljava/lang/Object;JLjava/lang/Object;)V use(s): Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture$Waiter;Lcom/google/common/util/concurrent/AbstractFuture$Waiter;)V Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture$Waiter;Ljava/lang/Thread;)V Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;a([Ljava/lang/Object;JLjava/lang/Object;)V#14: Linking greylist Lsun/misc/Unsafe;-&gt;putOrderedLong(Ljava/lang/Object;JJ)V use(s): Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;a([JJJ)V Lrx/internal/util/unsafe/SpmcArrayQueueProducerField;-&gt;d(J)V Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;d(J)V Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;e(J)V Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a(J)V Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;b(J)V#15: Linking greylist Lsun/misc/Unsafe;-&gt;putOrderedObject(Ljava/lang/Object;JLjava/lang/Object;)V use(s): Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;b([Ljava/lang/Object;JLjava/lang/Object;)V Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a([Ljava/lang/Object;JLjava/lang/Object;)VGoogle:#4: Linking greylist Lsun/misc/Unsafe;-&gt;compareAndSwapInt(Ljava/lang/Object;JII)Z use(s): Lcom/google/common/cache/Striped64;-&gt;c()Z#7: Linking greylist Lsun/misc/Unsafe;-&gt;getLong(Ljava/lang/Object;J)J use(s): Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray$1;-&gt;a([BI)J Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray$2;-&gt;a([BI)J Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;a([B[B)I (2 occurrences)#11: Linking greylist Lsun/misc/Unsafe;-&gt;getUnsafe()Lsun/misc/Unsafe; use(s): Lcom/google/common/cache/Striped64;-&gt;a()Lsun/misc/Unsafe; Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray;-&gt;c()Lsun/misc/Unsafe; Lcom/google/common/hash/Striped64;-&gt;a()Lsun/misc/Unsafe; Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;a()Lsun/misc/Unsafe; Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;&lt;clinit&gt;()VAndroidX#16: Reflection greylist-max-p Landroid/animation/LayoutTransition;-&gt;cancel use(s): Landroidx/transition/ViewGroupUtilsApi14;-&gt;a(Landroid/animation/LayoutTransition;)V#21: Reflection greylist Landroid/app/Dialog;-&gt;mOnKeyListener use(s): Landroidx/core/view/KeyEventDispatcher;-&gt;a(Landroid/app/Dialog;)Landroid/content/DialogInterface$OnKeyListener;#29: Reflection greylist Landroid/content/res/Resources;-&gt;mResourcesImpl use(s): Landroidx/appcompat/app/ResourcesFlusher;-&gt;d(Landroid/content/res/Resources;)V#30: Reflection greylist Landroid/graphics/Typeface;-&gt;createFromFamiliesWithDefault use(s): Landroidx/core/graphics/TypefaceCompatApi24Impl;-&gt;&lt;clinit&gt;()V Landroidx/core/graphics/TypefaceCompatApi26Impl;-&gt;f(Ljava/lang/Class;)Ljava/lang/reflect/Method; Landroidx/core/graphics/TypefaceCompatApi28Impl;-&gt;f(Ljava/lang/Class;)Ljava/lang/reflect/Method;#31: Reflection greylist Landroid/media/session/MediaSession;-&gt;getCallingPackage use(s): Landroid/support/v4/media/session/MediaSessionCompatApi24;-&gt;a(Ljava/lang/Object;)Ljava/lang/String;#33: Reflection greylist Landroid/os/Bundle;-&gt;getIBinder use(s): Landroidx/core/app/BundleCompat$BundleCompatBaseImpl;-&gt;a(Landroid/os/Bundle;Ljava/lang/String;)Landroid/os/IBinder;#34: Reflection greylist Landroid/os/Bundle;-&gt;putIBinder use(s): Landroidx/core/app/BundleCompat$BundleCompatBaseImpl;-&gt;a(Landroid/os/Bundle;Ljava/lang/String;Landroid/os/IBinder;)V#35: Reflection greylist Landroid/service/media/MediaBrowserService$Result;-&gt;mFlags use(s): Landroidx/media/MediaBrowserServiceCompatApi26;-&gt;&lt;clinit&gt;()V#45: Reflection greylist Landroid/view/LayoutInflater;-&gt;mFactory2 use(s): Landroidx/core/view/LayoutInflaterCompat;-&gt;b(Landroid/view/LayoutInflater;Landroid/view/LayoutInflater$Factory2;)V#46: Reflection greylist Landroid/view/View;-&gt;computeFitSystemWindows use(s): Landroidx/appcompat/widget/ViewUtils;-&gt;&lt;clinit&gt;()V#47: Reflection greylist Landroid/view/View;-&gt;mAccessibilityDelegate use(s): Landroidx/core/view/ViewCompat;-&gt;b(Landroid/view/View;)Z#49: Reflection greylist-max-p Landroid/view/View;-&gt;mViewFlags use(s): Landroidx/transition/ViewUtils;-&gt;a()V#50: Reflection greylist-max-p Landroid/view/animation/Animation;-&gt;mListener use(s): Landroidx/fragment/app/FragmentManagerImpl;-&gt;a(Landroid/view/animation/Animation;)Landroid/view/animation/Animation$AnimationListener;#51: Reflection greylist Landroid/widget/AbsListView;-&gt;mIsChildViewEnabled use(s): Landroidx/appcompat/widget/DropDownListView;-&gt;&lt;init&gt;(Landroid/content/Context;Z)V#52: Reflection greylist-max-p Landroid/widget/AutoCompleteTextView;-&gt;doAfterTextChanged use(s): Landroidx/appcompat/widget/SearchView$AutoCompleteTextViewReflector;-&gt;&lt;init&gt;()V#53: Reflection greylist-max-p Landroid/widget/AutoCompleteTextView;-&gt;doBeforeTextChanged use(s): Landroidx/appcompat/widget/SearchView$AutoCompleteTextViewReflector;-&gt;&lt;init&gt;()V#54: Reflection greylist-max-p Landroid/widget/AutoCompleteTextView;-&gt;ensureImeVisible use(s): Landroidx/appcompat/widget/SearchView$AutoCompleteTextViewReflector;-&gt;&lt;init&gt;()V#65: Reflection greylist Ljava/lang/Thread;-&gt;inheritableThreadLocals use(s): Lcom/google/common/base/internal/Finalizer;-&gt;b()Ljava/lang/reflect/Field;#66: Reflection greylist Llibcore/icu/ICU;-&gt;addLikelySubtags use(s): Landroidx/core/text/ICUCompat;-&gt;&lt;clinit&gt;()V#67: Reflection greylist Lsun/misc/Unsafe;-&gt;allocateInstance use(s): Lcom/google/gson/internal/UnsafeAllocator;-&gt;create()Lcom/google/gson/internal/UnsafeAllocator;#68: Reflection greylist Lsun/misc/Unsafe;-&gt;theUnsafe use(s): Lcom/google/gson/internal/UnsafeAllocator;-&gt;create()Lcom/google/gson/internal/UnsafeAllocator; Lrx/internal/util/unsafe/UnsafeAccess;-&gt;&lt;clinit&gt;()V68 hidden API(s) used: 15 linked against, 53 through reflection 60 in greylist 0 in blacklist 0 in greylist-max-o 8 in greylist-max-pTo run an analysis that can give more reflection accesses, but could include false positives, pass the --imprecise flag. greylist: 灰名单，即当前版本仍能使用的非 SDK 接口，但在下一版本中可能变成被限制的非 SDK 接口 blacklist：黑名单，使用了就会报错。也是我们项目中必须解决的非 SDK 接口 greylist-max-o： 在 targetSDK&lt;&#x3D;O 中能使用，但是在 targetSDK&gt;&#x3D;P 中被限制的非 SDK 接口 greylist-max-p： 在 targetSDK&lt;&#x3D;P 中能使用，但是在 targetSDK&gt;&#x3D;Q 中被限制的非 SDK 接口 使用非官方 API 的后果在 Developer Preview 的后续版本中，访问非 SDK 接口的各种方法都会产生错误或其他不良结果，下面列出了几种示例： Android Q 暗黑模式适配 1234567/** * 检查当前系统是否已开启暗黑模式 */fun getDarkModeStatus(context: Context): Boolean &#123; val mode = context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK return mode == Configuration.UI_MODE_NIGHT_YES&#125; 在需要跟随夜间模式的 Activity 中添加 android:configChanges=&quot;uiMode&quot; 选项，并重写 onConfigurationChanged() 方法 123456789101112131415&lt;activity android:name=&quot;.TestActivity&quot; android:configChanges=&quot;uiMode&quot; /&gt;override fun onConfigurationChanged(newConfig: Configuration) &#123; super.onConfigurationChanged(newConfig) when (newConfig.uiMode and Configuration.UI_MODE_NIGHT_MASK) &#123; Configuration.UI_MODE_NIGHT_YES -&gt; &#123; // 暗黑模式开启 &#125; Configuration.UI_MODE_NIGHT_NO -&gt; &#123; // 暗黑模已关闭 &#125; &#125;&#125; 关于 configChanges Android Q 全面屏及手势适配 左图 18.5:9 设备上最大纵横比设置为 16:9 的应用 右图 18.5:9 设备上最大纵横比设置为 18.5:9 的应用 1234&lt;!-- 适配全面屏 --&gt;&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.22&quot; /&gt; 建议将应用设计为支持 2.1 或更高的纵横比，如果未设置任何值，并且 android:resizeableActivity 不为 true，则最大纵横比默认为 1.86（大约相当于 16:9），应用将无法充分利用额外的屏幕空间 打开全面屏： 这张图片基本上指的是过去这么长时间，一般应用可以利用的在屏幕上的一个所谓的“安全范围”，在 Android Q 上，我们首先建议大家去考虑使用最下面的导航栏区域 在没有适配全面屏的应用中，会看到如下效果： 官方文档 手势操作再添新机制，Android Q Beta 5 更新详解 | 剧透 Android Q Labs | Android Q 手势导航","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"}]},{"title":"Kotlin REPL 使用","slug":"Kotlin REPL 使用","date":"2019-05-05T08:54:28.000Z","updated":"2025-07-09T09:33:16.188Z","comments":true,"path":"2019/05/05/Kotlin REPL 使用/","link":"","permalink":"https://enderhoshi.github.io/2019/05/05/Kotlin%20REPL%20%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言有时候我们在编程时，想要跑一小段代码验证计算结果，写单元测试比较麻烦，这个时候就希望可以在命令行中单独写一小段，跑出来看看结果，这其实就是 Kotlin 自带的交互式编程命令行，即 REPL（Read-Eval-Print Loop 的简写，直译为 “读取-求值-输出”循环），尤其适合快速实验一些东西，具体的实现步骤如下 IDE中使用首先我们需要一个已经装好 Kotlin 插件的 IDE ，无论是 Android Studio 还是 IntelliJ IDEA 都可以，点击 Tools 菜单，打开Kotlin-&gt;Kotlin REPL，即可在控制台书写代码运行 需要注意的是，Enter是换行，运行代码是 command + Enter 或者左边的运行键 命令行中使用如果我已经有一个已经装好 Kotlin 插件的 IDE ，但是我又不想打开 IDE 再运行 REPL ，那么就可以直接用命令行打开 Kotlin 的 REPL 去到 IDE 的 plugins 目录下，比如我是 Android Studio ，目录是 [用户目录]/[Android Studio 配置文件]/config/plugins/ ，找到 Kotlin/kotlinc ，把这个 kotlinc 目录完整拷贝到一个你想要放的地方 这个 kotlinc 目录下大概有这些东西 kotlinc: bin: kotlin.bat kotlin kotlinc.bat kotlinc kotlinc-js.bat kotlinc-js kotlinc-jvm.bat kotlinc-jvm lib: 一堆 jar license: 一堆 txt build.txt 然后就去配环境变量，打开终端，输入 1nano ~/.bash_profile // 使用 nano 命令打开 .bash_profile 修改环境变量 添加如下两行代码 12export KOTLIN_HOME=/Users/lvqx/Desktop/kotlincexport PATH=$PATH:$KOTLIN_HOME/bin 其中的 lvqx/Desktop 可以替换为你想要的位置，我这里直接放在桌面了 之后 control + O 保存 或者 control + X 退出并保存，再在终端输入以下命令使配置生效 1source ~/.bash_profile 然后就可以在命令行输入 kotlinc 打开 REPL 编写一小段程序跑起来了 不过我这里会出现如下提示 1-bash: /Users/lvqx/Desktop/kotlinc/bin/kotlin: Permission denied 所以需要去到目录下给相应的文件相应的权限，如下所示： 1chmod a+x [文件名或者通配符] 之后就可以在命令行输入 kotlinc 打开 REPL 了，如下所示： 123456789101112lvqx-Mac-work:bin lvqx$ kotlincWelcome to Kotlin version 1.3.20 (JRE 1.8.0_192-b12)Type :help for help, :quit for quit&gt;&gt;&gt; val kotlin = &quot;Kotlin is awesome!&quot;&gt;&gt;&gt; println(&quot;Hey boy, $kotlin&quot;)Hey boy, Kotlin is awesome!&gt;&gt;&gt; val a = 1&gt;&gt;&gt; val b = 232&gt;&gt;&gt; val c = 123&gt;&gt;&gt; println(a + b + c)356&gt;&gt;&gt; :quit 需要注意的是，输入 print 相关语法时，会自动运行代码并输出 总结在 IDE 中使用 REPL 可以使用 IDE 的语法高亮和补全功能，更方便地指定运行时机也可以更方便地查看结果，但是需要打开 IDE 再进行操作 而使用命令行打开，简单快捷，但是不及IDE简洁优雅，查看结果有一点点麻烦和不可控","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://enderhoshi.github.io/tags/Kotlin/"}]},{"title":"Java Calendar 类解析","slug":"Java Calendar 类解析","date":"2019-04-04T13:16:28.000Z","updated":"2025-07-09T09:33:16.188Z","comments":true,"path":"2019/04/04/Java Calendar 类解析/","link":"","permalink":"https://enderhoshi.github.io/2019/04/04/Java%20Calendar%20%E7%B1%BB%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言最近在处理关于时间格式化的问题时，用到了 Calendar 类，踩了一些比较低级的坑，感慨虽然是一个 Calendar 类，也有很多要留意的地方，而以前一直没有比较规范的了解过这个类，这次刚好对它深入了解一番 概念 是一个抽象类，可以派生出各种日历，除了使用默认的 GregorianCalendar（格里高利历），还可以自己实现各种其他历法 123Calendar iso8601 = new Calendar.Builder().setCalendarType(&quot;iso8601&quot;).build();Calendar.getAvailableCalendarTypes()// return [gregory] gregory 和 iso8601: 1234567891011121314151617/** *设置GregorianCalendar更改日期。 这是从朱利安日期到格里高利日期的转换发生的时刻。 默认值是1582年10月15日（格里高利）。在此之前，日期将在儒略历中。 *要获取纯Julian日历，请将更改日期设置为Date（Long.MAX_VALUE）。 要获得纯公历，请将更改日期设置为日期（Long.MIN_VALUE）。 */public void setGregorianChange(Date date) &#123; long cutoverTime = date.getTime(); if (cutoverTime == gregorianCutover) &#123; return; &#125;// Before changing the cutover date, make sure to have the// time of this calendar. complete(); setGregorianChange(cutoverTime);&#125;// 设定一年中第一周所需的最小天数; 例如，如果第一周定义为包含一年中第一个月的第一天的那一周，则使用值1调用此方法。如果它必须是整周，则使用值7。calendar.setMinimalDaysInFirstWeek(1); ISO 8601 基本用法1234567891011121314151617181920212223242526272829303132333435363738// 通过getInstance()获取实例，并不是单例，而是每次都new一个新的GregorianCalendar对象，可以把这个对象存起来，避免每次都新建private val calendar = Calendar.getInstance() // 获得默认的时区和语言地区，即从系统中取private val calendar = Calendar.getInstance(TimeZone zone, Locale aLocale)/** * Gets a calendar with the specified time zone and locale. * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time * in the given time zone with the given locale. * * @param zone the time zone to use * @param aLocale the locale for the week data * @return a Calendar. */ public static Calendar getInstance(TimeZone zone, Locale aLocale) &#123; return createCalendar(zone, aLocale); &#125; private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; // BEGIN Android-changed: only support GregorianCalendar here return new GregorianCalendar(zone, aLocale); // END Android-changed: only support GregorianCalendar here &#125; /** * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time * in the given time zone with the given locale. * * @param zone the given time zone. * @param aLocale the given locale. */ public GregorianCalendar(TimeZone zone, Locale aLocale) &#123; super(zone, aLocale); gdate = (BaseCalendar.Date) gcal.newCalendarDate(zone); setTimeInMillis(System.currentTimeMillis()); &#125;// 创建一个 Dateval date = Date(1554362004L) 这里的 Date 类还有其他构造方法，不过已经被弃用了，现在通常都是用 Date(long: Long) 这个构造方法，直接传入时间戳，方便相互转化 12345678910111213141516171819202122232425262728293031// 传入一个Date类型calendar.time = date/** * Sets the values for the fields &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;, * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR_OF_DAY&lt;/code&gt;, &lt;code&gt;MINUTE&lt;/code&gt;, and * &lt;code&gt;SECOND&lt;/code&gt;. * Previous values of other fields are retained. If this is not desired, * call &#123;@link #clear()&#125; first. * * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field. * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field. * Month value is 0-based. e.g., 0 for January. * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field. * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field. * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field. * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field. * @see #set(int,int) * @see #set(int,int,int) * @see #set(int,int,int,int,int) */ public final void set(int year, int month, int date, int hourOfDay, int minute, int second) &#123; set(YEAR, year); set(MONTH, month); set(DATE, date); set(HOUR_OF_DAY, hourOfDay); set(MINUTE, minute); set(SECOND, second); &#125;calendar.set(2019,4,8); set(f, value) 方法日历的某个字段修改为 value 值，此外它还设置了一个内部成员变量，以指示日历字段 f 已经被更改。尽管日历字段 f 是立即更改的，但该 Calendar 所代表的时间却不会立即修改，直到下次调用 get()、getTime()、getTimeInMillis()、add() 或 roll() 时才会重新计算日历的时间。这被称为 set() 方法的延迟修改，采用延迟修改的优势是多次调用 set() 不会触发多次不必要的运算 123456789101112131415161718192021222324252627282930313233public void set(int field, int value) &#123; // If the fields are partially normalized, calculate all the // fields before changing any fields. if (areFieldsSet &amp;&amp; !areAllFieldsSet) &#123; computeFields(); &#125; internalSet(field, value); isTimeSet = false; areFieisSet[field] = true; ldsSet = false; stamp[field] = nextStamp++; if (nextStamp == Integer.MAX_VALUE) &#123; adjustStamp(); &#125;&#125;SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd:hh:mm:ss&quot;);Calendar calendar2 = Calendar.getInstance();calendar2.set(2003, 7, 31);Log.d(&quot;textqqq&quot;, simpleDateFormat.format(calendar2.getTime()));calendar2.set(Calendar.MONTH, 8);//Log.d(&quot;textqqq&quot;, simpleDateFormat.format(calendar2.getTime()));calendar2.set(Calendar.DATE, 5);Log.d(&quot;textqqq&quot;, simpleDateFormat.format(calendar2.getTime()));// 注释掉的 Log 是// 2019-04-08 15:39:16.484 24647-24647/com.example.calendartest D/textqqq: 2003-08-31:03:39:16// 2019-04-08 15:39:16.485 24647-24647/com.example.calendartest D/textqqq: 2003-09-05:03:39:16// 去掉注释后的 Log 是// 2019-04-08 15:46:03.286 25362-25362/com.example.calendartest D/textqqq: 2003-08-31:03:46:03// 2019-04-08 15:46:03.287 25362-25362/com.example.calendartest D/textqqq: 2003-10-01:03:46:03// 2019-04-08 15:46:03.287 25362-25362/com.example.calendartest D/textqqq: 2003-10-05:03:46:03 获取不同的日期值12// 取得不同字段对应的的值val month = calendar.get(Calendar.MONTH) 常用字段值 Field name Minimum Greatest Minimum Least Maximum Maximum ERA 0 0 1 1 YEAR 1 1 292269054 292278994 MONTH 0 0 11 11 WEEK_OF_YEAR 1 1 52* 53 WEEK_OF_MONTH 0 0 4* 6 DAY_OF_MONTH 1 1 28* 31 DAY_OF_YEAR 1 1 365* 366 DAY_OF_WEEK 1 1 7 7 DAY_OF_WEEK_IN_MONTH -1 -1 4* 6 AM_PM 0 0 1 1 HOUR 0 0 11 11 HOUR_OF_DAY 0 0 23 23 MINUTE 0 0 59 59 SECOND 0 0 59 59 MILLISECOND 0 0 999 999 ZONE_OFFSET -13:00 -13:00 14:00 14:00 DST_OFFSET 0:00 0:00 0:20 2:00 * 根据格里高利历而变化 比较特殊的字段值12345678910111213public final static int ERA = 0; // 时代public final static int AD = 1; // 公元public final static int BC = 0; // 公元前public final static int AM_PM = 9;public final static int AM = 0;public final static int PM = 1;public final static int DAY_OF_MONTH = 5; // 这两个是一样的public final static int DATE = 5;public final static int WEEK_OF_MONTH = 4; // 这周在当月里是第几周，以星期为标准public final static int DAY_OF_WEEK_IN_MONTH = 8; // 这周在当月里是第几周，以日期为标准 DAY_OF_WEEK_IN_MONTH: 指示当前月中的第几个星期。与 DAY_OF_WEEK 字段一起使用时，就可以唯一地指定某月中的某一天。与 WEEK_OF_MONTH 和 WEEK_OF_YEAR 不同，该字段的值并不取决于 getFirstDayOfWeek() 或 getMinimalDaysInFirstWeek()。 DAY_OF_MONTH 1 到 7 总是对应于 DAY_OF_WEEK_IN_MONTH 1； 8 到 14 总是对应于 DAY_OF_WEEK_IN_MONTH 2，依此类推。 DAY_OF_WEEK_IN_MONTH 0 表示 DAY_OF_WEEK_IN_MONTH 1 之前的那个星期。负值是从一个月的末尾开始逆向计数，因此，一个月的最后一个星期天被指定为 DAY_OF_WEEK &#x3D; SUNDAY, DAY_OF_WEEK_IN_MONTH &#x3D; -1。因为负值是逆向计数的，所以它们在月份中的对齐方式通常与正值的不同。例如，如果一个月有 31 天，那么 DAY_OF_WEEK_IN_MONTH -1 将与 DAY_OF_WEEK_IN_MONTH 5 和 DAY_OF_WEEK_IN_MONTH 4 的末尾相重叠。 拿 2019 年一月来测试一下 1234567891011121314public final static int ZONE_OFFSET = 15; //获取时区，正为东，负为西calendar.get(Calendar.ZONE_OFFSET) = 28800000 // 比世界协调时间（UTC）/格林尼治时间（GMT）快8小时的时区public final static int DST_OFFSET = 16; //以毫秒为单位指示夏令时的偏移量，地区相关Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;),Locale.US);Date newYears = new Date(1546272000000L);calendar.setTime(newYears);for (;;calendar.add(Calendar.DATE, 1)) &#123; if (calendar.get(Calendar.DST_OFFSET) &gt; 0) &#123; tvContent4.setText(&quot;&quot; + FULL_FORMAT.format(calendar.getTime())); break; &#125;&#125;calendar.get(Calendar.DST_OFFSET) = 3600000 美国夏时制 香港夏时制 夏时制 中国也曾在1986-1991年间实行夏令时，后废除 一些细微的不同可以留意到，一些字段取得的值是 0 开始的，比如 12345678910111213141516public final static int WEEK_OF_MONTH = 4;public final static int MONTH = 2;// JANUARY 0// FEBRUARY// MARCH// APRIL// MAY// JUNE// JULY// AUGUST// SEPTEMBER// OCTOBER// NOVEMBER// DECEMBER 11// UNDECIMBER 12 第十三个月 第十三个月 但是有些却是以 1 开始的，比如以下这些，使用时要加以区分 12345678910111213141516public final static int YEAR = 1;public final static int WEEK_OF_YEAR = 3;public final static int DAY_OF_MONTH = 5;public final static int DAY_OF_YEAR = 6;public final static int DAY_OF_WEEK = 7;// SUNDAY 1// MONDAY// TUESDAY// WEDNESDAY// THURSDAY// FRIDAY// SATURDAY 7// SUNDAY in the U.S, MONDAY in France.calendar.setFirstDayOfWeek(Calendar.MONDAY); add 和 roll 的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Adds or subtracts the specified amount of time to the given calendar field, * based on the calendar&#x27;s rules. For example, to subtract 5 days from * the current time of the calendar, you can achieve it by calling: * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;. * * @param field the calendar field. * @param amount the amount of date or time to be added to the field. * @see #roll(int,int) * @see #set(int,int) */abstract public void add(int field, int amount);/** * Adds or subtracts (up/down) a single unit of time on the given time * field without changing larger fields. For example, to roll the current * date up by one day, you can achieve it by calling: * &lt;p&gt;roll(Calendar.DATE, true). * When rolling on the year or Calendar.YEAR field, it will roll the year * value in the range between 1 and the value returned by calling * &lt;code&gt;getMaximum(Calendar.YEAR)&lt;/code&gt;. * When rolling on the month or Calendar.MONTH field, other fields like * date might conflict and, need to be changed. For instance, * rolling the month on the date 01/31/96 will result in 02/29/96. * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will * roll the hour value in the range between 0 and 23, which is zero-based. * * @param field the time field. * @param up indicates if the value of the specified time field is to be * rolled up or rolled down. Use true if rolling up, false otherwise. * @see Calendar#add(int,int) * @see Calendar#set(int,int) */abstract public void roll(int field, boolean up);Date newYears = new Date(1545408000000L);calendar.setTime(newYears);calendar.roll(Calendar.MONTH,1);calendar.setTime(newYears);calendar.add(Calendar.MONTH,1);2019-04-08 16:13:03.103 31697-31697/com.example.calendartest D/textqqq: 2018-12-22:12:00:002019-04-08 16:13:03.103 31697-31697/com.example.calendartest D/textqqq: 2018-01-22:12:00:002019-04-08 16:13:03.104 31697-31697/com.example.calendartest D/textqqq: 2018-12-22:12:00:002019-04-08 16:13:03.104 31697-31697/com.example.calendartest D/textqqq: 2019-01-22:12:00:00 calendar.setLenient 容错性1234567calendar.set(Calendar.MONTH, 13);System.out.println(simpleDateFormat.format(calendar.getTime()));// 关闭容错性// calendar.setLenient(false);calendar.set(Calendar.MONTH, 13);System.out.println(simpleDateFormat.format(calendar.getTime())); 当打开 calendar.setLenient(false) 时，① 处代码可以正常运行，因为将 MONTH 字段设置为 13，将会导致 YEAR 字段加 1；② 处将会导致运行异常，因为设置的 MONTH 字段超出了所允许的范围。关键在于程序中粗体字代码行， Calendar 提供一个 setLenient 用于设置它的容错性，Calendar 默认支持比较好的容错性，通过 setLenient(false) 了一关闭 Calendar 的容错性，让它进行严格的参数检查。Calendar 有两种解释日历字段的模式：lenient 模式和 non-lenient 模式。当处于 lenient 模式时，每个字段都可接受超出范围的值。当处于 non-lenient 模式时，每个字段都进行严格的参数检查，不接收超出字段的值。 1234567891011121314151617181920212223242526Calendar calendar2 = Calendar.getInstance();calendar2.setLenient(false);calendar2.set(2003, 7, 31);calendar2.set(Calendar.MONTH, 8);calendar2.set(Calendar.DATE, 5);java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.example.calendartest/com.example.calendartest.MainActivity&#125;java.lang.IllegalArgumentException: MONTH: 8 -&gt; 9 at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2778) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856) at android.app.ActivityThread.-wrap11(Unknown Source:0) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6494) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)Caused by: java.lang.IllegalArgumentException: MONTH: 8 -&gt; 9 at java.util.GregorianCalendar.computeTime(GregorianCalendar.java:2824) at java.util.Calendar.updateTime(Calendar.java:3397) at java.util.Calendar.getTimeInMillis(Calendar.java:1761) at java.util.Calendar.getTime(Calendar.java:1734) at com.example.calendartest.MainActivity.onCreate(MainActivity.java:67) at android.app.Activity.performCreate(Activity.java:7009) at android.app.Activity.performCreate(Activity.java:7000) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1214)","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://enderhoshi.github.io/tags/Java/"}]},{"title":"Android 状态栏与主题探究","slug":"Android 状态栏与主题探究","date":"2019-02-13T13:16:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2019/02/13/Android 状态栏与主题探究/","link":"","permalink":"https://enderhoshi.github.io/2019/02/13/Android%20%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8E%E4%B8%BB%E9%A2%98%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"前不久在写一个功能的时候，遇到一个添加引导页的需求，直接照搬了之前的引导页的实现方式，使用了 NewbieGuide 来实现，发现在 Activity 中引导页弹出时无法遮盖状态栏，除了状态栏外的部分才能正常被遮盖，所以探究下这个是什么原因导致的 项目中其他地方的遮罩可以完整的盖住整个手机屏幕，连同状态栏一起，所以先去看看这些地方是如何实现的，一共有两种： 布局中设置 android:fitsSystemWindows&#x3D;”true” 的同时，使用了自定义的 TransLinearLayout 这个 TranslinearLayout 中的 onMeasure 方法中，加上了 WindowInsets 的 getSystemWindowInsetTop 取得的高度而 WindowInsets 这里的 inset 的直译是插入物，可以理解为特定屏幕区域，WindowInsets 的三个成员变量 mSystemWindowInsets，mWindowDecorInsets，mStableInsets 表示了三种屏幕区域，而 SystemWindowInsets 系统窗口区域代表着整个屏幕窗口上，状态栏，导航栏，输入法等系统窗口占用的区域这里的top表示的是顶部占位区域的宽度，即状态栏的宽度，长度默认是屏宽 某些 Activity 的 Theme 中加上 windowTranslucentStatus&#x3D;true 属性，或者在活动的 onCreate 代码中设置 1&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 1234567891011121314151617181920if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)&#125;setContentView(R.layout.ai_kline_act_kline_master)if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; val titleBar = findViewById&lt;ConstraintLayout&gt;(R.id.ai_kline_master_title_bar) var statusBarHeight = 60 if (ScreenUtil.getStatusBarHeight(this) != 0) &#123; statusBarHeight = ScreenUtil.getStatusBarHeight(this) &#125; titleBar.setPadding(titleBar.paddingLeft, titleBar.paddingTop + statusBarHeight, titleBar.paddingRight, titleBar.paddingBottom) val titleBarLayoutParams = titleBar.layoutParams titleBarLayoutParams.height = titleBarLayoutParams.height + statusBarHeight titleBar.layoutParams = titleBarLayoutParams&#125; 至此明白了需要怎样去实现，解决了问题，但是从这里可以看出我对主题，状态栏相关的知识不够扎实，故对相关内容重新整理归纳一下 首先是主题相关的内容，Android 5.0 发布后，support-v7-appcompat 也更新到V21，增加了 ToolBar、recyclerview、cardview 等控件。Android 从 5.0 开始支持 Material Design 应用，可以通过修改各项参数来达到不同的主题效果，以下是各项参数的作用 textColorPrimary 应用的主要文字颜色，ActionBar 的标题文字默认使用该颜色 colorPrimary 应用的主要色调，actionBar 默认使用该颜色，Toolbar 导航栏的底色 statusBarColor 状态栏颜色，默认使用 colorPrimaryDark colorPrimaryDark 应用的主要暗色调，statusBarColor 默认使用该颜色 windowBackground 窗口背景颜色 navigationBarColor 底部栏颜色 colorAccent CheckBox，RadioButton，SwitchCompat 等一般控件的选中效果默认采用该颜色 colorForeground 应用的前景色，ListView的分割线，switch 滑动区默认使用该颜色 colorBackground 应用的背景色，popMenu 的背景默认使用该颜色 colorControlNormal CheckBox，RadioButton，SwitchCompat 等默认状态的颜色。 colorControlHighlight 控件按压时的色调 colorControlActivated 控件选中时的颜色，默认使用 colorAccent colorButtonNormal 默认按钮的背景颜色 editTextColor ：默认 EditView 输入框字体的颜色。 textColor Button，textView 的文字颜色 textColorPrimaryDisableOnly RadioButton checkbox 等控件的文字 colorSwitchThumbNormal switch thumbs 默认状态的颜色. (switch off) 1234&lt;item name=&quot;windowNoTitle&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;android:windowNoTitle&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;android:windowActionBar&quot;&gt;false&lt;/item&gt; 又发现到 AppCompatActivity 中出现了 windowNoTitle 属性，前边不需要加 “android:”，那这两个有什么区别吗？ 其实带 android 的是系统的，不带 android 是兼容样式的，就是 Theme.AppCompat 样式的，因为是 support 包里重新定义了这个属性，即 windowNoTitle 是 appcompat-v7 中的属性，在 appcompat-v7\\res\\values\\values.xml 中定义了，可以打开 appcompat-v7\\res\\values\\values.xml 搜索 AppCompatTheme，可以找到定义的 “windowNoTitle”、”windowActionBar” 等属性。 “windowNoTitle” 属性在代码中可以使用 R.attr.windowNoTitle 访问，“android:windowNoTitle” 则需要使用 android.R.attr.windowNoTitle 访问。 使用 AppCompatActivity 时（Activity 必须使用 Theme.AppCompat 主题及其子主题），测试发现： “android:windowActionBar” 属性在 AppCompatActivity 中不起作用 windowNoTitle &#x3D; false 并且 android:windowNoTitle &#x3D; false 时，会出现两个标题，位于下方的是 AppCompatActivity的标题栏 当windowNoTitle &#x3D; false，windowActionBar &#x3D; false 时，会报错: AppCompat does not support the current theme features windowNoTitle &#x3D; true 并且 android:windowNoTitle &#x3D; true时 ,无标题 然后是状态栏的沉浸式实现的转变： Android4.4（API 19）- Android 5.0（API 21）： 这个阶段可以实现沉浸式，但是表现得还不是很好，实现方式为: 通过 FLAG_TRANSLUCENT_STATUS 设置状态栏为透明并且为全屏模式，然后通过添加一个与 StatusBar 一样大小的 View，将 View 的 background 设置为我们想要的颜色，或者是像上文那样动态设置一个 padding，从而来实现沉浸式 这里的 FLAG_TRANSLUCENT_STATUS 的含义是：设置状态栏透明，并且变为全屏模式，从注释中看到，当 window 的这个属性有效的时候，会自动设置 system ui visibility 的标志 SYSTEM_UI_FLAG_LAYOUT_STABLE 和 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN Android 5.0（API 21）以上版本： 在Android 5.0 的时候，加入了一个重要的属性和方法 android:statusBarColor（对应方法为 setStatusBarColor），通过这个方法我们就可以轻松实现沉浸式 Android 6.0（API 23）以上版本：Android 6.0 以上的实现方式和 Android 5.0 +是一样，但是从 Android 6.0（API 23）开始，我们可以改状态栏的绘制模式，可以显示白色或浅黑色的内容和图标（除了魅族手机，魅族自家有做源码更改，6.0 以下就能实现）示例 12//6.0 以上可以设置状态栏的字体为黑色，使用下面代码可以打开亮色状态栏模式，实现黑色字体，白底的需求用这句 setStatusBarColor(Color.WHITE)window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR 更新同样的操作，在 Android 8.0 以上似乎并不能很好地实现，而是更符合 flag 原本的定义，FLAG_TRANSLUCENT_STATUS 其中的 TRANSLUCENT 的意思是半透明的意思，所以在 8.0 以上的时候，设置这个 FLAG 会让状态栏半透明，同时 SYSTEM_UI_FLAG_LAYOUT_STABLE（让应用的主体内容占用系统状态栏的空间）和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN（全屏）也会生效，造成顶部和状态栏重叠的情况，同时有一条半透明的状态栏在上面，这样子的话，在 Android7.0 中可以完美实现的沉浸式，在 8.0 的时候还是会显示一条半透明状态栏，所以如果要实现沉浸式，设置 FLAG_TRANSLUCENT_STATUS 和 android:windowTranslucentStatus &#x3D; true 其实并不是太可取，应该要动态改变状态栏的颜色来实现真正的沉浸式，可以设置状态栏颜色与下方控件颜色一致，或者在没有设置 FLAG_TRANSLUCENT_STATUS 而设置了 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 的同时，设置状态栏颜色为透明，因为设置 FLAG_TRANSLUCENT_STATUS 会使得状态栏默认为半透明颜色","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"}]},{"title":"WebView 加载链接跳转快应用问题","slug":"WebView 加载链接跳转快应用问题","date":"2018-12-12T09:16:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2018/12/12/WebView 加载链接跳转快应用问题/","link":"","permalink":"https://enderhoshi.github.io/2018/12/12/WebView%20%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC%E5%BF%AB%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言最近在项目中遇到一个关于快应用的问题，就是在应用内某个页面使用 WebView 查看微博时，会发生一次跳转到快应用的行为，在一些机型（目前发现华为的一些机型）上会因为 scheme 协议的问题而无法正确跳转，加载不了页面，而在另一个类似的页面打开，又没有发生跳转，只在应用内打开了微博页面，后来通过排查，用不是太妥善的方法解决了问题，先做下记录，以后再完善 分析过程在使用以下机型的时候会出现下面图中的问题，而华为荣耀8青春版却又没有这个问题 华为畅享 6 EMUI 4.7 Android 6.0 华为 p9 EMUI 8.0 Android 8.0 华为畅享 7 图中的报错信息显示是加载到了一个未知的 scheme，导致无法加载页面，我 load 的明明就是一个 http 链接，怎么会变成 scheme 呢，从报错中的 hwfastapp 就可以看出端倪，fastapp 不就是之前发布的快应用吗？先去了解下什么是快应用 从官网中可以看到，这是努比亚、联想、一加、小米、vivo、华为、OPPO、金立、魅族、中兴这十家厂商联合起来的快应用联盟所推出的一种应用形态，旨在打造一种无需安装，即点即用的新的应用体验，我感觉其实类似之前的 Progressive Web App(PWA)，看了下手头上的手机，就只有小米和华为，先拿这两家来测试下： 先是华为，可以在 WebView 的 setWebViewClient 中通过重写 shouldOverrideUrlLoading() 方法来看到 webView.loadUrl(url) 都干了什么，关于 shouldOverrideUrlLoading() 方法： 1234567891011121314151617181920/** * Give the host application a chance to take over the control when a new * url is about to be loaded in the current WebView. If WebViewClient is not * provided, by default WebView will ask Activity Manager to choose the * proper handler for the url. If WebViewClient is provided, return true * means the host application handles the url, while return false means the * current WebView handles the url. * This method is not called for requests using the POST &quot;method&quot;. * * @param view The WebView that is initiating the callback. * @param url The url to be loaded. * @return True if the host application wants to leave the current WebView * and handle the url itself, otherwise return false. * @deprecated Use &#123;@link #shouldOverrideUrlLoading(WebView, WebResourceRequest) * shouldOverrideUrlLoading(WebView, WebResourceRequest)&#125; instead. */@Deprecatedpublic boolean shouldOverrideUrlLoading(WebView view, String url) &#123; return false;&#125; 大致的意思是 若没有设置 WebViewClient 则由系统（Activity Manager）处理该 url，通常是使用浏览器打开或弹出浏览器选择对话框。 若设置 WebViewClient 且该方法返回 true ，则说明由应用的代码处理该 url，WebView 不处理，也就是程序员自己做处理。 若设置 WebViewClient 且该方法返回 false，则说明由 WebView 处理该 url，即用 WebView 加载该 url 而 WebView 的前进、后退、刷新、以及 post 请求都不会调用 shouldOverrideUrlLoading 方法，除去以上行为，还得满足(!isLoadUrl || isRedirect） 即 （不是通过 webView.loadUrl 来加载的 或者 是重定向的）这个条件，才会调用 shouldOverrideUrlLoading 方法 所以通过重写 WebView的shouldOverrideUrlLoading() 方法，可以捕获到重定向的链接经历了几次变化 123456789https://api.weibo.com/开头 ⬇️http://weibo.com/ ⬇️http://m.weibo.cn/XXXXXX/XXXXXXX?&amp;jumpfrom=weibocom ⬇️https://m.weibo.cn/status/XXXXXXXXX?jumpfrom=weibocom ⬇️hwfastapp://xxxxxx 然后 WebView 在加载这条 scheme 的时候，无法识别，所以报错了，那么好办，直接过滤掉这个开头的，或者干脆不单只华为，连其他厂商的也不加载了，就是只加载 http 或者 https 开头的链接，那就不用报错了吧，试了一下 123456789101112webSiteNavigation.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if (url.startsWith(&quot;http:&quot;) || url.startsWith(&quot;https:&quot;)) &#123; view.loadUrl(url); return false; &#125; else &#123; //不做任何事直接返回true return true; &#125; &#125;&#125; 果然可行，在页面内加载出了微博的页面，并没有跳转快应用 那再试试小米系统，同样的方法，却发现小米仍然可以跳转到快应用，但是 shouldOverrideUrlLoading() 捕获不到关于快应用的链接，都是正常的 http 或者 https 头的，那是不是还有其他方式跳转快应用，而没有华为那么明显呢，重写一下 shouldInterceptRequest() 方法，看看发生了什么，从返回中可以看到，都是一些 js、css 页面或者是 log 和页面内的图片资源 jpg、svg 图 123456789101112131415161718192021222324252627I/lvqx-test: https://api.weibo.com/2/statuses/go?uid=6360369679&amp;id=4316516449593454I/lvqx-test: http://weibo.com/6360369679/H6VFqEfH8I/lvqx-test: https://weibo.com/6360369679/H6VFqEfH8I/lvqx-test: http://m.weibo.cn/6360369679/H6VFqEfH8?&amp;jumpfrom=weibocomI/lvqx-test: https://m.weibo.cn/6360369679/H6VFqEfH8?&amp;jumpfrom=weibocomI/lvqx-test: https://m.weibo.cn/status/H6VFqEfH8?jumpfrom=weibocomI/lvqx-test: https://h5.sinaimg.cn/m/weibo-lite/js/vendor.9e10b5e9.jsI/lvqx-test: https://h5.sinaimg.cn/m/weibo-lite/js/app.81d27428.jsI/lvqx-test: https://h5.sinaimg.cn/m/weibo-lite/css/app.c20922eb.cssI/lvqx-test: https://h5.sinaimg.cn/m/weibo-lite/js/manifest.65eb9185.jsI/lvqx-test: https://h5.sinaimg.cn/marvel/v1.4.0/css/lib/base.cssI/lvqx-test: https://h5.sinaimg.cn/marvel/v1.4.0/css/card/cards.cssI/lvqx-test: https://m.weibo.cn/static/pwa/sw-registration.jsI/lvqx-test: https://h5.sinaimg.cn/upload/1005/16/2017/11/30/wbp.jsI/lvqx-test: https://h5.sinaimg.cn/marvel/v1.4.0/img/sprite.svgI/lvqx-test: https://h5.sinaimg.cn/m/weibo-lite/js/statusLite.034a91ca.jsI/lvqx-test: http://thefatherofsalmon.com/?i=com.sina.weibo.quickapp&amp;p=WBDetail&amp;a=blog_id%3DH6VFqEfH8%26luicode%3D10000835%26lfid%3D_detailI/lvqx-test: https://m.weibo.cn/api/configI/lvqx-test: https://m.weibo.cn/statuses/show?id=H6VFqEfH8I/lvqx-test: https://h5.sinaimg.cn/m/weibo-lite/fonts/iconfont.25fdf7a.ttfI/lvqx-test: https://tvax3.sinaimg.cn/crop.0.0.512.512.180/006WrsHJly8fruc0frworj30e80e8dg6.jpgI/lvqx-test: http://n.sinaimg.cn/photo/5213b46e/20180926/timeline_card_small_super_default.pngI/lvqx-test: https://h5.sinaimg.cn/upload/2015/09/25/3/timeline_card_small_web_default.pngI/lvqx-test: https://r.sinaimg.cn/large/tc/mmbiz_qpic_cn/8c0ce7e3eaa0ba15ce3fe495847538f3.jpgI/lvqx-test: https://m.weibo.cn/comments/hotflow?id=4316516449593454&amp;mid=4316516449593454&amp;max_id_type=0I/lvqx-test: https://h5.sinaimg.cn/upload/2015/05/15/28/WeiboLogoCh.svg 打开这些页面，搜索一下相关的关键字，发现在一个js页面内，有如下代码 12345678default.toappRouter(&quot;com.sina.weibo.quickapp&quot;, &quot;WBHome&quot;, &#123; luicode: 10000835, lfid: window.config.wm + &quot;_home&quot;&#125;)default.toappRouter(&quot;com.sina.weibo.quickapp&quot;, &quot;WBDetail&quot;, &#123; blog_id: e.params.id, luicode: 10000835, lfid: window.config.wm + &quot;_detail&quot;&#125;) 看不懂 javascript，而且代码也经过了混淆，但是可以推断出这里就是跳转到微博快应用的代码，可以去翻翻官方文档看看，也有类似的，而从捕获的url中，有一条 http://thefatherofsalmon.com/?i=com.sina.weibo.quickapp&amp;p=WBDetail&amp;a=blog_id%xxxxxxxxxx%xxxxxxxxxx%26lfid%3D_detail 这样的，每当捕获到这条 url 之后，应用就发生了跳转，其中的 i&#x3D;com.sina.weibo.quickapp和p&#x3D;WBDetail 刚好与上文中的 js 代码吻合，所以，应该是加载了这个 js 页面后，页面内有跳转到快应用的逻辑，所以发生了跳转，只不过我们常见的是点击“在应用内打开”再去打开，而这里是直接就跳转了 而跳转时，当手机内没有快应用的时候，就会发生报错，类似没有安装微博时的报错 可以到官网论坛看到什么样的机型才支持快应用 厂商 快应用支持机型 具体机型 华为 使用华为应用市场8.0.3以上版本支持 更新最新版应用商店（8.0.3）后均支持 金立 Andorid 5.0以上机型均支持 S10、S10L；F103、S10、S10L、GN3003、F100、F105、GN3001、GN5007、M7GN5005、S9 小米 MIUI8.5以上 除米1、红米1外全支持 魅族 Flyme6.3.0.0固件版本大部分机型;Flyme7全版本机型 MX4、MX4 Pro、魅蓝 note、魅蓝 note2、MX5、魅蓝2、PRO 5、魅蓝 metal、魅蓝 Note3、PRO 6、PRO 6s、魅蓝 3、魅蓝 3s、MX6、魅蓝 E、魅蓝 U20、魅蓝 U10、魅蓝 Max、魅蓝 5、魅蓝 X、魅蓝 Note5、PRO 6 Plus、魅蓝 5s、魅蓝 E2、PRO 7 标准版、PRO 7 高配版、PRO 7 Plus、魅蓝 S6 努比亚 支持的机型：O：609, 611, 606N： 563, 589, 591, 595, 608, 612, 617M：531, 549, 569, 551, 573系统升级情况：目前最高版本是1.0.1.2是对应联盟1010的版本，各分支和rom都已经是这个1.0.1.2版本覆盖场景：桌面全局搜索、浏览器搜索、应用中心快应用专题 预装了快应用引擎NX608J,NX609J、红魔游戏手机，Z18mini OPPO Android4.4以上 安卓4.4版本以上全覆盖 vivo FuntouchOS 3.2及以上 X9i、X9、X9PLUS、X9s、X20、X20Plus、X20PlusUD、X21A&#x2F;X21&#x2F;X21UD、A&#x2F;X21UD、X21iA&#x2F;X21i、NEX、Y66i、Y75、Y79A、Xplay6、Y71、Y85、Y83&#x2F;Y83A、Z1 联想 负一屏支持18年新发布机型，商店覆盖所有机型 ZUI系统rom3.9，应用商店9.8版本以上 中兴 新发布机型 但是另一个类似的页面却又能正确加载而不发生跳转，看了代码发现是跟混合加载相关，在发生跳转的页面，有下面这样的代码 1234// 版本大于21 增加设置混合加载http和httpsif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 来看看这个 setMixedContentMode() 方法 翻译如下： 当安全源尝试从不安全的源加载资源时，配置 WebView 的行为， 默认情况下，以 Build.VERSION_CODES.KITKAT 或更低版本为目标的应用程序默认为 MIXED_CONTENT_ALWAYS_ALLOW， 针对 Build.VERSION_CODES.LOLLIPOP 的应用默认为 MIXED_CONTENT_NEVER_ALLOW， WebView 的首选和最安全的操作模式是 MIXED_CONTENT_NEVER_ALLOW，强烈建议不要使用 MIXED_CONTENT_ALWAYS_ALLOW 而它的三个参数的说明如下： MIXED_CONTENT_ALWAYS_ALLOW 在这种模式下，WebView是可以在一个安全的站点（Https）里加载非安全的站点内容（Http），这是WebView最不安全的操作模式，尽可能地不要使用这种模式 MIXED_CONTENT_COMPATIBILITY_MODE 在这种模式下，当涉及到混合式内容时，WebView会尝试去兼容最新Web浏览器的风格，一些不安全的内容（Http）能被加载到一个安全的站点上（Https），而其他类型的内容将会被阻塞，这些内容的类型是被允许加载还是被阻塞可能会随着版本的不同而改变，并没有明确的定义，这种模式主要用于在App里面不能控制内容的渲染，但是又希望在一个安全的环境下运行，兼容模式下会对部分元素进行加载，策略未严格指定，一般默认加载图片、音视频，屏蔽HTML、JS、CSS，为获得最高安全性，建议应用程序使用MIXED_CONTENT_NEVER_ALLOW MIXED_CONTENT_NEVER_ALLOW Webview 不允许一个安全的站点（https）去加载非安全的站点内容（http），比如 https 网页内容的图片是http链接。强烈建议App使用这种模式，因为这样更安全 通俗地说，现在很多网站都改成了 https 进行访问，https 可以提升访问网站的安全性，防止信息被窃取，如果所有的网页都是 https 且网页内的链接也是都是 https，那就没有混合加载的问题了，但是仍然有一些资源现阶段还没有改变成 https 访问，往往页面都嵌入了 http 的链接，这种混合网页如果不进行处理，直接加载是会出现错误的，比如某些图片加载不出来等等 查看上面的 js 页面的那条让应用跳转的 url，头部正是 http 开头的 http://thefatherofsalmon.com/?i=com.sina.weibo.quickapp&amp;p=WBDetail&amp;a=blog_id%xxxxxxxxxx%xxxxxxxxxx%26lfid%3D_detail 所以我猜测问题应该是出在这里，在Android 5.0（Api Level 21）以下，默认采用的是 MIXED_CONTENT_ALWAYS_ALLOW 模式，即总是允许 WebView 同时加载 Https 和 Http，而从 Android 5.0（Api Level 21）开始，默认使用 MIXED_CONTENT_NEVER_ALLOW 模式，即总是不允许 WebView 同时加载 Https 和 Http，所以在没有设置 MIXED_CONTENT_NEVER_ALLOW 模式的那个页面，当我没有 setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW) 时，并没有加载到这条不安全的 url，所以才没有跳转 总结新浪微博在 17 年已经启用 https，在使用中很少发现 http 的，在测试中可以正常加载，因此应该可以放心地使用 MIXED_CONTENT_NEVER_ALLOW 模式，不启用混合加载了，但是其他页面还说不定，所以在关于加载微博的地方使用 MIXED_CONTENT_NEVER_ALLOW 模式，在公共的 WebView 里还是使用 MIXED_CONTENT_ALWAYS_ALLOW 模式会比较好，在混合加载并只加载 http&#x2F;https 头时小米、OPPO 还是会跳转快应用而华为、联想、金立、一加、努比亚、中兴、vivo、魅族就不跳转了，不过我测试的是部分机型，有的机型优测上面没有，所以实际的情况还不太清楚，而快应用则是我平时比较少见到的，不是这次的bug都忘了还有这个东西，总之在使用WebView加载网页时还有很多大大小小的坑，这次只是其中一个，也发现了 WebView 在使用中的很多应该注意的点，以后开发中再遇到的时候再记录下来 参考文章：关于shouldOverrideUrlLoading方法的一些考证","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"WebView","slug":"WebView","permalink":"https://enderhoshi.github.io/tags/WebView/"},{"name":"快应用","slug":"快应用","permalink":"https://enderhoshi.github.io/tags/%E5%BF%AB%E5%BA%94%E7%94%A8/"}]},{"title":"Nexus6p 刷机指北","slug":"Nexus6p 刷机指北","date":"2018-12-05T03:05:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2018/12/05/Nexus6p 刷机指北/","link":"","permalink":"https://enderhoshi.github.io/2018/12/05/Nexus6p%20%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/","excerpt":"作为 Android 开发者，肯定要对各种 Android 手机都非常熟悉（但是却使用 iPhone），那自然也不能少了 Google 亲儿子中的 Nexus 系列了，为了体验一下原生 Android 的流畅和官方全家桶的舒适体验，我在某宝上面弄了一台 450RMB 的 Nexus6P，这几天拿到了，准备鼓捣鼓捣，学习一下","text":"作为 Android 开发者，肯定要对各种 Android 手机都非常熟悉（但是却使用 iPhone），那自然也不能少了 Google 亲儿子中的 Nexus 系列了，为了体验一下原生 Android 的流畅和官方全家桶的舒适体验，我在某宝上面弄了一台 450RMB 的 Nexus6P，这几天拿到了，准备鼓捣鼓捣，学习一下 首先踩的坑肯定就是网络相关的了，因为众所周知的原因，这个亲儿子无法与亲爹服务器取得联络，所以即使是连上了正常的 WiFi，也非常调皮地在右上角显示“已连接，但无法访问互联网”，只有当你不断点击跳过各种设置后，才可以上网，但是右上角仍然是显示一个带叉叉的 WiFi 图标，用以提醒你当前的网络不是稳定的科学的网络 既然这篇想讲刷机，现在又已经能上网了，先来研究下刷机和 root 是怎么回事，网络这个问题，就留待以后再研究了 开始刷机我拿到手机的时候，店家就已经帮我刷了 8.1.0 版本的 Android，想要刷机，先去看看都有些什么镜像，因为是入门，这里就直接去下载官方镜像，以后再看看其他各种魔改的镜像，拿到想要刷的镜像之后，有以下几个步骤： 配置 ADB 环境变量（SDK） 搜索下载 ADB，这里不再赘述，ADB 的相关指令可以自行 Google 安装 ADB 手机驱动 只要下好ADB，连接上手机，电脑会自动下载并为手机安装上驱动，这里也不赘述 解锁 BootLoader 手机关机后，长按音量-和电源键，一直到看见一个盖子打开躺在地上的安卓机器人为止。这时就已经进入了 fastboot 页面了，这时可以看到左下角的一些关于手机的信息 其中有一条 Device is LOCKED ，那现在就来解锁设备，命令行输入： 1fastboot devices 检查链接设备 前边的序列号就是你的设备的Serial Number（序列号），后边为fastboot链接，如果得不到这样的结果，可能是 adb 和驱动没有配置好。弄好了继续输入 1fastboot oem unlock 手机会跳转到一个页面，问你是否解锁，但是这时我遇到一个报错，提示未知命令 看了下官方文档，也就是上方的下载镜像文件的网址，原来是指令已经更换为： 1fastboot flashing unlock 输入后，正确跳转到询问是否解锁的页面 按音量上键，选择 yes，点击电源键确定，稍后手机会重启进入 recovery，重启就好了，可能时间比较长，静静等候。（在这一步中，已经刷入第三方 recovery 的话，重新解锁会卡死在开机动画，或者在开机画面不断循环，还要重新刷镜像，但是不要重刷 recovery，重刷 recovery 会把之前的第三方刷掉）重新进入 fastboot 界面，方法同上。 你会看到 Device is UNLOCKED 至此解锁完毕，要重新上锁也很简单，在 Bootbloader 下输入命令 1fastboot flashing lock Bootloader 会重新上锁。 线刷 前面操作都结束且成功，就可以开始线刷系统了，什么是卡刷和线刷呢？参考：线刷和卡刷的区别以及步骤 卡刷 卡刷就是通过内存卡给系统升级。在Android系统早期因为绝大多数手机自带的内存就比较小，所以都要借助外置SD卡来存放照片、音乐等。因为ROM刷机包体积都比较大，所以要将ZIP格式刷机包事先放入内存卡中，再通过第三方的recovery来将系统刷进去。（官方的recovery的没有提供相应的功能参考） 优点：方便、简单，刷机方法通用，不会破坏手机底层数据(所以理论上卡刷是不会将硬件刷坏); 缺点：需要借助第三方recovery，个别品牌或者机型需要事先获得ROOT权限才能够进行; 卡刷包一般是指代ota格式的更新包，它需要拥有差分更新的能力(在某些场合，卡刷包只包含新旧文件的差别以节省空间。如果不使用这个特性，ota格式的包也可以接近成为完整的刷机包)，因此需要一个能操作单个文件的平台上才能执行，这个平台就是recovery 卡刷包内部结构 system(系统apk文件) META-INF(签名信息) boot.img(内核)等文件夹和文件 线刷 通过数据线连接电脑来进行刷机，一般适用于官方的刷机包。也可以通过 fastboot 刷入第三方 recovery，通过如三星通过 KIES、ODIN，HTC 通过 RUU、索尼通过 flashtools 强刷工具等刷入 优点：可以进行底层修复，一般在升级过程中可直接将 bootloader、基带等一并升级，可在卡刷失败时可以使用官方刷机包进行救砖。 缺点：操作步骤繁琐，刷机工具调试复杂，刷机包必须和手机销售地对应，刷机过程中出现问题可能导致手机无法修复。 线刷包格式多种多样有：三星的是 .tar、.md5等，索尼为.ftf，HTC 为.exe等 简单了解了一下这两种刷机方式，然后解压我们下载好的系统镜像： 再把 image-angler-opm7.181205.001.zip 解压出来，得到一些 Recovery 和 system 的 img 文件，放到同一目录下，cd 进入此文件夹，依次执行： 123456fastboot flash recovery recovery.imgfastboot flash boot boot.imgfastboot flash system system.imgfastboot flash cache cache.imgfastboot flash userdata userdata.imgfastboot reboot 或者其实可以不用解压，Mac 系统直接把 .sh 文件拉到终端中，或者 &#x2F;flash-all.sh，Windows 系统双击打开 .bat 文件，就可以自动执行以上语句 最后就刷机成功了，开机就可以进入手机设置流程 adb fastboot 常用命令及刷机技巧12345678910111213141516adb devices 显示设备信息adb install 123.apk 安装一个软件adb uninstall -k 123.apk 删除一个软件adb shell 进入shell环境adb push c:/1.txt /sdcard/sdir/ 向设备推送文件adb pull /sdcard/1.txt C:/ 从设备取回文件adb reboot bootloader/recovery 使手机重启进入BL或REadb shell settings put global captive_portal_https_url https://www.google.cn/generate_204 去除 WiFi 叹号, 貌似仅对 Android 7 有效 穿插题外话本文有一些图片上传后旋转不正确，因为图片的 EXIF 里标记了旋转 Rotate 90 CW ，直接打开图片时 chrome 会自动调整过来，这时应该在图片链接尾部加上参数 imageMogr2&#x2F;auto-orient，如your_image_path?imageMogr2&#x2F;auto-orient，可以让图片正常显示，详情查看七牛云存储-图片高级处理，原问题点击此处查看，关于使用 HTML 语言调整 Markdown 中的图片的方法 有待更新这次只是简单地了解了刷机的基本操作和基本常识，root 失败了，卡在不断地进入 recovery 那里。但是好在还可以通过暂停再继续来跳过那个 bootloader 的页面，而要彻底关闭 bootloader，就比较复杂了。另外网络的问题还没有弄好，也没有体验到 Google 全家桶的强大，以后如果有空再研究下（虽然是不大可能再鼓捣刷机的东西了），附上几篇参考的文章： Android 手机刷机基础知识扫盲贴 使用 adb 工具刷机 Nexus 6P Android 8.0 Root教程","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"手机","slug":"手机","permalink":"https://enderhoshi.github.io/tags/%E6%89%8B%E6%9C%BA/"},{"name":"Nexus 6p","slug":"Nexus-6p","permalink":"https://enderhoshi.github.io/tags/Nexus-6p/"}]},{"title":"打造自己的 RSS 源","slug":"打造自己的 RSS 源","date":"2018-11-29T06:29:28.000Z","updated":"2025-07-09T09:33:16.190Z","comments":true,"path":"2018/11/29/打造自己的 RSS 源/","link":"","permalink":"https://enderhoshi.github.io/2018/11/29/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%20RSS%20%E6%BA%90/","excerpt":"如今我们可以通过各种 app、公众号、聚合信息网站获取相对大众并符合自己的信息，但也有缺点：我需要下载这么多个 app 吗？公众号我还需要一个个点开看吗？这些网站就拥有所有我想知道的吗？订阅 RSS 源就可以帮助我们解决这些问题","text":"如今我们可以通过各种 app、公众号、聚合信息网站获取相对大众并符合自己的信息，但也有缺点：我需要下载这么多个 app 吗？公众号我还需要一个个点开看吗？这些网站就拥有所有我想知道的吗？订阅 RSS 源就可以帮助我们解决这些问题 RSSRSS（Really Simple Syndication，简易信息聚合）是一种消息来源格式规范，表达了「聚合真的很简单」这样的愿景，我们可以将其看作是一种定制个性化推送信息的服务。 RSS 阅读器市面上有非常多的 RSS 阅读器，由于比较习惯使用手机阅读文章，所以我主要使用 App Store 上的 RSS 阅读器 不同的平台有不同的阅读器，这里不详细展开，有需要的再自行 google RSS 源RSS 阅读器有了，我们要订阅些什么源呢？可以看看知乎上的 这个你必读的 RSS 订阅源有哪些？这里面同样有一些关于 RSS 阅读器的内容，可以参考一下 参考文章：https://www.ifanr.com/app/770271 ，之后再作补全","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"博客部署","slug":"博客部署","permalink":"https://enderhoshi.github.io/tags/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"name":"RSS","slug":"RSS","permalink":"https://enderhoshi.github.io/tags/RSS/"}]},{"title":"关于 Git 忽略文件","slug":"关于 Git 忽略文件","date":"2018-11-28T13:36:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2018/11/28/关于 Git 忽略文件/","link":"","permalink":"https://enderhoshi.github.io/2018/11/28/%E5%85%B3%E4%BA%8E%20Git%20%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/","excerpt":"","text":"这两天把毕设拉到 Mac 上想解决一下闪退的问题，修改完提交的时候发现出现了一个 .DS_Store 文件，这个 .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件，如文件的图标位置或背景色，相当于 Windows 的 desktop.ini，而我并不想把这个多余的东西提交上去，上网看了下，附上两条命令便于查阅： 禁止 .DS_store 生成：打开“终端” ，复制黏贴下面的命令，回车执行，重启 Mac 即可生效1defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 恢复 .DS_store 生成： 1defaults delete com.apple.desktopservices DSDontWriteNetworkStores 但是我只是不想把它传上去而已，不至于禁止它生成，所以按往常一样写一个 .gitignore 文件就好，操作如下： 创建 .gitignore 文件： 1touch .gitignore 编辑 .gitignore 文件： 1vim .gitignore 补充 .gitignore 的内容，按规则填写想要忽略的文件： 12345678910111213141516bin.idea/*.iml*.classes*.jar*.war*.eartarget.settings.classpath.project.metadata/classes/logs/*.logrebel.xml 保存 .gitignore 并退出编辑： 按 ESC 键，并输入以下命令，完成操作 1：wq 要忽略的文件少的时候，还可以自己来填写 .gitignore 的内容，但是当项目复杂了大了的时候，总不能每次都自己去想要忽略些什么，于是 github 官方整理了一些 .gitignore 对应不同开发场景的范例，可以点击这里跳转查看，找到想要的，直接 copy 下来改个名字扔进工作空间里就可以了 点开一个 Android 的来看看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Built application files*.apk*.ap_*.aab# Files for the ART/Dalvik VM*.dex# Java class files*.class# Generated filesbin/gen/out/# Gradle files.gradle/build/# Local configuration file (sdk path, etc)local.properties# Proguard folder generated by Eclipseproguard/# Log Files*.log# Android Studio Navigation editor temp files.navigation/# Android Studio captures foldercaptures/# IntelliJ*.iml.idea/workspace.xml.idea/tasks.xml.idea/gradle.xml.idea/assetWizardSettings.xml.idea/dictionaries.idea/libraries.idea/caches# Keystore files# Uncomment the following lines if you do not want to check your keystore files in.#*.jks#*.keystore# External native build folder generated in Android Studio 2.2 and later.externalNativeBuild# Google Services (e.g. APIs or Firebase)google-services.json# Freelinefreeline.pyfreeline/freeline_project_description.json# fastlanefastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_outputfastlane/readme.md 可以看到，按照官方的建议，忽略了一些编译生成的文件，一些本地的配置，还有日志等等，那么如果真的要我们自己编写 .gitignore，我们应该遵循什么样的规则呢，想把忽略掉的文件强行add又要怎么做呢，更加详尽的说明如下，原文地址 Git Ignore1.WHY?当你使用 git add . 的时候有没有遇到把你不想提交的文件也添加到了缓存中去？比如项目的本地配置信息，如果你上传到 Git 中去其他人 pull 下来的时候就会和他本地的配置有冲突，所以这样的个性化配置文件我们一般不把它推送到 git 服务器中，但是又为了偷懒每次添加缓存的时候都想用 git add . 而不是手动一个一个文件添加，该怎么办呢？很简单，git 为我们提供了一个 .gitignore 文件只要在这个文件中申明那些文件你不希望添加到 git 中去，这样当你使用 git add . 的时候这些文件就会被自动忽略掉。 2.忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 3.使用方法首先，在你的工作区新建一个名称为 .gitignore 的文件。然后，把要忽略的文件名填进去，Git 就会自动忽略这些文件。不需要从头写 .gitignore 文件，GitHub 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览，上面已经附上链接直接跳转 4.栗子比如你的项目是 java 项目，.java 文件编译后会生成 .class 文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接使用 github 的 Java .gitignore 文件模板将这些忽略文件信息复制到你的 .gitignore 文件中去： 123456789101112*.class# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.ear# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid* 可以看到 github 为我们提供了最流行的 .gitignore 文件配置，保存 .ignore 文件后我们查看下 git status，检查下是否还有我们不需要的文件会被添加到 git 中去： 123456789101112131415$ git statusOn branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: .gitignore new file: HelloWorld.javaUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) Config.ini 比如我的项目目录下有一个 Config.ini 文件，这个是个本地配置文件我不希望上传到 git 中去，我们可以在 gitignore 文件中添加这样的配置： 1Config.ini 或者你想忽略所有的 .ini 文件你可以这样写： 1*.ini 如果有些文件已经被你忽略了，当你使用 git add 时是无法添加的，比如我忽略了 *.class，现在我想把 HelloWorld.class 添加到 git 中去： 1234$ git add HelloWorld.classThe following paths are ignored by one of your .gitignore files:HelloWorld.classUse -f if you really want to add them. git 会提示我们这个文件已经被我们忽略了，需要加上 -f 参数才能强制添加到 git 中去： 1234567891011$ git statusOn branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: .gitignore new file: HelloWorld.class new file: HelloWorld.java 这样就能强制添加到缓存中去了。如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用 rm 命令将其从中移除： 12$ git rm HelloWorld.class --cachedrm &#x27;HelloWorld.class&#x27; 如果你已经把不想上传的文件上传到了 git 仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后 pull 代码到本地仓库这些文件就会被删除，或者从本地删除这些文件并且在 .gitignore 文件中添加这些你想忽略的文件，然后再 push 到远程仓库。 5.查看 gitignore 规则如果你发现 .gitignore 写得有问题，需要找出来到底哪个规则写错了，可以用 git check-ignore 命令检查： 12$ git check-ignore -v HelloWorld.class.gitignore:1:*.class HelloWorld.class 可以看到 HelloWorld.class 匹配到了我们的第一条 *.class 的忽略规则所以文件被忽略了 6.忽略规则文件语法a.忽略指定文件&#x2F;目录123456# 忽略指定文件HelloWrold.class# 忽略指定文件夹bin/bin/gen/ b.通配符忽略规则通配符规则如下： 12345678# 忽略.class的所有文件*.class# 忽略名称中末尾为ignore的文件夹*ignore/# 忽略名称中间包含ignore的文件夹*ignore*/ 7.不生效问题先把本地缓存删除（改变成未track状态），然后再提交 123git rm -r --cached .git add .# 然后再提交","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"git","slug":"git","permalink":"https://enderhoshi.github.io/tags/git/"}]},{"title":"关于操作系统尾部换行符","slug":"关于操作系统尾部换行符","date":"2018-11-28T13:36:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2018/11/28/关于操作系统尾部换行符/","link":"","permalink":"https://enderhoshi.github.io/2018/11/28/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%BE%E9%83%A8%E6%8D%A2%E8%A1%8C%E7%AC%A6/","excerpt":"","text":"之前从 Windows 更换到 Mac，pull 代码下来修改完提交时，发现一个提示 说我正在提交一个 CRLF 文件到仓库上，问我要怎么处理。而在使用 git add . 指令时，也会弹出如下一些警告： 123456warning: LF will be replaced by CRLF in .idea/inspectionProfiles/Project_Default.xml.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in app/src/main/java/com/hoshi/viewtestdemo/view/visualizer/VisualizerView.java.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in gradlew.The file will have its original line endings in your working directory 这个 CRLF 其实是不同操作系统的尾部换行符的格式，CR（Carriage Return），LF（LineFeed），CRLF（Carriage Return Line Feed），中文意思就是回车换行 回车符就是回到一行的开头，用符号 r 表示，十进制 ASCII 代码是 13，十六进制代码为0x0D，回车（return）； 换行符就是另起一行，用 n 符号表示，ASCII 代码是 10，十六制为 0x0A， 换行（newline） 所以我们平时编写文件的回车符应该确切来说叫做回车换行符，它们的应用情况如下 Dos 和 Windows 平台： 使用回车（CR）和换行（LF）两个字符来结束一行，回车 + 换行(CR+LF)，即“\\r\\n”； Mac 和 Linux平台：只使用换行（LF）一个字符来结束一行，即“\\n”； 最早Mac每行结尾是回车CR 即’\\r’，后mac os x 也投奔了 unix 许多 Windows 上的编辑器会悄悄把行尾的换行（LF）字符转换成回车（CR）和换行（LF），或在用户按下 Enter 键时，插入回车（CR）和换行（LF）两个字符 假如你正在 Windows 上写程序，又或者你正在和其他人合作，他们在 Windows 上编程，而你却在其他系统上，在这些情况下，就可能会遇到行尾结束符问题，这是因为 Windows 使用回车和换行两个字符来结束一行，而 Mac 和 Linux 只使用换行符一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作，在提交时产生非常多的冲突 对于不同的平台，有不同的处理方案： Git可以在你提交时自动地把行结束符 CRLF 转换成 LF，而在检出代码时把 LF 转换成 CRLF。设置 core.autocrlf 来打开此项功能，如果是在 Windows 系统上，就把它设置成 true，这样当检出代码时，LF 会被转换成CRLF： 1$ git config --global core.autocrlf true Linux 或 Mac 系统使用LF作为行结束符，因此你不想 Git 在检出文件时进行自动的转换；当一个以 CRLF 为行结束符的文件不小心被引入时你肯定想进行修正，把 core.autocrlf 设置成 input 来告诉 Git 在提交时把 CRLF 转换成 LF，检出时不转换： 1$ git config --global core.autocrlf input 这样会在 Windows 系统上的检出文件中保留 CRLF，会在 Mac 和 Linux 系统上，包括仓库中保留 LF。 如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车符记录在库中： 1$ git config --global core.autocrlf false 上面三条总结起来就是下面的情形，x 是你当前使用的系统所使用的换行方式 1231) true: x -&gt; LF -&gt; CRLF # 提交时转换为 LF，检出时转换为 CRLF2) input: x -&gt; LF -&gt; LF # 提交时转换为 LF，检出时不转换3) false: x -&gt; x -&gt; x # 提交检出均不转换 项目已经存在换行符不同的问题的解决方案 如果当前开发有多个分支且各分支不同步，需要每个分支进行一次转换 如果只有一个分支或多个分支处于同一节点。可以从 master 切换一个新分支，进行转换，然后 commit ，将此分支合并到所有分支。 将修改过的分支 push 到 gitlab，让其他成员更新代码即可。 Ps：由于每个人系统不同或者就是 git 的问题，可能出现更新完代码换行符不变，这时以服务器上的代码为准重新 clone 一份最新代码即可 一些要注意的点 git 的 Windows 客户端基本都会默认设置 core.autocrlf&#x3D;true，设置 core.autocrlf&#x3D;true, 只要保持工作区都是纯 CRLF 文件，编辑器用 CRLF 换行，就不会出现警告了，这里出现警告，就是因为文件用了 LF 换行 Linux 最好不要设置 core.autocrlf，因为这个配置算是为 Windows 平台定制 Windows 上设置 core.autocrlf&#x3D;false，仓库里也没有配置 .gitattributes，很容易引入 CRLF 或者混合换行符（Mixed Line Endings，一个文件里既有 LF 又有CRLF）到版本库，这样就可能产生各种奇怪的问题 参考文章","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://enderhoshi.github.io/tags/Mac/"},{"name":"git","slug":"git","permalink":"https://enderhoshi.github.io/tags/git/"}]},{"title":"加载自定义 View 应用闪退 | @JvmOverloads 详解","slug":"加载自定义 View 闪退和 JvmOverloads 注解","date":"2018-11-21T13:29:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2018/11/21/加载自定义 View 闪退和 JvmOverloads 注解/","link":"","permalink":"https://enderhoshi.github.io/2018/11/21/%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E9%97%AA%E9%80%80%E5%92%8C%20JvmOverloads%20%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"前言前不久项目中要求实现一些小控件，用来展示图表或者显示正反双方的人数对比，于是就自定义了一些 View，用于绘图 把 View 写好后，放到程序里跑起来，却闪退了，报错提示 1234567java.lang.IllegalStateException: itemView.sev_safety_score_bar must not be null或者android.view.InflateException: Binary XML file line #77: Binary XML file line #77: Error inflating class Caused by: android.view.InflateException: Binary XML file line #77: Error inflating class Caused by: java.lang.NoSuchMethodException: &lt;init&gt; [class android.content.Context, interface android.util.AttributeSet] 原因分析一般这种情况，会有几种原因： 引用类名问题：自定义一个 View 之后，将他用于布局文件中，必须使用完整路径名来引用，不能只使用类名，检查了一下，不是这个原因导致的 编译的中间文件没有清理干净，就是你在原生系统代码的编译环境下编译 APK 之后，特别是修改了 XML，出现标题所述现象，这个时候你只需要删除 out 目录下编译生成的中间文件夹即可（具体名字记不清了:在编译过程中，系统会将那个位置打印出来，通过串口来看吧，…&#x2F;out&#x2F;……&#x2F;….&#x2F;classes.dex，你循着这个路径往前推到你的应用的 project 名字那一层文件夹），删除再重新 make 就 OK 了，但是我好像也不是这个原因，Invalidate Caches &#x2F; Restart 并不起作用 找不到 drawable 的资源文件，对应的 drawable 的 hdpi 或 xhdpi 等文件夹的图片资源有缺失，但是我显然不是因为这个 构造函数问题：自定义 View，派生实现基类 View 的构造函数不全 1234567class SafetyExamView : View &#123; constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet) : super(context, attrs) constructor(context: Context, attrs: AttributeSet?, defStyle: Int) : super(context, attrs, defStyle)&#125;// 可以简化为以下这样class SafetyExamView @JvmOverloads constructor(context: Context, attributeSet: AttributeSet? = null, defStyle: Int = 0) : View(context, attributeSet, defStyle) &#123;&#125; 从网上的一些说法来看，第二个和第三个构造函数对于XML这种引用方式是必须实现的，这三个构造函数是在不同的应用场合来实例化一个 View 对象的，但是事实是不是这样的呢，我发现了一些不同的看法 不过在当前这里看来，我在新建这个 View 编写构造函数的时候，有些构造函数的参数没写全，比如上面的第二条 constructor，后面我写成了: super(context)，所以根本没有调用到父类的第二个构造函数，所以看来问题是出在这里了，当时看到提示后面的 Parameter ‘attrs’ is never used 还觉得无所谓，原来是不可以的，于是补上构造函数的参数，再次运行，果然没问题了 拓展可以看到上面我使用了 @JvmOverloads 注解，那么刚好可以研究分析下这个 @JvmOverloads 注解是用来干嘛的，可以参考官方文档： 指示 Kotlin 编译器为此函数生成替换默认参数值的重载。 如果一个方法有N个参数且其中M个具有默认值，则会生成M个重载：第一个参数采用 N - 1 个参数（除了最后一个参数采用默认值），第二个采用 N - 2 个参数，等等上。 更加详细的官方文档： 通常，如果你写一个有默认参数值的 Kotlin 函数，在 Java 中只会有一个所有参数都存在的完整参数签名的方法可见，如果希望向 Java 调用者暴露多个重载，可以使用 @JvmOverloads 注解。 该注解也适用于构造函数、静态方法等。它不能用于抽象方法，包括在接口中定义的方法。 123class Foo @JvmOverloads constructor(x: Int, y: Double = 0.0) &#123; @JvmOverloads fun f(a: String, b: Int = 0, c: String = &quot;abc&quot;) &#123; …… &#125;&#125; 对于每一个有默认值的参数，都会生成一个额外的重载，这个重载会把这个参数和它右边的所有参数都移除掉。在上例中，会生成以下代码 ： 1234567// 构造函数：Foo(int x, double y)Foo(int x)// 方法void f(String a, int b, String c) &#123; &#125;void f(String a, int b) &#123; &#125;void f(String a) &#123; &#125; 请注意，如次构造函数中所述，如果一个类的所有构造函数参数都有默认值，那么会为其生成一个公有的无参构造函数。这就算没有 @JvmOverloads 注解也有效。 官方文档如是说，然而这次踩坑引出来的可不只是这个注解的问题，在我删除一些构造函数，复现报错然后把报错信息粘贴上来的时候，我记得好像并不是这个错误，这就奇怪了，难道还跟不同的构造方法有关？一查，果然，上文提到的报错信息里，当中的第一条，也就是： 1java.lang.IllegalStateException: itemView.sev_safety_score_bar must not be null 是我在有 @JvmOverloads 注解的前提下，直接从: View(context, attributeSet, defStyle) 中把后两个参数删除，从而复现出来的，这就是说，重载三个构造函数的时候，调用的父类方法都是 View(context) 这个，这时就会报上面这条错误，说我的 View 为空 而第二条报错信息，也就是： 123android.view.InflateException: Binary XML file line #77: Binary XML file line #77: Error inflating class Caused by: android.view.InflateException: Binary XML file line #77: Error inflating class Caused by: java.lang.NoSuchMethodException: &lt;init&gt; [class android.content.Context, interface android.util.AttributeSet] 则是我直接把 @JvmOverloads 注解删除，也就是只声明了第三个构造函数时，所复现出来的，也就是说，在不写第一第二条构造函数的时候，就会找不到 XML 中声明的对应的类，而这时，我把 defStyle: Int 参数移除，就是变成第二种构造函数的时候，发现又可以正常运行了，而当我只写第一条构造函数时，又发生了这个报错，那就意味着，在缺少第二条构造函数时，就会报这个错误，而在存在第二条函数，但是函数参数不全时，就会报上一条错误 由此可以看出，第二个构造函数是必须的，在网上查阅了相关文章，发现确实是如此，得出以下结论： Context：上下文，这个不用多说 AttributeSet attrs： 从xml中定义的参数 int defStyleAttr ：主题中优先级最高的属性 int defStyleRes ： 优先级次之的内置于View的style 在android中的属性可以在多个地方进行赋值，涉及到的优先级排序为：xml 直接定义 &gt; xml 中 style 引用 &gt; defStyleAttr &gt; defStyleRes &gt; theme 直接定义 网上有很多关于三个构造函数使用时机的说法，搜到的比较正确的是: 在代码中直接 new 一个 Custom View 实例的时候，会调用第一个构造函数，这个没有任何争议 在 xml 布局文件中调用 Custom View 的时候，会调用第二个构造函数，这个也没有争议 在 xml 布局文件中调用 Custom View，并且 Custom View 标签中还有自定义属性时，这里调用的还是第二个构造函数 也就是说，系统默认只会调用 Custom View 的前两个构造函数，至于第三个构造函数的调用，通常是我们自己在构造函数中主动调用的（例如，在第二个构造函数中调用第三个构造函数） 至于自定义属性的获取，通常是在构造函数中通过 obtainStyledAttributes 函数实现的 然后我自己做了个实验，验证了一些看法，也加深了自己的理解，首先上文中提及的 @JvmOverloads 注解，只是将 kotlin 的重载暴露给了 java 使用，也就是说，在 kotlin 中，可以直接利用构造函数赋默认值的方法来重载，但是因为 java 中没有这种机制，如官方文档所说：“写一个有默认参数值的 Kotlin 函数，在 Java 中只会有一个所有参数都存在的完整参数签名的方法可见”，如果要将重载的方法暴露给 java，就要使用 @JvmOverloads 注解 而kotlin中的利用参数赋默认值来进行重载又是怎么样的呢，接下来可以看下我的实验： 没有默认值，就没有重载，构造方法就是声明的那一条 第一个参数有默认值 第一第二个参数有默认值 第一第三个参数有默认值 第二第三个参数有默认值 三个参数都有默认值 这里接近文档所说：“对于每一个有默认值的参数，都会生成一个额外的重载，这个重载会把这个参数和它右边的所有参数都移除掉”，但是好像应该作些修改，并不是把右边所有”参数“都移除，而是把右边所有”有默认值的参数移除“，这样似乎更加正确，不过还有待考证 参考文章：Android View 四个构造函数详解","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"https://enderhoshi.github.io/tags/View/"}]},{"title":"Android 字体使用探索","slug":"Android 字体使用探索","date":"2018-11-14T13:16:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2018/11/14/Android 字体使用探索/","link":"","permalink":"https://enderhoshi.github.io/2018/11/14/Android%20%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言之前开发时有使用到 TextView 或者绘图画文字的时候，并不会太在意文字的字体，因为设计给出的设计图都是比较普通的字体，今天在做一个新页面的时候，看到设计图中有部分地方的字体是不一样的，所以开始摸索下要怎样使用 Android 里的字体 官方文档查阅官方的文档可以看到下面的信息 XML 中的字体 Android 8.0（API级别26）引入了一项新功能，即 XML 中的字体，它允许您将字体用作资源。您可以在 font 文件 res&#x2F;font&#x2F; 夹中添加文件以将字体捆绑为资源。这些字体在您的 R 文件中编译，并在 Android Studio 中自动提供。我们可以借助新资源类型访问字体资源 font。例如，要访问字体资源，就可以使用 @font&#x2F;myfont 或 R.font.myfont 要在运行 Android 4.1（API级别16）及更高版本的设备上使用字体 XML 功能，请使用支持库 26。有关使用支持库的更多信息，请参阅使用支持库 以上是文档开头的简介，接着往下看，可以看到，在 API level 26 或者以上时，只需简单的几步就可以使用字体资源: 如何使用 首先要创建一个字体资源文件夹： 然后创建好的目录如图： 而项目里的字体资源文件放置在assets目录下： 然后调用 123456TypefaceManager 初始化...// TypefaceManager 中const val PRICE_TEXT_THIN = &quot;fonts/DIN-Regular.otf&quot;const val PRICE_TEXT_BOLD = &quot;fonts/DIN-Bold.otf&quot;const val PRICE_TEXT_MEDIUM = &quot;fonts/DIN-Medium.otf&quot; 来进行使用，估计是版本兼容会更好，暂时还没深究原因 双击放进去的字体资源文件就可以查看字体的预览： 然后就可以通过xml或者Java去设置字体 123456//xmlandroid:fontFamily=&quot;@font/merriweather_regular&quot;//javaTypeface typefaceLato = getResources().getFont(R.font.lato_regular);mTextIntro.setTypeface(typefaceLato); 画文字的时候使用 paint 来设置字体，会有一些差别，暂时我还没怎么遇到，可以查看附在文末的相关文章 也可以指定一个基本的字体样式，如粗体，斜体或两者的组合 1mTextIntro.setTypeface(typefaceLato，Typeface.BOLD_ITALIC); 如果使用的是字体系列，则会有相同的字体，权重不同有不同的效果 这里的权重可以去谷歌字体官方网站去查看，当你在官网选中了想要的字体之后，从下方的 Your Selection 中可以选择你要下载的字体，而旁边就有字体的权重，选择了相应权重后，右边会提示载入时间，当你选择过多的时候就会变成 Slow 而不是 Fast 值得注意的是，假设我正在使用 Merriweather-Regular，如果将字体样式设为粗体 Bold，Android 将从我的字体系列中选择 Merriweather-Bold，并显示出来 然后我也找到些stackoverflow上关于字体的问答，是关于预定义的，即系统中本来就有的一些字体的内容，如下： From android 4.1 &#x2F; 4.2 &#x2F; 5.0, the following Roboto font families are available: 123456android:fontFamily=&quot;sans-serif&quot; // roboto regularandroid:fontFamily=&quot;sans-serif-light&quot; // roboto lightandroid:fontFamily=&quot;sans-serif-condensed&quot; // roboto condensedandroid:fontFamily=&quot;sans-serif-black&quot; // roboto blackandroid:fontFamily=&quot;sans-serif-thin&quot; // roboto thin (android 4.2)android:fontFamily=&quot;sans-serif-medium&quot; // roboto medium (android 5.0) 配合使用 1android:textStyle=&quot;normal|bold|italic&quot; this 16 variants are possible:（有16种可用的变体） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Added in Android Jelly Bean (4.1) - API 16 :Regular (default):&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;normal&lt;/item&gt; Italic:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;Bold:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;bold&lt;/item&gt;Bold-italic:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;bold|italic&lt;/item&gt;Light:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-light&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;normal&lt;/item&gt;Light-italic:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-light&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;Thin :&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-thin&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;normal&lt;/item&gt;Thin-italic :&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-thin&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;Condensed regular:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-condensed&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;normal&lt;/item&gt;Condensed italic:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-condensed&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;Condensed bold:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-condensed&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;bold&lt;/item&gt;Condensed bold-italic:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-condensed&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;bold|italic&lt;/item&gt;Added in Android Lollipop (v5.0) - API 21 :Medium:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-medium&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;normal&lt;/item&gt;Medium-italic:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-medium&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;Black:&lt;item name=&quot;android:fontFamily&quot;&gt;sans-serif-black&lt;/item&gt;&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;&lt;!-- 将字体封进style中 --&gt;&lt;style name=&quot;customfontstyle&quot; parent=&quot;@android:style/TextAppearance.Small&quot;&gt; &lt;item name=&quot;android:fontFamily&quot;&gt;@font/lobster&lt;/item&gt; &lt;item name=&quot;android:textStyle&quot;&gt;normal&lt;/item&gt;&lt;/style&gt; 除此之外，还可以创建自己的字体系列，步骤如下： 右键单击字体文件夹，然后转到“ 新建”&gt;“字体资源文件”。将出现“新建资源文件”窗口。 输入文件名，然后单击“ 确定”。新的字体资源XML在编辑器中打开。 然后编写自己的字体系列，那么这里就用到权重了 12345678910&lt;font-family xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;font android:fontStyle=&quot;normal&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/lobster_regular&quot; /&gt; &lt;font android:fontStyle=&quot;italic&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/lobster_italic&quot; /&gt;&lt;/font-family&gt; 这只是将特定fontStyle和fontWeight映射到将用于呈现该特定变体的字体资源。fontStyle的有效值是normal、italic或bold， 而fontWeight需要符合CSS font-weight规范 注意事项注意：通过支持库在XML布局中声明字体系列时，请使用app命名空间来确保加载字体。（谷歌官方文档） 注意：从Android Support Library 26.0开始，您必须声明两组属性（android:和app:)，以确保在运行Api 26或更低版本的设备上加载字体。如下所示（stackoverflow） 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;font-family xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;font android:fontStyle=&quot;normal&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/myfont-Regular&quot; app:fontStyle=&quot;normal&quot; app:fontWeight=&quot;400&quot; app:font=&quot;@font/myfont-Regular&quot;/&gt; &lt;font android:fontStyle=&quot;italic&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/myfont-Italic&quot; app:fontStyle=&quot;italic&quot; app:fontWeight=&quot;400&quot; app:font=&quot;@font/myfont-Italic&quot; /&gt;&lt;/font-family&gt; 系统字体的位置1D:\\Android\\sdk\\platforms\\android-N\\data\\fonts fonts.xml里还可以配置字体的别名 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string name=&quot;font_family_light&quot;&gt;sans-serif-light&lt;/string&gt; &lt;string name=&quot;font_family_medium&quot;&gt;sans-serif-medium&lt;/string&gt; &lt;string name=&quot;font_family_regular&quot;&gt;sans-serif&lt;/string&gt; &lt;string name=&quot;font_family_condensed&quot;&gt;sans-serif-condensed&lt;/string&gt; &lt;string name=&quot;font_family_black&quot;&gt;sans-serif-black&lt;/string&gt; &lt;string name=&quot;font_family_thin&quot;&gt;sans-serif-thin&lt;/string&gt;&lt;/resources&gt; 可下载的字体Android 8.0（API级别26）和 Android 支持库26引入了对API的支持，以便从应用程序请求字体，而不是将文件捆绑到APK或让APK下载字体。该功能可通过支持库26在运行 Android API 14 及更高版本的设备上使用 可下载字体功能具有以下优点： 减少APK大小 提高应用安装成功率 改善整体系统健康状况，因为多个APK可以通过提供商共享相同的字体。这样可以节省用户的蜂窝数据，手机内存和磁盘空间。在此模型中，需要时通过网络获取字体。关于可下载字体 参考文章 使用自定义字体资源 官方文档 谷歌字体 Android中Paint字体、粗细等属性的一些设置 How to change fontFamily of TextView in Android","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"}]},{"title":"Glide 无法加载细长图片解决方法","slug":"Glide 无法加载细长图片解决方法","date":"2018-11-08T14:01:28.000Z","updated":"2025-07-09T09:33:16.187Z","comments":true,"path":"2018/11/08/Glide 无法加载细长图片解决方法/","link":"","permalink":"https://enderhoshi.github.io/2018/11/08/Glide%20%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%BB%86%E9%95%BF%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"Glide 加载细长图片踩坑记录","text":"今天在开发过程中，看到测试的 bug 反馈中有一条挺有趣的，就是当用户发出很细很长的图片时，无法加载出那个细长图片，为什么说细长图片，而不直接说长图呢，接下来分享下这个 bug 的解决流程 以下就是今天看到的诡异 bug 可以看到，这个用户发了一条很长很长的图片，在安卓端显示的时候是空白的，但是在 iOS 端则是正常的，由此可以推断，后台返回给我们的数据应该是正常的，我验证了一下，在 postman 中发起请求，得到缩略图和原图后保存了下来，可以看到两个图片的信息如下： 明明就是实实在在存在的图像，怎么显示空白呢，同事之前遇到过一个无法显示长图的情况，那是因为图片的宽或者高超过了手机的限制，所以导致无法正常显示图片，解决的方案是载入图像时分段载入，就不会出现不显示图片的情况。但是我这里的两张图，一张顶多也就 5000，而缩略图更加诡异，明明只有 408 的高度，却显示不出来了，这就奇怪得很了，继续看看是什么原因 我依稀记得这个不是普通的写死宽高的 ImageView，也不是普通的 match_parent，wrap_content 之类的，于是去看了一下，果然，用的是一个重写的自适应高宽高比的自定义View，逻辑如下： 123456789101112131415161718192021222324252627282930313233public AdaptiveImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); maxSize = (int) context.obtainStyledAttributes(attrs, R.styleable.AdaptiveImageView). getDimension(R.styleable.AdaptiveImageView_maxSize, 720);&#125;/*** 通过maxSize 的最大宽高，自动适应高宽高* @param uri 图片的uri*/public void loadUri(String uri, LoadOptions loadOptions) &#123; ImageLoaderManager.INSTANCE.loadUri(this, uri, loadOptions, new ImageInfoCallback() &#123; @Override public void onFailed() &#123;&#125; @Override public void onSuccess(ImageSize imageSize) &#123; float originHeight = imageSize.getHeight(); float originWidth = imageSize.getWidth(); float adaptiveHeight, adaptiveWidth; if (originWidth &gt; originHeight) &#123; adaptiveWidth = maxSize; adaptiveHeight = originHeight * ((float) maxSize / originWidth); &#125; else &#123; adaptiveHeight = maxSize; adaptiveWidth = originWidth * ((float) maxSize / originHeight); &#125; ImageTools.INSTANCE.resizeView(AdaptiveImageView.this, (int)adaptiveWidth, (int)adaptiveHeight); &#125; &#125;);&#125; 那么可以看到，这个 View 是经过 resizeView，按照赋予它的最大宽高计算过后，再重新设定宽高的，我把这个控件重新设置后的宽高输出如下： 明明 width 就是 7.35，应该可以正常显示才是，我打开手机的开发者选项中的显示布局和边距模式，也可以看到确实是存在一个很细的 ImageView 的，但是图片却不显示出来，所以说问题也不出现在这个自适应高宽高的 View 上 那就可能是加载图片的时候出了问题了，项目是用 Glide 来加载图片的。我想要看到 Glide 的输出日志，但是项目内的 Glide 调用是在封装好的库中进行的，而且封装的时候并没有去监听 Glide 的异常输出，所以看不到异常信息，我又没办法修改这个库，那就简单写个 demo 去加载这个图片试试 结果发现，把 Glide 的 into 中的 Target 改为 ImageView 的时候，图片正常地显示出来了，那么这个 into 到底是什么的，可以参考官方的文档： 目标Glide中的目标作为请求跟请求者之间的传递者。目标负责显示占位符，加载的资源以及为每个请求确定合适的尺寸。最常用目标是使用ImageView显示占位符，Drawable和Bitmap的ImageViewTarget。用户还可以实现自己的目标，或者对任何可用的基类进行子类化。 指定目标into(Target) 方法不仅用于启动每个请求，同时也可以指定将要接收请求结果的目标。Glide 提供了一个辅助方法给into(ImageView)，其采用 ImageView 并把它包装在目标于适合所请求的资源类型。为了方便使用自定义目标，这些 into() 方法返回提供给他们的目标 郭霖在公众号中也提及了关于这个 into 以及 Target 的一些内容，节选一部分如下： 使用了这么久的 Glide，我们都知道 into() 方法中是可以传入 ImageView 的。那么 into() 方法还可以传入别的参数吗？我可以让 Glide 加载出来的图片不显示到 ImageView 上吗？答案是肯定的，这就需要用到自定义 Target 功能。 其实通过上面的分析，我们已经知道了，into() 方法还有一个接收 Target 参数的重载。即使我们传入的参数是 ImageView，Glide 也会在内部自动构建一个Target对象。而如果我们能够掌握自定义Target技术的话，就可以更加随心所欲地控制Glide的回调了。 我们创建了一个 SimpleTarget 的实例，并且指定它的泛型是 GlideDrawable，然后重写了 onResourceReady() 方法。在 onResourceReady() 方法中，我们就可以获取到 Glide 加载出来的图片对象了，也就是方法参数中传过来的 GlideDrawable 对象。有了这个对象之后你可以使用它进行任意的逻辑操作，这里我只是简单地把它显示到了 ImageView 上 SimpleTarget 中的泛型并不一定只能是 GlideDrawable，如果你能确定你正在加载的是一张静态图而不是 GIF 图的话，我们还能直接拿到这张图的 Bitmap 对象 Glide 在内部自动帮我们创建的 GlideDrawableImageViewTarget 就是 ViewTarget 的子类。只不过 GlideDrawableImageViewTarget 被限定只能作用在 ImageView 上，而 ViewTarget 的功能更加广泛，它可以作用在任意的 View 上 所以我的大致理解如下：给这个 Target 设置一个泛型，然后它会返回给你这个泛型的对象，你就可以拿这个返回的对象去处理一些事情了，而项目中返回的是 ImageView，返回的 resource 是 Drawable，我们就可以将 Drawable 给 set 到 ImageView 中了 然而就是在这里，使用细长图片的时候，调用的回调并不是 onResourceLoading，而是 onLoadFailed，说明图片加载出了错误，而 onLoadFailed 中并不会取得抛出的错误，那么就在 Glide 的 builder 中再加一条 .listener() 方法，去获取它的详细的报错信息 整个完整的小 demo 如下所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView imageView = findViewById(R.id.iv_test); RequestOptions requestOptions = new RequestOptions(); //requestOptions.override(80, 80);//设置width和height后可以正常显示 //requestOptions.signature(new ObjectKey(System.currentTimeMillis())); //网上说的缓存问题解决方案，并没有作用 //自己制作的细长图片https://github.com/EndeRHoshI/Photo/blob/master/blog/Glide/%E7%BB%86%E9%95%BF%E5%9B%BE%E6%A1%88.png?raw=true //原图 https://static.aicoinstorge.com/talk/18-11-07/100518-cdc-166.jpeg //缩略图 https://static.aicoinstorge.com/talk/18-11-07/100518-cdc-166.jpeg?x-oss-process=image/resize,m_mfit,h_408,w_4 //平时的普通图片 https://static.aicoinstorge.com/talk/18-11-08/082142-569-179.jpeg?x-oss-process=image/resize,m_mfit,h_408,w_176 //平时的普通图片 http://oz5ak1kvp.bkt.clouddn.com/cms_liuhua/user/img1516646371.jpg //into的参数使用imageView可以正常使用，问题出在不设置宽高的 target —— CustomViewTarget 上 Glide.with(imageView) .load(&quot;https://static.aicoinstorge.com/talk/18-11-07/100518-cdc-166.jpeg&quot;) .apply(requestOptions) .listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123; if (e != null) &#123; e.printStackTrace(); e.logRootCauses(&quot;root-lvqx&quot;); Log.d(&quot;lvqx-causes&quot;,&quot;\\nMessage----&gt;&quot; + e.getMessage() + &quot;\\nCauses----&gt;&quot; + e.getCauses()); &#125; return false; &#125; @Override public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123; return false; &#125; &#125;) .into(new CustomViewTarget&lt;ImageView, Drawable&gt;(imageView) &#123; @Override public void onLoadFailed(@Nullable Drawable errorDrawable) &#123; Log.d(&quot;glide-test&quot;, &quot;fail&quot;);//Options不设置宽高，设置CustomViewTarget，且图片过于细长的时候，会加载失败回调该方法 &#125; @Override public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) &#123; view.setImageDrawable(resource); &#125; @Override protected void onResourceCleared(@Nullable Drawable placeholder) &#123; Log.d(&quot;glide-test&quot;, &quot;cleared&quot;); &#125; &#125;); &#125;&#125; 获得的完整报错信息如下： 接下来我在 e.logRootCauses 方法输出的信息中找到了抛出这个 GlideException 的地方，就是 setDataSource 方法，这个 setDataSource 方法在 Glide 的 VideoDecoder 类中的 decode 方法中调用，具体抛出异常的地方如下： 在其中的 296 行中的 setDataSource 方法抛出 错误的描述是 1Caused by: java.lang.RuntimeException: setDataSource failed: status = 0x80000000 查到的结果是说，这个错误的意思是因为文件不完整，已损坏等等原因而读取错误 好了，那现在项目框架选择了使用 Glide 来加载图片，又封装好了特定的库去调用 Glide，无法修改其中内容，每当加载到这种奇葩细长图片的时候就无法显示，而且也不是之前同事遇到的超长图片的问题（图片的宽高远远没有达到手机限制的最大宽高，所以这个根本不是尺寸长短的问题，而是宽高比的问题，不能称之为长图加载失败，而是细长图加载失败….），那么到底要怎样解决呢 我再去看了下官方文档，看到了以下这条 override方法的官方api文档解释如下 这下可以改变 Target 的宽高来达到目的了，而且文档中也说了，应该只用于你需要一个很特别的图像尺寸的时候，这种细长图，够奇葩了，那就试着设置了一下，发现只要是设置了这个，图像都可以显示了，无论是 override(1, 1) 还是 override(80, 80)，都可以显示出来，只是如果设置宽高为1，会把图像处理成宽度为1个像素，然后拉伸填满 View，这样就会让图像面目全非，宽度 80 会好一点，那这个数当然不能写死，如果图像比较大的时候就会模糊不清，刚好看到接口中后台为了让 iOS 端正确显示图片而有传图像的宽高过来，把这个设置进去，就刚好可以设置 Target 的高度让其符合这张奇葩图片了，图像完美地显示了出来，bug 至此就修复了 总结bug 已经修复，但是问题还是很多，总结起来就是封装第三方库的时候最好把输出异常信息的操作也封装进去，这样会比较方便排查故障 然后还有几点没有弄懂的： 为什么普通的图片没有设置宽高，可以正常显示，而这个细长图片就不可以呢，是因为不能自适应？ 如果不能自适应，那么为什么 Target 设置成 ImageView 的时候又可以显示了呢？ setDataSource 方法只有在使用细长图案的时候才会调用到，然后抛出异常，我设置了断点，但是在使用正常图案时并没有跑到 setDataSource 方法中去，为什么呢？ 这个 CustomViewTarget 到底干了啥，它在处理细长图案时是怎样的？现在看源码还是看不太懂 如果以后技术深入到了这个程度，也有这样的闲情逸致再去研究，再接着更新","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Glide","slug":"Glide","permalink":"https://enderhoshi.github.io/tags/Glide/"}]},{"title":"AS 下载插件 | 使用 Parcelable 接口","slug":"AS 下载插件和 Parcelable 接口","date":"2018-10-08T06:24:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2018/10/08/AS 下载插件和 Parcelable 接口/","link":"","permalink":"https://enderhoshi.github.io/2018/10/08/AS%20%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6%E5%92%8C%20Parcelable%20%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"今天回顾上周的一些开发任务，结合主管审查代码之后提出的一些建议，对代码进行一些整理，看到一条这样的： 12345import com.google.gson.annotations.SerializedNamedata class CurrencReviewEntity( // 可以考虑替换为实现 Parcelable 接口// 新写的实体类，如果不是工具生成，可以直接用 kotlin 写，然后用 Option + T 快捷键自动实现 Parcelable 接口 原来的代码中使用了 SerializedName 注解来对 JSON 数据实体类进行映射，主管给出的建议中要求使用 Parcelable 接口来实现 我打开实体类点了几次 Option + T 没有任何反应，原来是要再下载一个插件 Android Parcelable code generator，遂打开 AS 的 preferences，然后查找插件进行下载： 却弹出了如下错误： 懒得去设置代理地址了，所以直接去 Jetbrains 的插件官网 搜索下载好，然后解压到 AS&#x2F;Contents&#x2F;plugins 目录下 然后再重启 AS，大功告成，我们可以点击实体类名右侧的空白，用快捷键自动补全试试： 代码如下： 123456789101112131415161718192021222324252627282930313233343536@Keepdata class TickerCommentResponse ( @SerializedName(&quot;success&quot;) var success: Boolean, @SerializedName(&quot;error&quot;) var error: String, @SerializedName(&quot;errorCode&quot;) var errorCode: Int, @SerializedName(&quot;data&quot;) var data: TickerCommentBean) : Parcelable &#123; constructor(parcel: Parcel) : this( parcel.readByte() != 0.toByte(), parcel.readString(), parcel.readInt(), TODO(&quot;data&quot;) ) &#123; &#125; override fun writeToParcel(parcel: Parcel, flags: Int) &#123; parcel.writeByte(if (success) 1 else 0) parcel.writeString(error) parcel.writeInt(errorCode) &#125; override fun describeContents(): Int &#123; return 0 &#125; companion object CREATOR : Parcelable.Creator&lt;TickerCommentResponse&gt; &#123; override fun createFromParcel(parcel: Parcel): TickerCommentResponse &#123; return TickerCommentResponse(parcel) &#125; override fun newArray(size: Int): Array&lt;TickerCommentResponse?&gt; &#123; return arrayOfNulls(size) &#125; &#125;&#125; 因为这里的 TickerCommentBean 是另一个实体类，所以我们再把 constructor 处修改好就可以了： 123456constructor(parcel: Parcel) : this( parcel.readByte() != 0.toByte(), parcel.readString(), parcel.readInt(), parcel.readParcelable(TickerCommentBean::class.java.classLoader)) 注意这里的 TickerCommentBean 也需要实现 Parcelable 接口，否则报错 到最后发现原来只是快捷键不一样，其实并不需要下载插件就可以直接自动实现 Parcelable 接口","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"}]},{"title":"Markdown 常用语法","slug":"Markdown 常用语法","date":"2018-09-29T03:33:28.000Z","updated":"2025-07-09T09:33:16.189Z","comments":true,"path":"2018/09/29/Markdown 常用语法/","link":"","permalink":"https://enderhoshi.github.io/2018/09/29/Markdown%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"","text":"我简化并且整理了一些网上文章中的 MarkDown 的常用语法，在我的有道云笔记-&gt;多人协作-&gt;编辑模式下可以看到效果是怎么实现的，因为 hexo 渲染长文时貌似会导致页面空白，而且文章发在博客上看起来也并不好看，所以还是不发在博客上了 原文附在结尾 2016&#x2F;11&#x2F;18 补充内容Markdown 是不支持缩进的 在 Markdown 里按下四个空格，就自动转入 Code 模式 在 Markdown 里一个回车，不是分段而是换行，要两个回车，才是分段 分段和换行的区别是：换行后，上一行和下一行在一个段落里，其视觉表现为，行前距和行后距与一行字太多导致的自然换行是一致的（大约 0.5 个字高 LineHeight） 而段落不同，段落的行前距离和行后距大约是一个字高 这种视觉上的差异自然地让人明白：这是两个不同的段落 技术层，段落是&lt;p&gt;，换行是&lt;br&gt;，两者不同 如果需要增加缩进，可以自己写： 半方大的空白&amp;ensp;或&amp;#8194; 全方大的空白&amp;emsp;或&amp;#8195; 不断行的空白格&amp;nbsp;或&amp;#160; 本段来自 felcon 的 CSDN 博客 ，全文地址请点击：https://blog.csdn.net/felcon/article/details/45333077?utm_source=copy Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) Minimalist Markdown Editor 高级应用 Sublime Text 2 + MarkdownEditing &#x2F; 教程 SegmentFault Markdown 编辑器语法指南 内容已经简化，完整版：http://wowubuntu.com/markdown/index.html#precode(链接已经失效) 简化版：http://wowubuntu.com/markdown/basic.html(链接已经失效) 本文用 Markdown 编写，用作查阅和展示，要查询具体的用法需要查看源文件然后再对比预览","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://enderhoshi.github.io/tags/Markdown/"}]},{"title":"Android Studio for Mac 快捷键汇总","slug":"Android Studio for Mac 快捷键汇总","date":"2018-09-28T13:30:28.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2018/09/28/Android Studio for Mac 快捷键汇总/","link":"","permalink":"https://enderhoshi.github.io/2018/09/28/Android%20Studio%20for%20Mac%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/","excerpt":"","text":"Android Studio 快捷键 Mac 上 Android Studio 常用的快捷键如下，以后遇到新的有助于提高代码效率的操作，将会不断收录在本文，方便以后查阅 功能 Mac OSX Win&#x2F;Linux 自动完成代码 Cmd + Space 智能自动完成代码 Cmd + Shift + Space 完成声明 Cmd + Shift + Enter 查看方法参数方法 Cmd + P 单行注释 Cmd + &#x2F; Ctrl + &#x2F; 多行注释 Cmd + option + &#x2F; Ctrl + Alt + &#x2F; 格式化代码 Cmd + option + L Ctrl + Alt + L 查找 Cmd + F Ctrl + F 替换 Cmd + R Ctrl + R 删除行 Cmd + Delete Ctrl + Y 快捷生成结构体 Cmd + option + T Ctrl + Alt + T 快速定位到类 Cmd + O Ctrl + O 快速定位到符号（变量） Cmd + option + O Ctrl + O 快捷定位到行首&#x2F;尾 Cmd + Left&#x2F;Right Ctrl + Left&#x2F;Right 折叠展开代码块 Cmd + Plus&#x2F;Minus Ctrl + Plus&#x2F;Minus 折叠全部代码块 Cmd + Shift + Plus&#x2F;Minus Ctrl + Shift + Plus&#x2F;Minus 文件结构 Cmd + F12 Ctrl + F12 查找调用位置 Cmd + option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U 剪切行 Cmd + X Ctrl + X 复制行 Cmd + D Ctrl + D 导入包优化，调整导入包位置 Cmd + option + o Ctrl + Alt + o 清除无效包引用 option + Control + O Alt + Ctrl + O 上下移动代码 option + Shift + Up&#x2F;Down Alt + Shift + Up&#x2F;Down 扩大缩小选中范围 option + Up&#x2F;Down Ctrl + W&#x2F;Ctrl + Shift + W 导包，自动修正 option + return Alt + enter Mac中的特殊键 ⌘ : Command () ⌃ : Control ⌥ : Option (alt) ⇧ : Shift ⇪ : Caps Lock 其他特殊操作 Control - Command - 空格键，显示“字符检视器”弹出式窗口 按住某个按键直到出现它的替代字符，可以键入重音字符 保持按下 Shift + Alt 状态，点击工作空间：多光标同步编辑","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Mac","slug":"Mac","permalink":"https://enderhoshi.github.io/tags/Mac/"}]},{"title":"Mac 环境下 Android Studio 无法找到 R 文件 & Mac 修改只读文件","slug":"Mac 环境下 Android Studio 无法找到 R 文件的问题","date":"2018-09-28T13:16:28.000Z","updated":"2025-07-09T09:33:16.188Z","comments":true,"path":"2018/09/28/Mac 环境下 Android Studio 无法找到 R 文件的问题/","link":"","permalink":"https://enderhoshi.github.io/2018/09/28/Mac%20%E7%8E%AF%E5%A2%83%E4%B8%8B%20Android%20Studio%20%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%20R%20%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"前段时间为了更快地编译项目更换了 Mac 系统，搭建好环境后把项目 pull 下来，然后编译运行，发现报错，无法生成R文件，出现 R 类找不到的问题，即使是 clean、rebuild 之后也找不到，当时的报错信息和记录没有保留，所以没有图来展示 因为同事已经迁移环境，所以他们也遇到了这个问题，先顺利解决了，具体原因就是，随着项目的不断开发，R 文件太大，以至于超出了配置大小，所以 R 文件没有被 IDE 正确地生成 class 文件 找到了问题所在，去更改配置就可以了，打开AS目录下的 idea.properties 配置文件，将 idea.max.intellisense.filesize=2500 这个值改大些，如 5000，保存然后重启 AS，发现这时就可以正常找到 R 文件了 另外还有一点小插曲，在对文件进行修改时，我是用 Mac 命令行来对文件进行修改的，提示只读文件不可改动，解决问题的具体操作如下：（my.cnf 为只读文件） 1sudo chmod 755 /etc/my.cnf 然后输入mac锁屏密码（其实就是超级管理密码）回车然后再: 1sudo vim /etc/my.cnf 就可以编辑文件，加上所你需要的内容，这样就可以完成了 参考自：Android Studio R 类找不到（Mac） 参考自：Mac 下面如何修改只读文件 参考自：微信公众号-Android填坑指南","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"Mac","slug":"Mac","permalink":"https://enderhoshi.github.io/tags/Mac/"}]},{"title":"Mac 终端自动补全及常用命令汇总","slug":"Mac 终端自动补全及常用命令汇总","date":"2018-09-08T08:11:28.000Z","updated":"2025-07-09T09:33:16.188Z","comments":true,"path":"2018/09/08/Mac 终端自动补全及常用命令汇总/","link":"","permalink":"https://enderhoshi.github.io/2018/09/08/Mac%20%E7%BB%88%E7%AB%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/","excerpt":"","text":"终端自动补全的配置 首先打开终端，输入 : 1nano .inputrc 然后在文件里面写上： 123set completion-ignore-case onset show-all-if-ambiguous onTAB: menu-complete 最后 ctrl + o ，回车，重启终端，要使用自动补全时按 Tap 键就 ok 了 常用命令 指令 作用 pwd 当前工作目录 cd（不加参数） 进root cd（folder） 进入文件夹 cd .. 上级目录 cd ~ 返回root cd - 返回上一个访问的目录 rm 文件名 删除 cat 文件名(less) 在终端下查看文件 ls 列出目录下所有文件 cp 文件名 目标目录 将文件拷贝到目标目录下 ~代表root 如：~&#x2F;Document&#x2F;CPP2&#x2F; mkdir 新建文件夹 g++ 源文件名 编译源文件，产生a.out .&#x2F;文件名 运行 例如：.&#x2F;a.out &lt; 输入文件名 &gt; 输出文件名 control+d 中断a.out运行 nano 编写脚本语言 ctrl+o存储 nano ….sh 打开 bash ….sh 运行脚本 echo “…$i…” 输出语句 tar -zxf abc.tar.gz tar文件解压 ssh &#x72;&#111;&#111;&#x74;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#49;&#46;&#x32;&#50;&#50; 以root账号远程连接222服务器 unrar x abc.rar rar文件解压，需要安装rar工具 还可能存在错漏或需要补充，将会慢慢完善","categories":[{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://enderhoshi.github.io/tags/Mac/"}]},{"title":"Apk 无法在某款手机上运行解决方案","slug":"Apk 无法在某款手机上运行解决方案","date":"2018-09-08T07:42:37.000Z","updated":"2025-07-09T09:33:16.186Z","comments":true,"path":"2018/09/08/Apk 无法在某款手机上运行解决方案/","link":"","permalink":"https://enderhoshi.github.io/2018/09/08/Apk%20%E6%97%A0%E6%B3%95%E5%9C%A8%E6%9F%90%E6%AC%BE%E6%89%8B%E6%9C%BA%E4%B8%8A%E8%BF%90%E8%A1%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"昨天遇到一个很奇怪的问题，在运行程序时，我的小米手机可以正常跑起来，但是某一台 LG 测试机却提示缺少 WelcomeAcitivity","text":"昨天遇到一个很奇怪的问题，在运行程序时，我的小米手机可以正常跑起来，但是某一台 LG 测试机却提示缺少 WelcomeAcitivity 情况如下图所示： 就连去官网下载正式版的 App 也提示安装包可能已经损坏，所以询问同事，告知有可能是卸载不完全，可以看看是否卸载完全，或者用 adb 去彻底删除它，程序在手机上已经用常规的删除方法卸载了，无法确认是否卸载完全，所以决定动用 adb，使用 adb 的过程如下： 首先确认已经配置好 adb，并且你的 Android 设备可以被你的电脑识别，可以通过输入命令 adb devices 来进行测试是否安装好了 adb，如果没有，则可以通过 Homebrew 安装： 1brew cask install android-platform-tools 如果没有Homebrew，则 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 如果记得包名或者知道包名的话，直接跳到第三步，如果不记得包名或者不知道包名，之所以这样说，是因为对于通过ADB卸载一个应用程序，你必须知道这个应用程序的程序包名称，但是包名称未必是某应用的APK文件名字，比如 Yahoo! Mail（雅虎邮箱）Android 终端应用，它的程序包名称可能是 yahoo.mobile.client.android.mail 所以你可以使用指令 1adb shell pm list packages 来列出所有包名，找到自己的程序的包名 输入指令 1adb uninstall com.example.package 按 Enter 回车键确认，当 Success 提示出现后，应用即从你的 Android 设备中移除，其他以此类推 完成上述步骤后，再次运行程序，成功安装","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"}]},{"title":"Hexo 博客部署指北","slug":"Hexo 博客部署指北","date":"2018-08-30T07:19:35.000Z","updated":"2025-07-09T09:33:16.187Z","comments":true,"path":"2018/08/30/Hexo 博客部署指北/","link":"","permalink":"https://enderhoshi.github.io/2018/08/30/Hexo%20%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8C%97/","excerpt":"今天尝试部署 Hexo 博客，发现确实是十分的简明快捷，以后要多加使用","text":"今天尝试部署 Hexo 博客，发现确实是十分的简明快捷，以后要多加使用 这次的部署过程中遇到了以下几个问题： 1. 无法上传到 Github 部署 Hexo 时，使用教程中说的 repository: 1https://github.com/andybroker/andybroker.github.io.git 无法正确上传，后来用了 1git@github.com:andybroker/andybroker.github.io.git 才正确，应该是直接使用 ssh 进行上传，故没有写账号密码的过程 2. 配置文件时语言选项 中文的选项不是 zh-Hans，而应该是 zh-CN，关于其他的一些语言可以在 themes 中看到，其他的一些配置也可以在 themes 里对应的主题的配置文件 _config.yml 中进行配置，languages 文件夹内容如下所示： 3. Hexo 修改主题 需要把主题先下载下来再进行配置使用 4. Hexo 的配置文件 其中的参数需要在冒号后空一格，不能直接连接冒号 5. 更换电脑时的操作（现在已经使用 Github 进行版本控制，外加使用 Github Action 进行自动发布，所以这个可以忽略了） 安装 Node.js 检查是否安装 brew 1brew -v 安装 homebrew： 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 node：(如果之前已经手动安装过 node，再次通过 homebrew 安装往往产生冲突，可以先删除，如果是通过 homebrew 安装的，下发命令 brew uninstall node 即可，如果是通过安装包安装的，手动删除 node 的安装文件即可) 123brew link nodebrew uninstall nodebrew install node 检查是否安装 node： 12node -vnpm -v 注意：安装 cnpm（npm 由于源服务器在国外，下载 node 包速度较慢，cnpm 使用国内镜像，下载速度较快）： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 hexo: 1npm i -g hexo 把博客文件从 git 上拉下来，或者用 iCloud 中的，基本上只要在 Mac 上更新博客，都可以直接用 iCloud 文稿中的文件，但是如果要更新 git 上的文件，就要先拉到本地，用 iCloud 的将其覆盖，再推到远端 遇到的一些问题Hexo 使用了 Fluid 皮肤后，hexo g 关于高亮报错12TypeError: Cannot set property &#x27;lastIndex&#x27; of undefined at highlight (/home/xxxx/Blog/xxxxx/highlight.js/lib/highlight.js:514:35) 这是因为在你的博客中，在用代码段时没有指明语言，可以把部分文章移出文件夹，逐渐找出是哪一篇的代码段没有指明语言，处理后再移回来 相关链接 Hexo 升级问题最近在整理自己的博客，看到 Hexo 版本是 3.9.0，最新已经去到 6.0.0 了，而我所使用的主题 Fluid 的相关配置在新版本 Hexo 上将会更加方便简洁，所以决定升级一波 按照 Google 得来的升级步骤，先执行如下指令 1npm install -g hexo-cli 运行完毕，再输入 hexo version 查看版本，哦豁，还是 3.9.0，看来应该是只升级了 hexo-cli，并没有正确升级 Hexo，于是再次进行搜索，得到如下的步骤 先安装 npm-check 和 npm-upgrade 1npm install -g npm-check npm-upgrade 安装完后，执行 npm-check 即可检查本地各插件版本情况 执行 npm-upgrade 可根据当前版本和最新版本比较，让用户确认和选择是否升级 若用户确认升级，则会自动把 package-lock.json 和 package.json 文件内容进行更新后保存，然后执行： 1npm update -g --save 上述命令执行完毕，则所有通过 npm-upgrade 确认的插件全部都升级到最新（包括 Hexo） 稍等片刻后，出现了一堆日志，诸如改变了多少个 package 之类的，应该是报告出错了，同时贴心地附上处理的指令 npm audit fix，这时查看一下 Hexo 版本，仍然没有变化，还是 3.9.0，看来的确是出现问题了，那就输入 npm audit fix 试试看，又稍等片刻后通过 hexo version 验证 Hexo 版本，已经更新到最新的 6.0.0 了 如果还遇到另外的问题，可以参考原文，另附查看 Node.js 版本的指令： node -v Node 快速切换版本、版本回退(降级)、版本更新(升级)最近遇到一些 node 的坑，对旧版博客皮肤不太满意，所以更换了现在的 fluid，之后发布的时候报错，一查发现是 node 版本过高了，需要回退到比较稳定的版本，这时可以借助 node 版本管理模块 n 来解决这个问题 12345678910111213141516171819202122# 安装sudo npm install n -g# 下边步骤请根据自己需要选择# 安装稳定版sudo n stable# 安装最新版sudo n latest# 版本降级/升级sudo n 版本号# 检测目前安装了哪些版本的noden# 切换版本（不会删除已经安装的其他版本）n 版本号# 删除版本sudo n rm 版本号 相关链接 不断使用和尝试中，如果有新的坑会继续补充 从零搭建 hexo 参考文章，这个博主也是使用 hexo 的，可以多多参考 Hexo 主题网站","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://enderhoshi.github.io/tags/Hexo/"},{"name":"博客部署","slug":"博客部署","permalink":"https://enderhoshi.github.io/tags/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"}]}],"categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"日常查阅","slug":"日常查阅","permalink":"https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://enderhoshi.github.io/tags/git/"},{"name":"Android","slug":"Android","permalink":"https://enderhoshi.github.io/tags/Android/"},{"name":"版本适配","slug":"版本适配","permalink":"https://enderhoshi.github.io/tags/%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"},{"name":"ADB","slug":"ADB","permalink":"https://enderhoshi.github.io/tags/ADB/"},{"name":"WebView","slug":"WebView","permalink":"https://enderhoshi.github.io/tags/WebView/"},{"name":"应用签名","slug":"应用签名","permalink":"https://enderhoshi.github.io/tags/%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/"},{"name":"UI","slug":"UI","permalink":"https://enderhoshi.github.io/tags/UI/"},{"name":"Java","slug":"Java","permalink":"https://enderhoshi.github.io/tags/Java/"},{"name":"序列化","slug":"序列化","permalink":"https://enderhoshi.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://enderhoshi.github.io/tags/Kotlin/"},{"name":"Gradle","slug":"Gradle","permalink":"https://enderhoshi.github.io/tags/Gradle/"},{"name":"依赖管理","slug":"依赖管理","permalink":"https://enderhoshi.github.io/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://enderhoshi.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"Fragment","slug":"Fragment","permalink":"https://enderhoshi.github.io/tags/Fragment/"},{"name":"TextView","slug":"TextView","permalink":"https://enderhoshi.github.io/tags/TextView/"},{"name":"EditText","slug":"EditText","permalink":"https://enderhoshi.github.io/tags/EditText/"},{"name":"OkHttp","slug":"OkHttp","permalink":"https://enderhoshi.github.io/tags/OkHttp/"},{"name":"快应用","slug":"快应用","permalink":"https://enderhoshi.github.io/tags/%E5%BF%AB%E5%BA%94%E7%94%A8/"},{"name":"手机","slug":"手机","permalink":"https://enderhoshi.github.io/tags/%E6%89%8B%E6%9C%BA/"},{"name":"Nexus 6p","slug":"Nexus-6p","permalink":"https://enderhoshi.github.io/tags/Nexus-6p/"},{"name":"博客部署","slug":"博客部署","permalink":"https://enderhoshi.github.io/tags/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"},{"name":"RSS","slug":"RSS","permalink":"https://enderhoshi.github.io/tags/RSS/"},{"name":"Mac","slug":"Mac","permalink":"https://enderhoshi.github.io/tags/Mac/"},{"name":"View","slug":"View","permalink":"https://enderhoshi.github.io/tags/View/"},{"name":"Glide","slug":"Glide","permalink":"https://enderhoshi.github.io/tags/Glide/"},{"name":"Markdown","slug":"Markdown","permalink":"https://enderhoshi.github.io/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","permalink":"https://enderhoshi.github.io/tags/Hexo/"}]}