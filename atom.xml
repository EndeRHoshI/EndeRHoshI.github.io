<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HoshI-blog</title>
  
  
  <link href="https://enderhoshi.github.io/atom.xml" rel="self"/>
  
  <link href="https://enderhoshi.github.io/"/>
  <updated>2025-07-09T09:33:16.189Z</updated>
  <id>https://enderhoshi.github.io/</id>
  
  <author>
    <name>HoshIlIlI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git merge 后产生重复提交的原因</title>
    <link href="https://enderhoshi.github.io/2025/07/09/git%20merge%20%E5%90%8E%E4%BA%A7%E7%94%9F%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>https://enderhoshi.github.io/2025/07/09/git%20merge%20%E5%90%8E%E4%BA%A7%E7%94%9F%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2025-07-09T07:52:33.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天同事打算对散乱的分支进行合并，处理完成后，我 fetch 之后看了一下，发现 git 分支图上，产生了重复的提交，而且作者栏里面，我的名称后多了一个星号</p><p>这种情况之前也发生过，我有时候合并完也会出现这样的情形，这对功能并没有多大影响，但是让分支图显得不太好看。另外如果后续有回退代码的需求时，存在内容、作者都相同的两个提交，也需要我们对其进行甄别，到底回退到哪个才是正确的，因为它们虽然内容相同，但是它们的前后提交有可能是不同的</p><h2 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h2><p>经过一些排查，还是没搞清楚为什么会出现这种情况，比较接近的答案是：上游分支和本地分支有冲突，或者存在提交历史的不同，可能会出现将提交历史重新应用到上游分支的过程中，会将本地分支的每个提交都应用一次</p><h2 id="出现如何处理"><a href="#出现如何处理" class="headerlink" title="出现如何处理"></a>出现如何处理</h2><p>最好配合 git reflog 以及 git reset 进行重置，然后看看哪里出了问题，灵活运用 git rebase，不要一味 merge</p><h2 id="如何避免下次出现"><a href="#如何避免下次出现" class="headerlink" title="如何避免下次出现"></a>如何避免下次出现</h2><p>一般正常使用不会出现，需要再研究下出现条件再避免，平时使用时要注意下面几点：</p><ol><li>不要直接将 develop 分支合并到 develop 的子分支上</li><li>要根据实际情况，利用好 git rebase</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天同事打算对散乱的分支进行合并，处理完成后，我 fetch 之后看了一下，发现 git 分支图上，产生了重复的提交，而且作者栏里面，我的名称后多了一个星号&lt;/p&gt;
&lt;p&gt;这种情况之前也发生过，我有时候合并完也会出现这样的情形，这对功能并没有多大影响，但是让分支图显得不太好</summary>
      
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="git" scheme="https://enderhoshi.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Android 15 适配</title>
    <link href="https://enderhoshi.github.io/2025/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Android%2015%20%E9%80%82%E9%85%8D/"/>
    <id>https://enderhoshi.github.io/2025/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Android%2015%20%E9%80%82%E9%85%8D/</id>
    <published>2025-03-13T08:38:33.000Z</published>
    <updated>2025-07-09T09:33:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>公司有个项目一直没有维护，Google Play 上收到用户投诉，提示目标版本过低，无法安装，于是需要进行一次适配，这里详尽记录一下经过</p><p>很多年前写过一篇 Android 9、10 的适配记录，但是过于凌乱，那时候基础也差，基本是搜到什么就粘贴进项目里，能跑起来就完事了（其实现在也差不多）。后面有一些开发笔记用于记录适配相关的事项，但是好像又比较零散，想着还是以记录完整经过的模式来写，写时候比较舒服，读起来也更通顺</p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">targetSdkVersion</span> = <span class="hljs-number">31</span><br><span class="hljs-attribute">AGP</span> Version = <span class="hljs-number">7</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Gradle</span> Version = <span class="hljs-number">7</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Kotlin</span> Version = <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h2 id="提升相关版本"><a href="#提升相关版本" class="headerlink" title="提升相关版本"></a>提升相关版本</h2><p>最基础的一步是提升 targetSdkVersion，然后直接运行，发现报错提示还需要提升 AGP 版本，这里提升到 8.7.3</p><p>这个 AGP 版本指的是 Android Gradle 插件版本（Android Gradle Plugin），该插件版本适用于在相应 Android Studio 项目中构建的所有模块，可以在以下几个地方指定：</p><ol><li>Android Studio 的 File &gt; Project Structure &gt; Project 菜单中指定插件版本 <img src="/../img/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Android%2015%20%E9%80%82%E9%85%8D/AGP_Version_in_file.png"></li><li>在顶级 build.gradle.kts 文件中指定 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">plugins &#123;<br>    id(<span class="hljs-string">&quot;com.android.application&quot;</span>) version <span class="hljs-string">&quot;8.7.3&quot;</span> apply <span class="hljs-keyword">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用 build.gradle 的话，指的是 classpath ‘com.android.tools.build:gradle:8.7.3’ 这个 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">dependencies</span> &#123;<br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.android.tools.build:gradle:8.7.3&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>提升 AGP 版本后，对应的，Gradle 版本要提升到 8.9，JDK 需要升级至 17 以上</p><p>后续因为 reverse() 方法的问题，提升了 Kotlin 版本到 1.9.22，又因为在 Kotlin 版本大于 1.7 时，Room 库 2.4.3 以下版本下无法识别挂起函数，编译报错，再把 Room 库提升到最新版本 2.6.1 后，又报如下问题</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">D</span>:\WorkSpace\cpp<span class="hljs-number">-0914</span>\common\build\tmp\kapt3\stubs\domesticDebug\com\ddpai\common\database\dao\VVideoDao.<span class="hljs-name">java</span>:<span class="hljs-number">16</span>: 错误: Methods annotated with [@Insert, @Upsert, @Update, @Delete] shouldn<span class="hljs-string">&#x27;t declare nullable parameters (com.ddpai.common.database.entities.VVideo[]).</span><br><span class="hljs-string">    com.ddpai.common.database.entities.VVideo[] item, @org.jetbrains.annotations.NotNull()</span><br></code></pre></td></tr></table></figure><p>意思是这几个注解下不能用可空的类型，需要改成非空类型，好办，改完再运行下，无问题了</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/Ever69/article/details/130750021">解决 Kotlin 升级 1.7 以上版本时 Room 库报错的问题</a></li></ul><h2 id="模块级别的-build-gradle-改动"><a href="#模块级别的-build-gradle-改动" class="headerlink" title="模块级别的 build.gradle 改动"></a>模块级别的 build.gradle 改动</h2><p>这里的 build.gradle 指的是除了顶级 build.gradle 之外的 build.gradle，需要做以下改动</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>每个模块下的 build.gradle 都需要声明一个 namespace（下列代码举例子为了方便所以写到一起了，事实是分开的），新建项目会自带</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">android &#123;<br>    namespace = <span class="hljs-string">&quot;com.hoshi.test&quot;</span> <span class="hljs-comment">// 这个是 test 模块</span><br>&#125;<br>android &#123;<br>    namespace = <span class="hljs-string">&quot;com.hoshi.common&quot;</span> <span class="hljs-comment">// 这个是 common 模块</span><br>&#125;<br>android &#123;<br>    namespace = <span class="hljs-string">&quot;com.hoshi.platform&quot;</span> <span class="hljs-comment">// 这个是 platform 模块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个东东是干嘛的呢？为什么另一个项目不需要？待研究后补充，现在已知的是新增了这个之后，会导致你以前的 R 文件引用产生变化</p><p>以前假设你在 test 模块下写代码，test 模块引用 common 模块，你只 <code>import com.hoshi.test.R</code>，就既可以使用 test 模块的资源，又可以使用 common 模块的资源</p><p>但是现在不一样了，你 <code>import com.hoshi.test.R</code> 只能使用 test 模块的资源，如果你想用 common 的资源，你就需要在资源文件前加上完整包名，如 <code>context.getString(com.hoshi.common.R.string.common_today)</code></p><p>增加了 namespace 后，AndroidManifest 里面的 <code>package=&quot;com.hoshi.test&quot;</code> 就可以删掉了</p><h3 id="zipAlignEnabled"><a href="#zipAlignEnabled" class="headerlink" title="zipAlignEnabled"></a>zipAlignEnabled</h3><p>zipAlignEnabled 废弃，不再需要声明，删掉代码即可，直接是自动默认为开的</p><h3 id="buildConfig"><a href="#buildConfig" class="headerlink" title="buildConfig"></a>buildConfig</h3><p>新版本 AGP，默认关闭 buildConfig，会导致你的 BuildConfig.xxxxx 全部出现异常，需要作如下配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">android &#123;<br>    buildFeatures &#123;<br>        buildConfig = <span class="hljs-keyword">true</span> <span class="hljs-comment">// 配置开启 buildConfig 构建特性，新版本 AGP 需要配置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他写法调整"><a href="#其他写法调整" class="headerlink" title="其他写法调整"></a>其他写法调整</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">flavorDimensions <span class="hljs-string">&#x27;isOverseas&#x27;</span><br><br><span class="hljs-comment">// flavor 配置的写法调整，上面是旧版的，改为下面这样</span><br>flavorDimensions = [<span class="hljs-string">&quot;isOverseas&quot;</span>]<br></code></pre></td></tr></table></figure><p>这种调整经常会有，如果遇到可以往类似方向调整，或者直接搜一下如何解决</p><h2 id="存储权限适配"><a href="#存储权限适配" class="headerlink" title="存储权限适配"></a>存储权限适配</h2><p>targetSdkVersion 大于等于 33，并且运行在 Android 13 的手机上时，通过代码判断是否拥有 READ_EXTERNAL_STORAGE 权限，一定返回 false</p><p>XXPermissions 库不再允许申请 READ_EXTERNAL_STORAGE 权限（会直接闪退并告知原因是申请 READ_EXTERNAL_STORAGE），而 ActivityResultLauncher 库中，取图片、视频的 PickContentLauncher 会判断是否拥有 READ_EXTERNAL_STORAGE 权限，所以需要做一下适配</p><p>首先彻底移除自己项目中所有的 READ_EXTERNAL_STORAGE，使用 READ_MEDIA_IMAGES、READ_MEDIA_VIDEO、READ_MEDIA_AUDIO 替代，然后把 PickContentLauncher 单独取出来，进行如下修改</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">// 当当前手机版本为 Android 13，并且 targetSdkVersion 为 33 时</span><br><span class="hljs-comment">// 根据文件类型分别取得 READ_MEDIA_IMAGES 和 READ_MEDIA_VIDEO</span><br><span class="hljs-comment">// 低版本下一律取 READ_EXTERNAL_STORAGE</span><br><span class="hljs-keyword">val</span> applicationInfo = AppState.getApplicationContext().applicationInfo<br><span class="hljs-keyword">val</span> permissionStr = <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU <br>    &amp;&amp; applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.TIRAMISU<br>) &#123;<br>    <span class="hljs-keyword">if</span> (input == <span class="hljs-string">&quot;image/*&quot;</span>) &#123;<br>        Manifest.permission.READ_MEDIA_IMAGES<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Manifest.permission.READ_MEDIA_VIDEO<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    Manifest.permission.READ_EXTERNAL_STORAGE<br>&#125;<br></code></pre></td></tr></table></figure><p>最后找一下用到原 PickContentLauncher 类的地方，将其替换成自己魔改过的 PickContentLauncher 类</p><h2 id="MQTT-相关调整"><a href="#MQTT-相关调整" class="headerlink" title="MQTT 相关调整"></a>MQTT 相关调整</h2><p>因为以下众多原因，需要对 MQTT 库进行一些魔改</p><ol><li>SCHEDULE_EXACT_ALARM 权限需要和 Google 官方说明申请原因，还要拍摄录像告知使用场景，最好移除掉</li><li>前台 service 需要声明 android:foregroundServiceType</li><li>动态广播接收器必须指定导出的行为，也就是 registerReceiver 方法要加一个 flag 说明是 RECEIVER_EXPORTED 还是 RECEIVER_NOT_EXPORTED</li></ol><p>Github 上有挺多方案，甚至还有 Kotlin 版本的，现在追求改动最小，所以沿用了<a href="https://github.com/mayzs/paho.mqtt.android">这个</a>方案。这个方案将之前官方 MQTT 用到的 AlarmManager 直接用 Worker 替换掉，且也做了 2、3 两点的适配，十分符合此次适配的需求</p><h2 id="隐式-Intent-和-PendingIntent-的限制"><a href="#隐式-Intent-和-PendingIntent-的限制" class="headerlink" title="隐式 Intent 和 PendingIntent 的限制"></a>隐式 Intent 和 PendingIntent 的限制</h2><p>官方的说法是，要启动非导出活动，应用程序应使用显式意图，具体可以直接看我之前写过的文章中的某段 —— <a href="https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/#No-3-Android-14-%E9%80%82%E9%85%8D-Intent-%E7%9B%B8%E5%85%B3">Android 14 适配 Intent 相关</a></p><p>这个不难，如果自己写有统一的跳转方法的话，直接给 intent 加上 packageName 即可，这里需要特别注意的就是，第三方库里面的跳转如果没有加上 packageName 就会导致闪退，我这里又是 ActivityResultLauncher 库里面的跳转导致的，只能说开源不易，不能怪人，自己发现后及时修改即可</p><h2 id="Edge-to-Edge-适配，沉浸式的新方案"><a href="#Edge-to-Edge-适配，沉浸式的新方案" class="headerlink" title="Edge to Edge 适配，沉浸式的新方案"></a>Edge to Edge 适配，沉浸式的新方案</h2><p>之前一直用 ImmersionBar 库来做沉浸式，提升到 Android 15 后，发现在某些页面中，状态栏和应用顶部的控件又重叠了，好家伙全都白搞了，又要一轮全新的适配。虽然官方告知可以在 theme 中声明 <code>&lt;item name=&quot;android:windowOptOutEdgeToEdgeEnforcement&quot;&gt;true&lt;/item&gt;</code> 来暂时规避，但是 Android 16 明确说了会废弃并停用这个选项，躲得了初一躲不过十五，还是乖乖适配好了</p><p>首先把 ImmersiveBar 相关的解决布局与状态栏重叠问题的代码（比如 <code>ImmersionBar.fitsSystemWindows()</code> 这些）移除掉，避免重复处理，然后写相关的 View 扩展代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Android 15 Edge to Edge 适配</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@receiver</span> View</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">statusPaddingEdge</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> layoutParams = <span class="hljs-keyword">this</span>.layoutParams <span class="hljs-comment">// 首先取得 LayoutParams</span><br>    <span class="hljs-keyword">var</span> oldHeight = layoutParams.height <span class="hljs-comment">// 然后先用 LayoutParams 取得控件的高</span><br>    <span class="hljs-keyword">var</span> isMatchParent = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> (oldHeight == ViewGroup.LayoutParams.MATCH_PARENT) &#123;<br>        isMatchParent = <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldHeight == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;<br>        <span class="hljs-comment">// 如果是 MATCH_PARENT 或者 WRAP_CONTENT，要再测量取实际高度</span><br>        <span class="hljs-keyword">val</span> width = View.MeasureSpec.makeMeasureSpec(<span class="hljs-number">0</span>, View.MeasureSpec.UNSPECIFIED)<br>        <span class="hljs-keyword">val</span> height = View.MeasureSpec.makeMeasureSpec(<span class="hljs-number">0</span>, View.MeasureSpec.UNSPECIFIED)<br>        <span class="hljs-keyword">this</span>.measure(width, height)<br><br>        oldHeight = <span class="hljs-keyword">this</span>.measuredHeight <span class="hljs-comment">// 然后先在外部取得控件的高，放在监听里面可能会多次回调导致高度累加，显示异常</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (oldHeight &lt;= <span class="hljs-number">0</span> &amp;&amp; (oldHeight != ViewGroup.LayoutParams.MATCH_PARENT)) &#123;<br>        VLog.e(<span class="hljs-string">&quot;statusPaddingEdge&quot;</span>, <span class="hljs-string">&quot;取得控件的高小于 0，且不是 MATCH_PARENT，不正确，请检查，对应控件：&quot;</span> + <span class="hljs-keyword">this</span>.javaClass.name)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) &#123; v, insets -&gt;<br>        <span class="hljs-keyword">val</span> statusBars = insets.getInsets(WindowInsetsCompat.Type.statusBars())<br>        <span class="hljs-keyword">val</span> statusBarsTop = statusBars.top<br>        <span class="hljs-keyword">if</span> (!isMatchParent) &#123;<br>            layoutParams.height = oldHeight + statusBarsTop <span class="hljs-comment">// 如果不是 MATCH_PARENT，整个 View 要增高</span><br>        &#125;<br>        v.layoutParams = layoutParams<br>        v.setPadding(statusBars.left, statusBarsTop, statusBars.right, statusBars.bottom)<br>        <span class="hljs-comment">// VLog.e(&quot;statusPaddingEdge&quot;, &quot;statusBars = $statusBars, oldHeight = $oldHeight&quot;)</span><br>        insets<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在实际使用过程中，有一些界面/控件不会触发 setOnApplyWindowInsetsListener 里面的 OnApplyWindowInsetsListener，这时候就用下面这个老方法来处理</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加 View 的上内边距, 增加高度为状态栏高度, 防止视图和状态栏重叠</span><br><span class="hljs-comment"> * 如果是 RelativeLayout 设置 padding 值会导致 centerInParent 等属性无法正常显示</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * !----注意----! 这个方法在某些手机（目前发现荣耀 magic3）的横屏界面上会出问题，表现为顶部多出一段间距</span><br><span class="hljs-comment"> * 可以尝试采用其它沉浸式方法处理，如 statusPaddingEdge、ImmersionBar</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> remove true: paddingTop = 状态栏高度</span><br><span class="hljs-comment"> *               false: paddingTop = 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@JvmOverloads</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">statusPadding</span><span class="hljs-params">(remove: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> RelativeLayout) &#123;<br>        <span class="hljs-keyword">throw</span> UnsupportedOperationException(<span class="hljs-string">&quot;Unsupported set statusPadding for RelativeLayout&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> statusBarHeight = context.statusBarHeight<br>    <span class="hljs-keyword">val</span> lp = layoutParams<br>    <span class="hljs-keyword">if</span> (remove) &#123;<br>        <span class="hljs-keyword">if</span> (paddingTop &lt; statusBarHeight) <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (lp != <span class="hljs-literal">null</span> &amp;&amp; lp.height &gt; <span class="hljs-number">0</span>) &#123;<br>            lp.height -= statusBarHeight <span class="hljs-comment">// 减高</span><br>        &#125;<br>        setPadding(<br>            paddingLeft, paddingTop - statusBarHeight,<br>            paddingRight, paddingBottom<br>        )<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (paddingTop &gt;= statusBarHeight) <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (lp != <span class="hljs-literal">null</span> &amp;&amp; lp.height &gt; <span class="hljs-number">0</span>) &#123;<br>            lp.height += statusBarHeight <span class="hljs-comment">// 增高</span><br>        &#125;<br>        setPadding(<br>            paddingLeft, paddingTop + statusBarHeight,<br>            paddingRight, paddingBottom<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在状态栏和控件重叠的页面，让重叠的控件调用上面代码即可</p><h3 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/guolin_blog/article/details/141500877">Android 15 新特性，强制 edge-to-edge 全面屏体验</a></li><li><a href="https://developer.android.com/about/versions/16/behavior-changes-16?hl=zh-cn#edge-to-edge">无边框设计停用退出选项</a></li></ul><h2 id="Collection-reversed-扩展方法闪退问题"><a href="#Collection-reversed-扩展方法闪退问题" class="headerlink" title="_Collection.reversed() 扩展方法闪退问题"></a>_Collection.reversed() 扩展方法闪退问题</h2><p>报错如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">java.lang.NoSuchMethodError: No <span class="hljs-keyword">interface</span> <span class="hljs-keyword">method</span> <span class="hljs-title function_">reversed</span><span class="hljs-params">()</span><span class="hljs-title function_">Ljava</span>/<span class="hljs-title function_">util</span>/<span class="hljs-title function_">List</span>; <span class="hljs-keyword">in</span> <span class="hljs-keyword">class</span> Ljava/util/List<span class="hljs-punctuation">;</span> <span class="hljs-keyword">or</span> its super classes (declaration <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;java.util.List&#x27;</span> appears <span class="hljs-keyword">in</span> /apex/com.android.runtime/javalib/core-oj.jar)<br></code></pre></td></tr></table></figure><p>这里报错的是集合类的扩展方法 reversed()，以前用得好好的，突然就不行了，感觉可能也和 APG 版本、JDK 版本有关。我这里直接替换为 asReversed() 即可，下面说下它们之间有什么不同</p><p>简单概括就是：两个类都会返回一个 List，改变 list.reversed() 返回的 List 中的元素，不会影响到原 List，而改变 list.asReversed() 返回的 List 中的元素，会影响到原 List </p><p>后来想到还是要看看为什么突然就不行了，留意到我的 Kotlin 版本是 1.6.21，看了下扩展方法里面的具体实现，处于位置 kotlin-stdlib-common-1.6.21-sources.jar!\generated_Collections.kt，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">expect</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> MutableList<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><p>这里的这个 expect 关键字是用于跨平台的，这里用 expect 声明了方法之后，其他平台再使用对应的 actual 关键字实现对应的方法，每个目标平台（如 JVM、JS、Native 等）都可以有自己的 actual 实现</p><p>那么可以猜测，应该是提升了 JDK 版本为 17 后，对应的 Native 实现没有实现到这个方法了，所以导致报错，于是升级 Kotlin 版本试试，发现升级后，reverse 扩展方法位置变了，在 _CollectionsJVM.kt 里面，且代码变为如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> MutableList<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    java.util.Collections.reverse(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来是个 actual 方法，有实现了，应该可行了，编译运行，执行相关的方法，没有报错了</p><h3 id="参考文章-2"><a href="#参考文章-2" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/github_27263697/article/details/145594156">Kotlin 中 expect 和 actual 关键字修饰的函数作用</a></li><li><a href="https://stackoverflow.com/a/57115894/16861528">asReversed() vs reversed() in Kotlin?</a></li></ul><h2 id="R8-混淆相关"><a href="#R8-混淆相关" class="headerlink" title="R8 混淆相关"></a>R8 混淆相关</h2><p>上面的步骤都处理完了，提交代码，进行远程打包，直接报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">app:minifyReleaseWithR8 FAILED<br><br>Missing classes detected <span class="hljs-keyword">while</span> running R8. Please add the missing classes or apply additional keep rules that are generated <span class="hljs-keyword">in</span> D:\WorkSpace\myApp\app\build\outputs\mapping\domesticRelease\missing_rules.txt.<br></code></pre></td></tr></table></figure><p>打开提示中的对应目录，有如下内容，说明我们缺少了这些，需要加上。这里的 -dontwarn 是关闭警告的意思，为什么需要加上这些，具体原理不明，估计是 JDK 版本提升后，R8 的一些相关配置改变了</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">-dontwarn com.google.android.exoplayer2.decoder.OutputBuffer$Owner<br>-dontwarn com.google.android.exoplayer2.decoder.OutputBuffer<br>-dontwarn com.google.android.exoplayer2.decoder.SimpleOutputBuffer<br>-dontwarn com.google.android.exoplayer2.drm.ExoMediaCrypto<br></code></pre></td></tr></table></figure><p>复制粘贴到 proguard-rules.pro 中，再上传打包，这次没问题了，打包 apk 成功，但是安装好后一运行就闪退了，好好好，再看闪退日志</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassCastException</span>: com<span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.LinkedTreeMap</span> cannot be cast Student<br><span class="hljs-comment">// 另外还有一些关于 ParameterizedType 的问题，这里没有记录到就不贴了，大致是说取不到具体泛型类型，只能取到一个 Class 之类的</span><br><span class="hljs-comment">// 因为我这个项目的 ViewBinding 是用反射的方式来处理的，所以还有一些 ViewBinding 工具无法取到泛型产生的报错</span><br></code></pre></td></tr></table></figure><p>搜索资料得知，如果使用了 R8 混淆，JDK 17 默认会开启 R8 fullMode 混淆模式，完整模式下，对于没有 keep 的类，将会擦除泛型信息。而我的项目中 ViewBinding 是用反射的方式在基类中处理的，并且使用了类似于 BaseResponse&lt;T&gt; 的类，有自定义解析器，所以精准踩中了这个雷。一个个去手动配置混淆豁免规则过于麻烦，所以选择直接手动关闭完整模式，在 gradle.properties 文件中添加以下代码即可</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">android.enableR8.fullMode=<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h3 id="参考文章-3"><a href="#参考文章-3" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://github.com/liujingxing/rxhttp/issues/471">R8 full mode 完整模式兼容问题</a></li><li><a href="https://juejin.cn/post/7155483761197449223">使用 ViewBinding 混淆后 APP 炸了？</a></li><li><a href="https://blog.csdn.net/qq_36652498/article/details/107457231">使用 gson，出现 LinkedTreeMap cannot be cast to xxx</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，这次的 Android 15 告一段落了。不得不说 Android 的适配每次都能给你来点新花样，每次有新版本时，及时对 APP 进行适配，能够减轻将来再有新版本时适配的工作量，同时也能更快利用上一些新版本 <del>Bug</del> 特性，还是值得重视的</p>]]></content>
    
    
    <summary type="html">记录一次将 targetSdkVersion 从 31 提升到 35 的过程</summary>
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="版本适配" scheme="https://enderhoshi.github.io/tags/%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>ADB 漫游指南</title>
    <link href="https://enderhoshi.github.io/2025/02/25/ADB%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/"/>
    <id>https://enderhoshi.github.io/2025/02/25/ADB%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/</id>
    <published>2025-02-25T02:25:11.000Z</published>
    <updated>2025-07-09T09:33:16.186Z</updated>
    
    <content type="html"><![CDATA[<p>作为 Android 开发，经常要使用到 ADB，但是始终没有系统规范地全面学习过，导致使用过程中经常会记不起命令，感到卡壳；有时看到别人的巧妙用法，又会感叹 “居然还能这么用”。故作此指南，供需要时翻阅</p><h2 id="awesome-adb"><a href="#awesome-adb" class="headerlink" title="awesome-adb"></a>awesome-adb</h2><p>点击<a href="https://github.com/mzlogin/awesome-adb">这里</a>跳转项目，这是一个比较知名的用法大全库，有需要的可以 fork 到自己的仓库中保存，当需要 ADB 指令又记不起时，可以优先从这里找</p><h2 id="ADB-打包-tar"><a href="#ADB-打包-tar" class="headerlink" title="ADB 打包 tar"></a>ADB 打包 tar</h2><p>有时候我们需要把一些文件打包拉取，一是为了方便统一分享；二是有时候文件中含有一些 windows 非法字符（比如冒号这些），无法直接 pull，需要打包后再 pull</p><p>这时就可以使用指令 <code>adb exec-out tar chf - -C /data/data/xxx . &gt; aaa.tar</code>，注意这里的 tar 只是打包，没有压缩</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="将-adb-封装成-bat-文件"><a href="#将-adb-封装成-bat-文件" class="headerlink" title="将 adb 封装成 .bat 文件"></a>将 adb 封装成 .bat 文件</h3><p>可以将 adb 指令写入到 .bat 文件内，举个例子，下面是一个将当前屏幕分辨率设置为 1440 x 1920 的 .bat 的代码</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bat">adb shell wm size <span class="hljs-number">1440</span>x1920<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>封装后就可以双击直接一键运行了<br><img src="/../img/blog/ADB%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E5%B8%B8%E7%94%A8%20ADB.png" alt="常用 ADB"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为 Android 开发，经常要使用到 ADB，但是始终没有系统规范地全面学习过，导致使用过程中经常会记不起命令，感到卡壳；有时看到别人的巧妙用法，又会感叹 “居然还能这么用”。故作此指南，供需要时翻阅&lt;/p&gt;
&lt;h2 id=&quot;awesome-adb&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="日常查阅" scheme="https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"/>
    
    
    <category term="ADB" scheme="https://enderhoshi.github.io/tags/ADB/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-WebView</title>
    <link href="https://enderhoshi.github.io/2025/02/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-WebView/"/>
    <id>https://enderhoshi.github.io/2025/02/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-WebView/</id>
    <published>2025-02-13T08:17:56.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-网页中无法弹出选择框"><a href="#No-1-网页中无法弹出选择框" class="headerlink" title="No.1 网页中无法弹出选择框"></a>No.1 网页中无法弹出选择框</h2><p>网页内有一个按钮，正常情况下点击后会弹出地区选择弹窗，开发时发现在应用内 WebView 中无法弹出，在手机浏览器或 PC 浏览器内均正常，搜索后发现是因为 WebView 初始化时，context 参数传了 Application。看了一下网上的分析，初步估计应该是弹出地区选择弹窗时，用的是原生 Dialog，而 Application 不能作为 Dialog 的 context。所以把 WebView 的初始化参数改为当前 Activity，就解决了问题</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.cn/post/7314125877486616615">一文洞彻：Application 为啥不能作为 Dialog 的 context？</a></li><li><a href="https://guangxingmao.github.io/2017/07/24/webview%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BAselect%E9%80%89%E6%8B%A9%E6%A1%86/">webview 无法弹出 select 选择框</a></li></ul>]]></content>
    
    
    <summary type="html">WebView 使用笔记</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="WebView" scheme="https://enderhoshi.github.io/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-应用签名</title>
    <link href="https://enderhoshi.github.io/2025/01/17/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/"/>
    <id>https://enderhoshi.github.io/2025/01/17/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/</id>
    <published>2025-01-17T04:18:56.000Z</published>
    <updated>2025-07-09T09:33:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-一些细碎的问题"><a href="#No-1-一些细碎的问题" class="headerlink" title="No.1 一些细碎的问题"></a>No.1 一些细碎的问题</h2><ol><li>build.gradle 里面的 signingConfigs 里的 keyAlias 要与你新建 Key Store 时填写的 Alias 保持一致，否则会报错：No key with alias ‘xxxx’ found in keystore E:\workspace\xxxx\xxxx，如果不小心忘记了，可以用指令：<code>keytool -changealias -keystore test.keystore -alias key_name -destalias new_key_name</code> 来处理，参考文章：<a href="https://blog.csdn.net/jack22001/article/details/85319308">修改 alias 方法</a></li><li>发现未签名的 apk 打包出来后，文件名里面带有 unsigned，签了名的就没有了，这个应该是可以配置的</li><li>生成签名文件和查看签名文件 <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">如何生成 .keystore<br>keytool -genkey -v -keystore myApp.keystore -alias myApp.keystore -keyalg RSA -validity 30000<br><br>如何查看 .keystore<br>keytool -list -v -keystore keystore文件路径 -storepass keystore密码<br></code></pre></td></tr></table></figure></li></ol><h2 id="No-2-关于系统签名"><a href="#No-2-关于系统签名" class="headerlink" title="No.2 关于系统签名"></a>No.2 关于系统签名</h2><p>近来接触了一下车机项目，因为需要系统级权限，探索了一下系统签名，这里简单记录一下，后续如果还有进行更多关于系统签名的学习的话，可以再继续完善</p><p>首先我们手上的是一个普通 apk，能够直接 adb install 到手机、车机等 Android 设备上，这时候我们想要打包一个系统级别的 apk，我做了如下步骤：</p><ol><li>AndroidManifest.xml 里面 Application 层级声明了 <code>android:sharedUserId=&quot;android.uid.system&quot;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.hoshi.test&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:sharedUserId</span>=<span class="hljs-string">&quot;android.uid.system&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:versionCode</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:versionName</span>=<span class="hljs-string">&quot;1.0.0&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>然后将客户提供的 platform.jks 文件放到项目根目录下</li><li>修改 build.gradle 里面的 signingConfigs <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle">signingConfigs &#123;<br>    systemKey &#123;<br>        keyAlias <span class="hljs-string">&quot;e02&quot;</span><br>        keyPassword <span class="hljs-string">&quot;123456&quot;</span><br>        storeFile <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../platform.jks&quot;</span>)<br>        storePassword <span class="hljs-string">&quot;123456&quot;</span><br>    &#125;<br>    ...<br>&#125;<br>buildTypes &#123;<br>    release &#123;<br>        minifyEnabled <span class="hljs-keyword">true</span><br>        shrinkResources <span class="hljs-keyword">true</span><br>        proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-project.txt&#x27;</span><br><br>        signingConfig signingConfigs.systemKey<br>    &#125;<br>    debug &#123;<br>        minifyEnabled <span class="hljs-keyword">false</span><br>        signingConfig signingConfigs.debugkey<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>然后把代码提交，Jenkins 进行打包，得到 apk</li><li>使用 <code>keytool -list -v -keystore</code> 指令查看 jks 的 SHA1 码，然后把 apk 上传到客户的应用市场</li></ol><p>上面步骤走完，整个处理就结束了，大体流程非常简单，但是里面的细节可以讲很多，下面稍微展开讲讲</p><h3 id="第-1-步"><a href="#第-1-步" class="headerlink" title="第 1 步"></a>第 1 步</h3><p>我们声明了一个 <code>android:sharedUserId=&quot;android.uid.system&quot;</code>，声明之后，就无法通过 AS 直接运行我们的 apk 了，如果要本地运行，调试应用，还需要把这个注释掉</p><p>默认情况下，Android 会为每个应用分配其唯一用户 ID。如果两个或多个应用将此属性设置为相同的值，则这些应用都将共享相同的 ID，前提是这些应用的签名完全相同。具有相同用户 ID 的应用可以访问彼此的数据，如果需要的话，还可以在同一进程中运行。所以我们设置了这个 sharedUserId 后，又签了同一个应用的签名，除了都获得了系统级权限之外，彼此之间应该也都可以共享数据了</p><p>要注意，android:sharedUserId 在 Android 29 上已经被弃用了，所以高版本还需要找下替代，同时，由于现有应用无法移除此值，这类应用应添加 <code>android:sharedUserMaxSdkVersion=&quot;32&quot;</code> ，以免在新用户安装时使用共享用户 ID。因为我这次开发针对的车机 Android 版本比较老，所以不怎么需要管这个</p><h3 id="第-2-步"><a href="#第-2-步" class="headerlink" title="第 2 步"></a>第 2 步</h3><p>第 2 步这个 platform.jks 文件，应该是客户进入到 AOSP 的 build 目录（或者什么别的目录）下，运行 keytool 相关指令生成的，因为用户有车机系统的源码，所以他可以生成一个车机系统的签名文件出来，具体细节我不太了解，这里简单提一下大概原理即可</p><h3 id="第-5-步"><a href="#第-5-步" class="headerlink" title="第 5 步"></a>第 5 步</h3><p>因为上传到用户的应用市场需要填入 SHA1 码，所以调用 keytool 指令去获取，这里记录一下方便以后有类似场景时查阅，如果不需要的话就不要管这个了</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我们得到的这个 apk，是无法正常 adb install 的，只能获得 root 权限后，通过 adb push 到 system&#x2F;app&#x2F; 这种目录下，然后重启系统让其自行安装，具体的执行方法视乎具体系统而定。安装好后，这个应用拥有系统级权限，且无法通过常规手段卸载</p><h2 id="No-3-APK-迁移-AAB"><a href="#No-3-APK-迁移-AAB" class="headerlink" title="No.3 APK 迁移 AAB"></a>No.3 APK 迁移 AAB</h2><p>首先用我自己的理解简单说说什么是 AAB，AAB 全称是 Android App Bundle，在用户进行下载时，它会根据用户所在地区、语言、手机分辨率等差异进行分发，以达到精简应用大小的效果，更正式的说明可以自行搜索文档或其他文章</p><p>从 2021 年 8 月起，新应用上架 Google 市场就需要以 AAB 的格式上传，老应用可以继续用 APK。公司的应用逐渐臃肿，已经超过 APK 的大小限制 —— 100 MB 了。因为之前已经进行过精简，所以再压缩会比较困难，而 AAB 的大小限制是 150 MB，所以刚好趁这次机会直接将 APK 升级为 AAB 格式</p><p>需要做的非常简单，只需要修改 Jenkins 打包脚本，将 <code>gradlew assebleRelease</code> 改为 <code>gradlew bundleRelease</code>，就可以将产物从 .apk 变为 .aab，至于签名密钥文件，可以沿用 .keystore，也可以将 .keystore 转换成 .jks，这两种都是一样的，转换指令为：<code>keytool -importkeystore -srckeystore your-keystore.keystore -srcstoretype JKS -destkeystore your-keystore.jks -deststoretype JKS</code></p><p>.keystore 和 .jks 文件本质上是 Java 密钥库的不同命名格式，网上很多文章说 .keystore 是 Eclipse、keytool 生成的，而 .jks 是 Android Studio 生成的，它们本质是一样的，具体还没怎么研究，相关文章也少，暂时按这样理解，后续由新的认知可以再补充下</p><p>另外还有个语言分包问题，如果 app 做了应用内多语言切换的话，用 AAB 格式，会由于根据语言分发的特性而导致部分语言实效，所以还要加上如下配置，这里记录一下</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Gradle">android &#123;<br><br>    ...<br><br>    bundle &#123;<br>        language &#123;<br>            <span class="hljs-comment">// Specifies that the app bundle should not support</span><br>            <span class="hljs-comment">// configuration APKs for language resources. These</span><br>            <span class="hljs-comment">// resources are instead packaged with each base and</span><br>            <span class="hljs-comment">// feature APK.</span><br>            enableSplit = <span class="hljs-keyword">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">应用签名杂记</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="应用签名" scheme="https://enderhoshi.github.io/tags/%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout 的一个小技巧</title>
    <link href="https://enderhoshi.github.io/2024/09/05/ConstraintLayout%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://enderhoshi.github.io/2024/09/05/ConstraintLayout%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2024-09-05T10:00:28.000Z</published>
    <updated>2025-07-09T09:33:16.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>在做一些账号相关的功能时，我们经常有以下场景，需要展示一个人的头像、名称，名称后要跟一个小标签，比如勋章&#x2F;成就图标、定位图标、等级图标等，大致如下：</p><p><img src="/../img/blog/ConstraintLayout%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/image-0.png"></p><p>用常规方式实现上面这种布局，如下：（为了简化代码，尽可能看到关键的约束条件和参数，我写了点 style 把不太相关的参数统一声明了，后面的代码示例也是这样，不做赘述）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/cl_container_0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_avatar_0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Avatar&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_name_0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Name&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@id/iv_avatar_0&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_position_0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Position&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@id/tv_name_0&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是名称是用户自己定义的，有长有短，遇到太长的名字时，name 控件会穿出屏幕边界，把右侧的 position 挤得不可见，如下：</p><p><img src="/../img/blog/ConstraintLayout%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/image-1.png"></p><p>实际上我们想要 position 控件跟着 name 控件的长度改变位置，但是最右只能去到屏幕边界，不能被挤出去，同理 name 控件既要根据文字内容来展示，又要在宽度即将超出时进行折叠，末尾显示为 … 的形式，效果如下：</p><p><img src="/../img/blog/ConstraintLayout%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/image-2.png"></p><p>要达到这种效果，直接沿用上面的三个控件的结构，暂时我还没有办法做到，这时需要加入第四个控件（如果需求里跟在名称后的控件有两个，就省了这个操作，如果没有，直接加一个 1dp 宽高的占位 View 即可），然后分两种方式达到我们想要的效果</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="第一种方案"><a href="#第一种方案" class="headerlink" title="第一种方案"></a>第一种方案</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/cl_container_1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@id/cl_container_0&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_avatar_1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Avatar&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_name_1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Name&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constrainedWidth</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@id/placeholder_view_1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@id/iv_avatar_1&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 宽高 1dp 的占位 View，仅用于实现约束效果，并没有其他作用 --&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/placeholder_view_1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Placeholder&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/tv_name_1&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_position_1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Position&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@id/placeholder_view_1&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>与原始布局的不同点在于：</p><ol><li>name 控件多了 app:layout_constrainedWidth&#x3D;”true” 属性，而且右侧约束 placeholder_view</li><li>多了一个 placeholder_view 占位控件，placeholder_view 左侧约束 name 控件</li><li>position 控件多了 app:layout_constraintHorizontal_bias&#x3D;”0.0” 属性，而且左侧约束 placeholder_view，右侧约束父布局</li></ol><p>这个方案的基本原理在于 “推动”，name 控件推动 placeholder_view，placeholder_view 控件推动 position，推到边界时，position 控件右侧约束父布局，再也推不动了，理论上来说 position 会被限制在边界，但事实上还要再给 name 加上 app:layout_constrainedWidth&#x3D;”true” 属性，对 name 控件进行强制约束，这时才能达到效果</p><p>同时还要注意，这里的 name、placeholder_view 和 position 不能形成链，形成链的话要方案二的一些处理才能达到最终效果，讲方案二时会再展开</p><h3 id="第二种方案"><a href="#第二种方案" class="headerlink" title="第二种方案"></a>第二种方案</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/cl_container_2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@id/cl_container_1&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_avatar_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Avatar&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_name_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Name&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@id/placeholder_view_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_chainStyle</span>=<span class="hljs-string">&quot;packed&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@id/iv_avatar_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintWidth_default</span>=<span class="hljs-string">&quot;wrap&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 宽高 1dp 的占位 View，仅用于实现约束效果，并没有其他作用 --&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/placeholder_view_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Placeholder&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@id/iv_position_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/tv_name_2&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_position_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ConstraintLayoutTips.Position&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@id/placeholder_view_2&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>与原始布局的不同点在于：</p><ol><li>name 控件 android:layout_width&#x3D;”0dp”，多了 app:layout_constraintWidth_default&#x3D;”wrap” 属性，设置了 app:layout_constraintHorizontal_bias&#x3D;”0.0”、app:layout_constraintHorizontal_chainStyle&#x3D;”packed”，而且右侧约束 placeholder_view</li><li>多了一个 placeholder_view 占位控件，placeholder_view 左侧约束 name 控件，右侧约束 position 控件</li><li>position 控件左侧约束 placeholder_view，右侧约束父布局</li></ol><p>与方案一的不同点在于：</p><ol><li>三个控件构成了一条链</li><li>主要处理的控件是 name 控件</li></ol><p>这个方案的基本原理在于 “链”，三个控件构成了一条链，且把它们 packed 打包到一起，用 app:layout_constraintHorizontal_bias&#x3D;”0.0” 控制居左显示，最后用 android:layout_width&#x3D;”0dp” 配合 app:layout_constraintWidth_default&#x3D;”wrap”，处理了 name 控件字数不多时没有根据字数动态展示宽度的问题（不设置这个参数，它会把控件占满，因为 width&#x3D;”0dp”）</p><h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><ol><li>layout_constraintHorizontal_bias 用于控制布局相对水平约束空间的位置百分比，在约束主体只有一个时才有效（不知道这样说是不是合理，大概是这个意思吧），也就是说分两块时，要把 layout_constraintHorizontal_chainStyle 设置为 packed，将其绑成一块才行，否则不会生效（vertical 同理）</li><li>layout_constraintWidth_default 需要在 layout_width 为 0dp 时才能生效，因为它就是用来控制 layout_width 为 0dp 时的布局状态的（height 同理）</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>看了这位哥们的<a href="https://blog.csdn.net/weixin_39397471/article/details/128319082">文章</a>学到的，加了些自己的理解，整理归纳</p>]]></content>
    
    
    <summary type="html">使用约束布局实现头像、名称、标签布局时的一个小技巧</summary>
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="UI" scheme="https://enderhoshi.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-序列化与反序列化</title>
    <link href="https://enderhoshi.github.io/2024/09/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://enderhoshi.github.io/2024/09/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-09-05T04:13:33.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-实现-Parcelable-接口后，构造方法需要可空值"><a href="#No-1-实现-Parcelable-接口后，构造方法需要可空值" class="headerlink" title="No.1 实现 Parcelable 接口后，构造方法需要可空值"></a>No.1 实现 Parcelable 接口后，构造方法需要可空值</h2><p>记录一下序列化遇到的问题：需要在 Intent 中传递数据，所以需要序列化，Kotlin 中实现 Parcelable 接口后，constructor(parcel: Parcel) 构造方法中报错提示需要可空值，所以改动了一下默认构造方法中的类型变为可空，但是没有赋默认值，导致后续使用默认构造函数时，需要你传一个 parcel 进去，这时补上可空参数的默认值 &#x3D; null 就可以了</p><h2 id="No-2-Serializable-接口的-“传递”-问题"><a href="#No-2-Serializable-接口的-“传递”-问题" class="headerlink" title="No.2 Serializable 接口的 “传递” 问题"></a>No.2 Serializable 接口的 “传递” 问题</h2><p>最近遇到一个问题，从某个页面返回手机系统 home 页面后，再打开 app 返回那个页面，会引发闪退，报错 java.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name &#x3D; xxx.xxxx.xxxBean)。这是因为我们在某个 A 实体类中实现了 Serializable 接口，然后 A 类中有一些 B、C、D 其他类，这些 B、C、D 类却没有实现 Serializable 接口，而页面恢复时需要序列化来还原一些数据，这时进行序列化遇到没有实现 Serializable 接口的类就会报错，没有实现 Serializable 接口的类会在报错后具体写出，<a href="https://blog.csdn.net/Afanbaby/article/details/78615207">参考文章</a>。因为父类声明了子类也需要声明，所以我把这个叫做 Serializable 接口的 “传递” 问题，经过一番检索，有下面三种处理方法</p><ol><li>用 transient 来修饰类内不参与序列化&#x2F;反序列化的属性。这个需要再仔细了解下 transient 修饰符，不能乱用，因为加上了这个，对应属性不参与序列化&#x2F;反序列化，可能会影响页面数据的恢复</li><li>考虑一下属性的用途，看是否可以修改属性，不要直接用实体类，比如只需要一个 String 就能存储的信息，就不需要用一个类了。一般比较推荐这个，毕竟是做减法，复杂度更小了，毕竟你的 B、C、D 等类内可能还有 E、F、G 这些其他类，会越来越麻烦</li><li>用 Parcelable 来替代 Serializable。如果是简单的类还比较好弄，如果有很多字段，且这个类会比较频繁地加属性，那后面要一直维护这个类，不如 Seriallizable 简单。而且抽象类实现 Parcelable 接口貌似还比较复杂，不太好用</li><li>这三种处理方法的原文在<a href="https://stackoverflow.com/questions/43505285/caused-by-java-io-notserializableexception-android-net-uristringuri">这里</a>，截图如下，贴出来供参考，综上所述，我比较推荐使用第 2 种方案，实在不行的话就要再考虑 1、3 这两种了</li></ol><p><img src="/img/blog/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98.png"></p><p>另外附上 <a href="https://cloud.tencent.com/developer/article/1931748">《Android Studio 自动生成 SerialVersionUID》</a> 文章供查阅</p><h3 id="展开讲讲什么是-serialVersionUID？有什么用？"><a href="#展开讲讲什么是-serialVersionUID？有什么用？" class="headerlink" title="展开讲讲什么是 serialVersionUID？有什么用？"></a>展开讲讲什么是 serialVersionUID？有什么用？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性，其目的是以序列化对象进行版本控制，有关各版本反序加化时是否兼容</p><p>如果类没有显示定义这个静态变量，它的值是 JRE 根据类的内部细节自动生成的。若类做了修改，serialVersionUID 可能发生变化，故建议显式声明</p>]]></content>
    
    
    <summary type="html">关于序列化与反序列化</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://enderhoshi.github.io/tags/Java/"/>
    
    <category term="序列化" scheme="https://enderhoshi.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>移动存储介质实现 git 远端仓库</title>
    <link href="https://enderhoshi.github.io/2024/05/11/%E7%A7%BB%E5%8A%A8%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%AE%9E%E7%8E%B0%20git%20%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93/"/>
    <id>https://enderhoshi.github.io/2024/05/11/%E7%A7%BB%E5%8A%A8%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%AE%9E%E7%8E%B0%20git%20%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93/</id>
    <published>2024-05-11T09:35:28.000Z</published>
    <updated>2025-07-09T09:33:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一个关于离线使用 Git 的技巧，就是将远端仓库配置在一个移动存储介质（U 盘、移动硬盘，下面统一用 U 盘来描述）里，需要 push、pull 时把 U 盘插到电脑上，然后进行相关的操作</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>首先我们需要在本地文件夹内建立一个本地的 git 仓库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs BASH">// 创建一个文件夹，最好记住这个文件夹名，后面创建远端仓库时也用这个，后面 <span class="hljs-built_in">clone</span> 就比较统一了<br><span class="hljs-built_in">mkdir</span> myRepo<br><span class="hljs-built_in">cd</span> myRepo<br>git init<br><span class="hljs-built_in">touch</span> test.txt // 创建一个用于测试的 txt<br>git add .<br>git commit -m <span class="hljs-string">&quot;Initial Commit&quot;</span><br></code></pre></td></tr></table></figure></li><li>然后把你的 U 盘插到电脑里</li><li>cd 到你的 U 盘目录下，进行设置 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/h</span> <span class="hljs-string">//</span> 假设你的 U 盘被电脑识别为 H 盘<br>mkdir myRepo.git<br><span class="hljs-keyword">cd</span> myRepo.git<br>git init <span class="hljs-params">--bare</span> <span class="hljs-string">//</span> 注意要加 <span class="hljs-params">--bare</span> 创建一个裸库<br></code></pre></td></tr></table></figure></li><li>然后回到你的本地文件夹内，进行 push <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/local/my</span>Repo <span class="hljs-comment">// 回到你的本地文件夹内</span><br>git remote add origin <span class="hljs-regexp">/h/my</span>Repo.git<br>git <span class="hljs-keyword">push</span> origin master<br><br><span class="hljs-comment">// 如果有提示本地的分支没有和远程分支建立联系，可以再加上下面这句</span><br>git <span class="hljs-keyword">push</span> --set-upstream origin master<br></code></pre></td></tr></table></figure></li><li>这时就完成了 U 盘远端仓库的配置了，如果你需要把文件 pull 到本地电脑上，只需要插入 U 盘后就可以正常 fetch、pull 了</li><li>如果你需要把文件 pull 到另一台电脑上，先将 U 盘插入指定电脑，然后执行如下指令 <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">/h</span>/repoName.git // 这里同样假设你的 U 盘被电脑识别为 H 盘<br></code></pre></td></tr></table></figure></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>可以想象，这种方案可以用于一些只想本地脱离网络的多人开发场合，局域网内 gitlab 也可以做到，但是配置相对复杂一点，这个直接利用 U 盘的就非常简单</p><p>除了上述的多人开发场合，我最近也有一个用得到的场景，那就是相册备份</p><p>每次我把相机&#x2F;无人机的照片&#x2F;视频传到个人电脑上时，我还要传一份到 U 盘上，如果我直接整个文件夹复制，电脑肯定会提示我有重复的，询问是否覆盖，这时我们就要选择全部覆盖。同理，从 U 盘上把文件提取到电脑上时，也会经历这个过程。照片&#x2F;视频非常多时，这个过程会很不优雅，这时使用上面的 U 盘 Git 方案就会很方便了，它具有以下优点</p><ol><li>能够满足电脑、U 盘各存一份照片的需求</li><li>能够增量更新，不必自己识别新增了哪些照片，也不用全部覆盖</li><li>多台电脑之间可以实现相册同步，不会出现差异</li><li>比起直接用 github、gitee，这种离线方案没有容量限制，也更安全，传输也更快</li><li>比起在局域网内搭建 gitlab，这个方案更简单直接</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>基于上述设想，我进行了尝试，很快败下阵来，因为我的图片非常多，仅仅是 <code>git add .</code> 指令就花费了一个多小时还没结束。我尝试对一个 2G 的文件夹进行 <code>git add</code> 操作，发现也耗费了十来分钟。对一个 14G 的进行操作直接又一个多小时，我们平时的代码看着文件很多，但实际文件大小不大，所以才可以正常进行各种操作。而相册对于 git 来说实在是太庞大了，git 的处理速度和传输速度不足以对相册进行此类操作，遂最终放弃了这个相册存储方案</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.gibbard.me/using_git_offline/">Using Git offline</a></li><li><a href="https://www.cnblogs.com/qiyuexin/p/9926225.html">使用 U 盘或在本地电脑作为 git 远程仓库进行托管</a></li><li><a href="https://cloud.tencent.com/developer/article/1825910">Git init 和 Git init –bare 的区别，以及 Git init –bare 如何创建工作空间</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看到一个关于离线使用 Git 的技巧，就是将远端仓库配置在一个移动存储介质（U 盘、移动硬盘，下面统一用 U 盘来描述）里，需要 push、pull 时把 U 盘插到电脑上，然后进行相关的操作&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; clas</summary>
      
    
    
    
    <category term="日常查阅" scheme="https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"/>
    
    
    <category term="git" scheme="https://enderhoshi.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 主次构造函数理解</title>
    <link href="https://enderhoshi.github.io/2024/03/07/Kotlin%20%E4%B8%BB%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/"/>
    <id>https://enderhoshi.github.io/2024/03/07/Kotlin%20%E4%B8%BB%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/</id>
    <published>2024-03-07T03:09:28.000Z</published>
    <updated>2025-07-09T09:33:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做需求时需要自定义两个 View，在取自定义属性时稍微纠结了一下该放在哪里</p><ul><li>是不是该在主构造函数中调用</li><li>但是主构造方法不能有方法体</li><li>那是不是不应该放在 init 代码块里</li><li>但是 init 代码块不是会在类构造前就调用的吗，那怎么取到自定义属性</li></ul><p>搞来搞去，越来越乱，和 Java 的用法彻底搞混淆了，说来惭愧，用了 Kotlin 这么多年，还是没有彻底理清这种基础的东西，现在做点笔记记录下</p><h2 id="Java-构造函数与-init-代码块"><a href="#Java-构造函数与-init-代码块" class="headerlink" title="Java 构造函数与 init 代码块"></a>Java 构造函数与 init 代码块</h2><p>首先直接捋一下 Java 的，相对 Kotlin 的应该比较基础</p><p>想要在 Android 项目中直接跑 Java 代码，可以 new module 创建一个 Java or Kotlin Library，选择 Java 语言即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化块1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造函数&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化块2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 执行结果： </span><br>初始化块<span class="hljs-number">1</span><br>初始化块<span class="hljs-number">2</span><br>无参构造函数<br></code></pre></td></tr></table></figure><p>从上面的代码和运行结果可以看出，当创建 Java 对象时：</p><ul><li>先执行初始化块；</li><li>如果定义多个初始化块，则前面的先执行，后面的后执行；</li><li>然后执行构造函数。</li><li>虽然可以定义多个初始化块，但是没有意义， 一般合并在一起，代码更加简洁。</li></ul><h3 id="static-init-代码块"><a href="#static-init-代码块" class="headerlink" title="static init 代码块"></a>static init 代码块</h3><p>使用 static 修饰符定义的初始化块，称为静态初始化块，也叫类初始化块。普通初始化块是对对象初始化，类初始化块是对类初始化。因此静态初始化块总是比普通初始化块先执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Root</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Root static init&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Root obj init&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Root</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Root constructor func&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mid</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Root</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Mid static init&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Mid obj init&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mid</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Mid constructor func&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mid</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>();<br>        System.out.println(<span class="hljs-string">&quot;Mid has param constructor: &quot;</span> + msg);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mid</span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Leaf static init&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Leaf obj init&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Leaf</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;MESSAGE&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Leaf constructor func &quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 执行结果</span><br>Root <span class="hljs-keyword">static</span> init<br>Mid <span class="hljs-keyword">static</span> init<br>Leaf <span class="hljs-keyword">static</span> init<br>Root obj init<br>Root constructor func<br>Mid obj init<br>Mid constructor func<br>Mid has param constructor: MESSAGE<br>Leaf obj init<br>Leaf constructor func<br></code></pre></td></tr></table></figure><p>从上面的代码和执行结果看：</p><ul><li>会先进行类初始化， 然后对象初始化，类初始化全部先执行一遍。先执行父类初始化，然后子类初始化。</li><li>对象初始化时，同样先执行父类的初始化块，构造函数，然后执行子类的。</li></ul><p>另外，静态初始化块和静态成员变量，初始化的值与代码顺序相对应。如果你先 int a &#x3D; 5，然后再写 init 块改变它的值为 8，最后输出 a 为 8，反之如果先 init 块中赋值 a &#x3D; 8，再 int a &#x3D; 5，那么最后输出 a 为 5</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>初始化块是构造函数的补充。</li><li>初始化块总在构造函数之前执行。</li><li>初始化块是一段固定执行的代码， 不接受任何参数， 因此，如果一段初始化代码对所有对象相同， 且不用接收任何参数，则可以把这段初始化代码放在初始化块中。</li></ul><p>实际上初始化块是一个假象， 使用 javac 编译 Java 类后， 初始化块消失，被”还原”到构造器中，且位于构造器所有函数的前面。</p><p><a href="https://blog.csdn.net/yonggang7/article/details/85200134">参考文章</a></p><h2 id="Kotlin-构造函数与-init-代码块"><a href="#Kotlin-构造函数与-init-代码块" class="headerlink" title="Kotlin 构造函数与 init 代码块"></a>Kotlin 构造函数与 init 代码块</h2><p>然后再看一下 Kotlin 相关的内容，在 Kotlin 中有两种类型的构造函数，分别是主构造函数（主构造器）和次级构造函数（次级构造器），在 Kotlin 类中只有一个主构造函数，而次级构造函数可以是一个或者多个。</p><p>construction 在 Kotlin 中是一个关键字，在 Java 中，构造方法名必须和类名相同，例如文中开头写的 Java 的构造函数；而在 Kotlin 中，是通过 constructor 关键字来标明的，对于主构造函数来说，它的位置在类的标题中声明，而对于次级构造函数来说它的位置在类中。</p><p>并且当 constructor 关键字没有注解和可见性修饰符作用于它时，constructor 关键字可以省略。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123; ... &#125; <span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123; ... &#125; <span class="hljs-comment">// private 修饰</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">12</span>) &#123; ... &#125; <span class="hljs-comment">// 有注解</span><br><br><span class="hljs-comment">// 如果构造方法中参数用了 val 或 var 修饰，那么他们就是类的属性，否则只是参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123; ... &#125; <span class="hljs-comment">// name 和 age 都不是 Person 类的属性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123; ... &#125; <span class="hljs-comment">// name 和 age 都是 Person 类的属性</span><br></code></pre></td></tr></table></figure><h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><p>主构造函数用于初始化类，它在类标题中声明。需要注意的是主构造函数不能包含任何代码，所以这时的初始化代码块本质就是主构造函数的方法体。</p><p>当我们定义一个类并没有声明一个主构造函数的时候，Kotlin 会默认为我们生成一个无参的主构造函数，这一点和 Java 一样</p><h3 id="次级构造函数"><a href="#次级构造函数" class="headerlink" title="次级构造函数"></a>次级构造函数</h3><p>我们可以在同一类中使用主构造函数和次级构造函数。如果一个类有次构造函数，那么这些次构造函数就必须调用主构造函数，方式可以不同：</p><ol><li>无参的主构造函数会被次级构造函数隐式调用，且顺序在次级构造函数之前</li><li>可以使用 this() 对同一个类中的另一个构造函数进行调用</li><li>可以使用 super() 来调用父类的构造函数</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 的用法和 Java 的有比较大的不同，使用时要注意区分</p><p><a href="https://juejin.cn/post/6844903872016678919#heading-2">参考文章</a></p><h2 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h2><p>梳理完毕，现在我们看回一开始的问题</p><ul><li>是不是该在主构造函数中调用<ul><li>确实是应该在主构造中调用，View 构造完就该读取自定义属性了</li></ul></li><li>但是主构造方法不能有方法体<ul><li>init 就是主构造的方法体</li></ul></li><li>那是不是不应该放在 init 代码块里<ul><li>应该放在 init 代码块里，因为它就是主构造的方法体</li></ul></li><li>但是 init 代码块不是会在类构造前就调用的吗，那怎么取到自定义属性<ul><li>Java 的会在类构造前调用，但是 Kotlin 的不会，Kotlin 中 init 就是主构造函数的一部分，执行到 init 时，已经跑完主构造函数，它能够取到自定义属性</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在做需求时需要自定义两个 View，在取自定义属性时稍微纠结了一下该放在哪里&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是不是该在主构造函数中调用&lt;/li&gt;
&lt;li&gt;但是主构造方法不能有方法体&lt;/li&gt;
&lt;li&gt;那是不是不应该放在 init 代码块里&lt;/li&gt;
&lt;li&gt;但是 init </summary>
      
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://enderhoshi.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 统一依赖管理方案</title>
    <link href="https://enderhoshi.github.io/2024/03/05/Android%20Gradle%20%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/"/>
    <id>https://enderhoshi.github.io/2024/03/05/Android%20Gradle%20%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/</id>
    <published>2024-03-05T08:51:33.000Z</published>
    <updated>2025-07-09T09:33:16.186Z</updated>
    
    <content type="html"><![CDATA[<p>在组件化开发 Android 应用时，多个模块可能由不同同事负责，并且依赖引入也可能不是由同一个人来控制，这样会导致引用到的依赖版本不一致，统一升级不方便等问题，所以对版本的统一管理很重要</p><p>Android 最原始的依赖管理方式就是直接引入，如果要统一管理，有三种方式：</p><ol><li>传统 apply from 的方式</li><li>buildSrc 方式</li><li>includeBuild 方式（也有叫 composing builds 方式的）</li></ol><p>经过一些考虑，个人认为 apply from 的方式无法跟踪代码、无法自动补全、需要手动搜索相关的依赖，且可读性很差；而 includeBuild 的方式有点太复杂了，于是选择使用 buildSrc 的方式，这里做下记录</p><h2 id="buildSrc-方式统一管理依赖流程"><a href="#buildSrc-方式统一管理依赖流程" class="headerlink" title="buildSrc 方式统一管理依赖流程"></a>buildSrc 方式统一管理依赖流程</h2><ol><li>在项目根目录下新建一个名为 buildSrc 的文件夹(名字必须是 buildSrc，因为运行 Gradle 时会检查项目中是否存在一个名为 buildSrc 的目录)</li><li>在 buildSrc 文件夹里创建名为 build.gradle.kts 的文件，添加以下内容<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">plugins &#123;<br>    `kotlin-dsl`<br>&#125;<br>repositories&#123;<br>    mavenCentral()<br>&#125;<br></code></pre></td></tr></table></figure></li><li>创建 buildSrc&#x2F;src&#x2F;main&#x2F;kotlin&#x2F; 目录，然后在其下新建 Dependencies.kt 文件，添加以下内容 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">object</span> Versions &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> compileAndTargetSdk = <span class="hljs-number">34</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> compileSdk = compileAndTargetSdk<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> targetSdk = compileAndTargetSdk<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> minSdk = <span class="hljs-number">24</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> buildToolsVersion = <span class="hljs-string">&quot;30.0.3&quot;</span><br>&#125;<br><br><span class="hljs-keyword">object</span> Strings &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> applicationId =<span class="hljs-string">&quot;com.hoshi.armor&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>同步一下，项目里就会多出一个名为 buildSrc 的 module，同时buildSrc 目录下多出了一些不需要的东西，可以在 gitignore 中加一下来忽略掉<br><img src="/../img/blog/Android%20Gradle%20%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/buildSrc_dir.png"></li><li>然后就可以在 build.gradle.kts 中使用了<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">compileSdk</span> <span class="hljs-operator">=</span> Versions.compileSdk<br><span class="hljs-attribute">buildToolsVersion</span> <span class="hljs-operator">=</span> Versions.buildToolsVersion<br><br>defaultConfig &#123;<br>    applicationId <span class="hljs-operator">=</span> Strings.applicationId<br>    targetSdk <span class="hljs-operator">=</span> Versions.targetSdk<br>    minSdk <span class="hljs-operator">=</span> Versions.minSdk<br>    versionCode <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    versionName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>有一点要注意的，如果发现无法引用到 Dependencies 内定义的常量，可能是同步的顺序有问题，我在执行上面第 2 步后立刻同步，就无法正确引用了，重新按顺序走一遍流程，最后走到第 4 步才同步，就可以正常使用</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/7097431328441761800#heading-1">&lt;版本&gt;Android统一依赖管理</a></li><li><a href="https://blog.csdn.net/ssq236811/article/details/115694382">Android gradle统一依赖版本：kotlin+buildSrc</a></li><li><a href="https://blog.csdn.net/u010629285/article/details/116005860">Android 统一依赖管理</a></li></ul><h2 id="新一代版本依赖管理-Vesion-Catalog"><a href="#新一代版本依赖管理-Vesion-Catalog" class="headerlink" title="新一代版本依赖管理 Vesion Catalog"></a>新一代版本依赖管理 Vesion Catalog</h2><p>这个是预览版的内容，还未稳定发布，但是看起来将来会成为比较主流的一种用法，后续 AS 的稳定版本支持这种方式后，可以尝试改成这种，然后再补充一下日志，<a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/131501932">参考文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在组件化开发 Android 应用时，多个模块可能由不同同事负责，并且依赖引入也可能不是由同一个人来控制，这样会导致引用到的依赖版本不一致，统一升级不方便等问题，所以对版本的统一管理很重要&lt;/p&gt;
&lt;p&gt;Android 最原始的依赖管理方式就是直接引入，如果要统一管理，有三</summary>
      
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="Gradle" scheme="https://enderhoshi.github.io/tags/Gradle/"/>
    
    <category term="依赖管理" scheme="https://enderhoshi.github.io/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-版本适配</title>
    <link href="https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"/>
    <id>https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/</id>
    <published>2024-03-05T07:38:33.000Z</published>
    <updated>2025-07-09T09:33:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-startForegroundService-方法导致报错-RemoteServiceException-引起闪退"><a href="#No-1-startForegroundService-方法导致报错-RemoteServiceException-引起闪退" class="headerlink" title="No.1 startForegroundService 方法导致报错 RemoteServiceException 引起闪退"></a>No.1 startForegroundService 方法导致报错 RemoteServiceException 引起闪退</h2><p>闪退机型：(均为 Android 9.0 系统)</p><ul><li>小米 MI NOTE 3</li><li>华为 <ul><li>P30 Pro (VOG AL00)</li><li>P10 PLUS (VKY AL00 )</li><li>NOVA 4 (VCE AL00)</li><li>Mate10 (ALP AL00)</li><li>Mate20 (LYA AL00)</li><li>P30 (ELE AL00)</li></ul></li><li>荣耀 <ul><li>HONOR 9 (STF AL00)</li><li>HONOR 10 （COL AL10）</li><li>HONOR V10 （BKL AL20）</li><li>HONOR Note 10 （RVL AL09） </li><li>HONOR Play （COR AL00）</li></ul></li><li>索尼 G8142</li><li>一加 pro 7</li></ul><p>报错详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">android.app.RemoteServiceException  <br>Context.startForegroundService() did not <span class="hljs-keyword">then</span> call Service.startForeground()<br></code></pre></td></tr></table></figure><h3 id="Android-O-后台执行限制"><a href="#Android-O-后台执行限制" class="headerlink" title="Android O 后台执行限制"></a>Android O 后台执行限制</h3><p>Android 8.0 为提高电池续航时间而引入的变更之一是，当您的应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁</p><p>此外，为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言：</p><ul><li>现在，在后台运行的应用对后台服务的访问受到限制</li><li>应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播）</li><li>默认情况下，这些限制仅适用于针对 O 的应用，不过，用户可以从 Settings 屏幕为任意应用启用这些限制，即使应用并不是以 O 为目标平台</li></ul><p>Android 8.0 还对特定函数做出了以下变更：</p><ul><li>如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException</li><li>新的 Context.startForegroundService() 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 Context.startForegroundService()。不过，应用必须在创建服务后的五秒内调用该服务的 startForeground() 函数，否则会导致 ANR</li></ul><h3 id="Android-O-后台服务限制"><a href="#Android-O-后台服务限制" class="headerlink" title="Android O 后台服务限制"></a>Android O 后台服务限制</h3><p>在后台中运行的服务会消耗设备资源，这可能降低用户体验。 为了缓解这一问题，系统对这些服务施加了一些限制</p><p>系统可以区分 前台 和 后台 应用，（用于服务限制目的的后台定义与内存管理使用的定义不同；一个应用按照内存管理的定义可能处于后台，但按照能够启动服务的定义又处于前台）如果满足以下任意条件，应用将被视为处于前台： </p><ol><li>具有可见 Activity（不管该 Activity 已启动还是已暂停）</li><li>具有前台服务</li><li>另一个前台应用已关联到该应用（不管是通过绑定到其中一个服务，还是通过使用其中一个内容提供程序），例如，如果另一个应用绑定到该应用的服务，那么该应用处于前台：<ul><li>IME</li><li>壁纸服务</li><li>通知侦听器</li><li>语音或文本服务</li></ul></li></ol><p>如果以上条件均不满足，应用将被视为处于后台。</p><p>绑定服务不受影响，这些规则不会对绑定服务产生任何影响，如果您的应用定义了绑定服务，则不管应用是否处于前台，其他组件都可以绑定到该服务</p><p>处于前台时，应用可以自由创建和运行前台服务与后台服务，进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用服务，在该时间窗结束后，应用将被视为处于 空闲 状态。 此时，系统将停止应用的后台服务，就像应用已经调用服务的 <code>Service.stopSelf()</code> 方法，在这些情况下，后台应用将被置于一个临时白名单中并持续数分钟。 位于白名单中时，应用可以无限制地启动服务，并且其后台服务也可以运行，处理对用户可见的任务时，应用将被置于白名单中，例如：</p><ol><li>处理一条高优先级 Firebase 云消息传递 (FCM) 消息。</li><li>接收广播，例如短信&#x2F;彩信消息。</li><li>从通知执行 PendingIntent。</li></ol><p>在很多情况下，您的应用都可以使用 JobScheduler 作业替换后台服务，例如 CoolPhotoApp 需要检查用户是否已经从朋友那里收到共享的照片，即使该应用未在前台运行，在之前的版本中，应用使用一种会检查其云存储的后台服务。 为了迁移到 Android 8.0，开发者使用一个计划作业替换了这种后台服务，该作业将按一定周期启动，查询服务器，然后退出，在 Android 8.0 之前，创建前台服务的方式通常是先创建一个后台服务，然后将该服务推到前台，而 Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务，因此，Android 8.0 引入了一种全新的方法，即 <code>Context.startForegroundService()</code>，以在前台启动新服务，在系统创建服务后，应用有五秒的时间来调用该服务的 <code>startForeground()</code> 方法以显示新服务的用户可见通知，如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR</p><p>所以为了解决这个问题，应该：</p><ol><li>将启动 Service 调用的 startService 改为 startForegroundService</li><li>调用了 startForegroundService 后需要在 Service 里继续调用 Service.startForeground()，有如下三个注意事项<ul><li>在 Service 的 onCreate 方法和 onStartCommand 方法中都调用 startForeground，因为 onCreate 方法不一定会每一次都调用，主要是针对后台保活的服务，如果在服务A运行期间，保活机制又调用 startForegroundService 启动了一次服务A，那么这样不会调用服务A的 onCreate 方法，只会调用 onStartCommand 方法</li><li>notification ID 必须不为 0，否则会报同样的错误</li><li>调用 stopSelf 必须要在调用 startForeground 之后</li></ul></li></ol><p>这样应该就能够解决了</p><p>相关文章：<a href="https://www.jianshu.com/p/ee224f18a4bd">Android Service 生命周期</a>、<a href="https://www.jianshu.com/p/b529e61d220a">Android 通知渠道</a>、<a href="https://zhuanlan.zhihu.com/p/32930310">Android Oreo 通知新特性</a></p><h2 id="No-2-Android-Q-反射失效导致K线图缩放异常"><a href="#No-2-Android-Q-反射失效导致K线图缩放异常" class="headerlink" title="No.2 Android Q 反射失效导致K线图缩放异常"></a>No.2 Android Q 反射失效导致K线图缩放异常</h2><p>在处理一些手势缩放事件时，可以用如下做法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scaleGestureDetector = ScaleGestureDetector(context, ScaleListener())<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScaleListener</span> : <span class="hljs-type">ScaleGestureDetector.SimpleOnScaleGestureListener</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScaleBegin</span><span class="hljs-params">(detector: <span class="hljs-type">ScaleGestureModifyDetector</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onScaleBegin(detector)<br>        <span class="hljs-comment">// 开始缩放</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScale</span><span class="hljs-params">(detector: <span class="hljs-type">ScaleGestureModifyDetector</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onScale(detector)<br>        <span class="hljs-comment">// 缩放中的处理</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScaleEnd</span><span class="hljs-params">(detector: <span class="hljs-type">ScaleGestureModifyDetector</span>?)</span></span> &#123;<br>        <span class="hljs-comment">// 缩放完毕</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要在 ScaleListener 中实现想要的逻辑就可以了</p><p>但是，在 ScaleGestureDetector 中有一个属性 mMinSpan，在执行构造函数初始化时，会赋予一个从 viewConfiguration 对象获得的 mMinScalingSpan 值，又从 onTouchEvent() 方法中可以看到，当 span &lt; mMinSpan 时，会调用 mListener.onScaleEnd(this)，意思就是，当双指缩小到这个尺寸时，就不会再缩小了，所以造成了缩放不顺畅的效果，那么这个尺寸是多少呢，要怎么修改呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScaleGestureDetector</span><span class="hljs-params">(Context context, OnScaleGestureListener listener, Handler handler)</span> &#123;<br>    ···<br>    mMinSpan = viewConfiguration.getScaledMinimumScalingSpan();<br>    ···<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScaledMinimumScalingSpan</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mConstructedWithContext) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Min scaling span cannot be determined when this &quot;</span><br>            + <span class="hljs-string">&quot;method is called on a ViewConfiguration that was instantiated using a &quot;</span><br>            + <span class="hljs-string">&quot;constructor with no Context parameter&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mMinScalingSpan;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    ···<br>    <span class="hljs-keyword">if</span> (!inAnchoredScaleMode() &amp;&amp; mInProgress &amp;&amp; (span &lt; mMinSpan || configChanged)) &#123;<br>        mListener.onScaleEnd(<span class="hljs-built_in">this</span>);<br>        mInProgress = <span class="hljs-literal">false</span>;<br>        mInitialSpan = span;<br>    &#125;<br>    ···<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟踪进去看到，ViewConfiguration 类中的 get() 方法中，会用 ViewConfiguration 的私有构造函数创建一个 ViewConfiguration 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewConfiguration <span class="hljs-title function_">get</span><span class="hljs-params">(Context context)</span> &#123;<br>    ···<br>    <span class="hljs-type">ViewConfiguration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> sConfigurations.get(density);<br>    <span class="hljs-keyword">if</span> (configuration == <span class="hljs-literal">null</span>) &#123;<br>        configuration = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewConfiguration</span>(context);<br>        sConfigurations.put(density, configuration);<br>    &#125;<br>    <span class="hljs-keyword">return</span> configuration;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 ViewConfiguration 的私有构造函数中，会取到一个系统中写死的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">ViewConfiguration</span><span class="hljs-params">(Context context)</span> &#123;<br>    mMinScalingSpan = res.getDimensionPixelSize(com.android.internal.R.dimen.config_minScalingSpan);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 mm 是指屏幕的物理毫米尺寸，换算成 dp 大概是三四百像素左右，这么大，难怪卡顿了，必须要改掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;config_minScalingSpan&quot;</span>&gt;</span>27mm<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先用了反射的方法，将这个值直接给他改成 50 像素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> declaredFields = ScaleGestureDetector::<span class="hljs-keyword">class</span>.java.declaredFields<br>declaredFields.first &#123; it.name == <span class="hljs-string">&quot;mMinSpan&quot;</span> &#125;?.apply &#123;<br>    isAccessible = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">set</span>(scaleGestureDetector, <span class="hljs-number">50</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Android Q 之前的版本，运行完美，但是一但用户更新了 Android Q，就又会出现缩放不灵敏的感觉，就是说，我们的反射失效了</p><p>查阅文档，可以在 Android Q 中受限的灰名单中的非 SDK 接口列表中看到下面这一条：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Landroid/view/ScaleGestureDetector;-&gt;mMinSpan:I   <span class="hljs-comment"># To retrieve the min scaling span value in pixels, you can now use ViewConfiguration.get([context]).getScaledMinScalingSpan().</span><br><span class="hljs-comment"># 翻译：要检索最小缩放范围值（以像素为单位），现在可以使用 ViewConfiguration.get([context]).getScaledMinScalingSpan()</span><br></code></pre></td></tr></table></figure><p>也就是说，在 Android 9 中还是不建议使用的这个变量，现在直接受限了，使用反射是取不到改不了的了，其实不单只是这个变量，类里的其他变量都多多少少无法使用了，说明通过反射来修改一些私有变量在 Android Q 中其实并不是太可靠了，那没办法了，只能用最后一步了，直接复制整个类，然后改掉想要改掉的部分，然后替换掉原来的 ScaleGestureDetector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScaleGestureModifyDetector</span><span class="hljs-params">(Context context, OnScaleGestureListener listener, Handler handler)</span> &#123;<br>    ···<br>    <span class="hljs-comment">// mMinSpan = viewConfiguration.getScaledMinimumScalingSpan();</span><br>    mMinSpan = <span class="hljs-number">50</span>; <span class="hljs-comment">// 直接赋予为 50，单位为像素</span><br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="No-3-Android-14-适配-Intent-相关"><a href="#No-3-Android-14-适配-Intent-相关" class="headerlink" title="No.3 Android 14 适配 Intent 相关"></a>No.3 Android 14 适配 Intent 相关</h2><p>最近把 HoshiCore 库进行了一下 Android 14 的适配，起因是我的另一个项目里，提升 targetSdk 到 14 后，所有页面跳转都失效了，查了一下资料，原来是 Intent 有一些安全性调整，有如下一大段描述，原文点击<a href="https://developer.android.com/about/versions/14/behavior-changes-14?hl=zh-cn#safer-intents">这里</a>跳转</p><blockquote><p>对于面向 Android 14 的应用，Android 通过以下方式限制应用向内部应用组件发送隐式 intent：隐式 intent 仅传递给导出的组件，应用必须使用明确的 intent 来交付给未导出的组件，或者将组件标记为已导出（exported）。</p><p>如果应用创建一个 mutable pending intent ，但 intent 未指定组件或包，系统现在会抛出异常。</p><p>这些更改可防止恶意应用拦截只供给用内部组件使用的隐式 intent，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">   <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.AppActivity&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.action.APP_ACTION&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果应用尝试使用隐式 intent 启动该 activity，则会抛出异常：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">// Throws an exception when targeting Android 14.</span><br>context.startActivity(Intent(<span class="hljs-string">&quot;com.example.action.APP_ACTION&quot;</span>))<br></code></pre></td></tr></table></figure><p>要启动未导出的 Activity，应用应 <del>改用显式 Intent</del> <strong>给 Intent 对象设置 package</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">// This makes the intent explicit.</span><br><span class="hljs-keyword">val</span> explicitIntent = Intent(<span class="hljs-string">&quot;com.example.action.APP_ACTION&quot;</span>)<br>explicitIntent.apply &#123;<br>   <span class="hljs-keyword">package</span> = context.packageName<br>&#125;<br>context.startActivity(explicitIntent)<br></code></pre></td></tr></table></figure></blockquote><p>上述描述中，原版的描述是 “改用显式 Intent”，而我认为应该是 “给 Intent 对象设置 package” 即可，在一开始我们的认知里，显式 Intent 指的是明确写出了 Activity 的 Intent，应该也可以说是用了以下这个构造函数的情形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Intent</span><span class="hljs-params">(Context packageContext, Class&lt;?&gt; cls)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>而隐式 Intent 指不像显式那样直接指定需要调用的 Activity 的一种 Intent，它是设置 Action、Data、Category 等参数，让系统来筛选出合适的 Activity 的一种 Intent，筛选是根据 <code>&lt;intent-filter&gt;</code> 来进行的</p><p>官方的例子里很明显就是调用了以下这种构造函数，是用了 Action 的，应该是属于隐式声明的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Intent</span><span class="hljs-params">(String action)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>所以我认为并没有改成了显式声明，只是在原来的隐式声明上作了一些调整，也可能是我理解出了偏差，官方可能把这种指定了 package 的 Intent 认为是显式的，因为它指定的东西足够多了</p><p>当然，咬文嚼字多说无益，解决问题最重要，这里记录一些思考，旨在避免这类随意的文档描述混淆视听，搞乱了原来的理解，如果以后有新的认识，可以再作记录</p><h2 id="No-4-提升-minSdkVersion-后-APK-变大"><a href="#No-4-提升-minSdkVersion-后-APK-变大" class="headerlink" title="No.4 提升 minSdkVersion 后 APK 变大"></a>No.4 提升 minSdkVersion 后 APK 变大</h2><p>公司项目引入了一个第三方的远程预览库，最近需要提升版本，版本提升后发现需要同步提升 minSdkVersion，于是又把 minSdkVersion 提升到 23，结果打包后发现 APK 增大了 70M。把新旧 APK 都拉到 AS 里面一看，发现 lib 文件夹下的各个 .so 库的体积都翻了一倍</p><p>网上搜索了一下相关症状，发现是因为 minSdkVersio 23 以下时，android:extractNativeLibs 默认为 true，而 minSdkVersion 大于等于 23 时，android:extractNativeLibs 默认为 false，下面是 google 对这个属性的一些解析</p><blockquote><p>此属性指示软件包安装程序是否将原生库从 APK 提取到文件系统。如果设置为 “false”，则原生库以未压缩的形式存储在 APK 中。虽然您的 APK 可能较大，但应用加载速度更快，因为库是在应用运行时直接从 APK 加载。<br>extractNativeLibs 的默认值取决于 minSdkVersion 和您使用的 AGP 版本。在大多数情况下，默认行为很可能符合您的预期，您无需显式设置此属性。</p><p>从 AGP 4.2.0 开始，DSL 选项 useLegacyPackaging 取代了 extractNativeLibs 清单属性。请使用应用的 build.gradle 文件中的 useLegacyPackaging（而非清单文件中的 extractNativeLibs）来配置原生库压缩行为。如需了解详情，请参阅版本说明使用 DSL 打包压缩的原生库。</p></blockquote><p>所以，可以手动设置一下 android:extractNativeLibs 或者 useLegacyPackaging，即可避免提升 minSdkVersion 后 APK 包体积变大的问题</p><h2 id="No-5-提升-AGP-版本后，BuildConfig-不生成"><a href="#No-5-提升-AGP-版本后，BuildConfig-不生成" class="headerlink" title="No.5 提升 AGP 版本后，BuildConfig 不生成"></a>No.5 提升 AGP 版本后，BuildConfig 不生成</h2><p>在版本适配过程中，有时候需要提升 AGP（Android Gradle Plugin）版本，在把 AGP 版本从较旧版本提升到 8.0.0 之后，发现 BuildConfig 都提示找不到了，这是因为 8.0.0 之后，默认不会生成 BuildConfig 了，需要做以下配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">android &#123;<br>    buildFeatures &#123;<br>        buildConfig = <span class="hljs-keyword">true</span> <span class="hljs-comment">// 配置开启 buildConfig 构建特性，新版本 AGP 需要配置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相关官方文档，可以查看<a href="https://developer.android.com/build/releases/past-releases/agp-8-0-0-release-notes?hl=zh-cn#default-changes">这里</a></p>]]></content>
    
    
    <summary type="html">关于版本适配的一些开发中的笔记</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="版本适配" scheme="https://enderhoshi.github.io/tags/%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-疑难杂症</title>
    <link href="https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    <id>https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</id>
    <published>2024-03-05T07:35:26.000Z</published>
    <updated>2025-07-09T09:33:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>整理之前的近期小记时，发现有一些笔记不太好归类，且可能比较偏门，统一放到这里，汇集到一定量后可以再分类存放</p><!-- more --><h2 id="No-1-听云集成报错-No-virtual-method-isVisible"><a href="#No-1-听云集成报错-No-virtual-method-isVisible" class="headerlink" title="No.1 听云集成报错 No virtual method isVisible()"></a>No.1 听云集成报错 No virtual method isVisible()</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">java.lang.NoSuchMethodError: No virtual method isVisible()Z <span class="hljs-keyword">in</span> class Lcom/xxxx/xxxxxx/containers/xxxxxx; or its super classes (declaration of <span class="hljs-string">&#x27;com.xxxxxx.xxxxxxx.containers.xxxxxx&#x27;</span> appears <span class="hljs-keyword">in</span> /data/app/com.myapp.app-JUxpxJQv7z6s5jkYdS3yHw==/base.apk!classes3.dex)<br></code></pre></td></tr></table></figure><p>报错信息如上图，初步推断为听云嵌码插桩逻辑有些问题，部分类应该跳过插桩的过程，搜索相关内容寥寥无几，且不相关，听云客服疑似空号，添加失败，客服群也加不进去，最后从非常旧和凌乱的文档中看到一个不太起眼的描述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 等号“=”后替换为需要过滤听云嵌码的类的路径，如有多个路径，使用英文逗号隔开</span><br>noInstrumentedClasses=com/xxxxxx/xxxxxxx/containers/xxxxxxx<br></code></pre></td></tr></table></figure><p>把报错中指出的类填入这个 noInstrumentedClasses 中，再次编译，还是不行，后来发现是他的配置内容有缓存在本地，clean project 再重新跑就可以了，记录这个不是为了下次接入再查阅，而是提醒自己需要提升信息搜集能力和文档查阅能力，同时多从报错中推断；处理类似的第三方接入问题时，更改配置要 clean project，避免部分配置缓存在本地造成误判，认为自己的写法有误；另外，接入第三方库时尽量选取维护比较积极，售后比较靠谱的</p><p><a href="https://github.com/alibaba/flutter_boost/issues/646">相关链接</a></p><h2 id="No-2-Mac-处理-Adobe-Genuine-Software-Integrity-Service"><a href="#No-2-Mac-处理-Adobe-Genuine-Software-Integrity-Service" class="headerlink" title="No.2 Mac 处理 Adobe Genuine Software Integrity Service"></a>No.2 Mac 处理 Adobe Genuine Software Integrity Service</h2><p>使用”不明来路”的 ps, 某一天突然弹出个窗，必须点一下才能关掉，而且过一会又弹出来，无法彻底关闭</p><p>解决方法:</p><ol><li>关闭所有 Adobe 软件</li><li>$ sudo rm &#x2F;Library&#x2F;Application\ Support&#x2F;Adobe&#x2F;AdobeGCClient&#x2F;AdobeGCClient.app&#x2F;Contents&#x2F;MacOS&#x2F;AdobeGCClient</li><li>启动 ps，就正常了</li></ol><h2 id="No-3-Android-SSL-验证服务器证书-Hostname-不匹配错误"><a href="#No-3-Android-SSL-验证服务器证书-Hostname-不匹配错误" class="headerlink" title="No.3 Android SSL 验证服务器证书 Hostname 不匹配错误"></a>No.3 Android SSL 验证服务器证书 Hostname 不匹配错误</h2><p>有时候开发需要改动 host，然后会报 host name 不匹配的错误，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>-<span class="hljs-number">24</span> <span class="hljs-number">16</span>:<span class="hljs-number">37</span>:<span class="hljs-number">04.801</span>: W/System.err(<span class="hljs-number">26380</span>):   java.io.IOException: Hostname <span class="hljs-string">&#x27;74.208.145.100&#x27;</span> was not verified<br></code></pre></td></tr></table></figure><p>错误原因是验证证书时发现真正请求和服务器的证书域名不一致，这时就可以在客户端代码中增加如下代码，忽略hostname 的验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">HttpsURLConnection.setDefaultHostnameVerifier( <span class="hljs-keyword">new</span> <span class="hljs-title class_">HostnameVerifier</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(String string,SSLSession ssls)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="No-4-电脑可以科学上网但是模拟器不能的情况"><a href="#No-4-电脑可以科学上网但是模拟器不能的情况" class="headerlink" title="No.4 电脑可以科学上网但是模拟器不能的情况"></a>No.4 电脑可以科学上网但是模拟器不能的情况</h2><p>自己胡乱鼓捣的时候，发现有这样一种情况：电脑已经开启了科学上网，模拟器可以上网，但是不能浏览外网</p><p>解决方法:</p><ol><li>打开模拟器配置，找到 proxy 选项</li><li>ip 写 127.0.0.1，端口写代理的端口（如果使用的是 Clash，打开 Clash 主界面 -&gt; General 应该就可以看到）</li><li>保存设置，再尝试一下</li></ol><h2 id="No-5-AS-4-2-Gradle-面板中-Tasks-不见了"><a href="#No-5-AS-4-2-Gradle-面板中-Tasks-不见了" class="headerlink" title="No.5 AS 4.2 Gradle 面板中 Tasks 不见了"></a>No.5 AS 4.2 Gradle 面板中 Tasks 不见了</h2><p>某次想要执行一些 Gradle 命令，点开 Gradle 面板时，发现其中的 Tasks 不见了</p><p><img src="/../img/blog/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/Task_missing.webp"></p><p>解决办法如下：</p><p><img src="/../img/blog/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/Task_missing_fix.webp"></p><p><a href="https://www.jianshu.com/p/62503ba5d83d">参考文章</a></p><h2 id="No-6-gradle-properties-中文乱码"><a href="#No-6-gradle-properties-中文乱码" class="headerlink" title="No.6 gradle.properties 中文乱码"></a>No.6 gradle.properties 中文乱码</h2><p>如果发现 gradle.properties 原本应该是中文的一些注释变成了乱码，可以留意一下 IDE 右下方的编码是什么格式，如果是 ISO-8859-1，那么就可以到设置里找到 Editor -&gt; File Encodings 选项，把默认的 properties 格式改成 UTF-8，如下图</p><p><img src="/../img/blog/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/gradle_properties_garbled.png"></p><h2 id="No-7-返回手势需要执行两次"><a href="#No-7-返回手势需要执行两次" class="headerlink" title="No.7 返回手势需要执行两次"></a>No.7 返回手势需要执行两次</h2><p>我们平时使用返回手势时，手机边缘会出现一个返回箭头以示成功触发，松开手指就会执行返回操作，但是我开发时发现我的 App 存在一个问题，返回手势第一次触发无反应，第二次才会出现箭头，此时把手指移回边缘，也就是把返回操作取消掉，再执行，又是无反应，再触发一次才能成功。简而言之就是我每次想触发返回，都要执行两次手势</p><p>看了一下 Logcat，发现频繁打印 <code>Android handleResized abandoned!</code>，问问 AI，得到这样的答复：这个日志通常由 SurfaceFlinger 或 ViewRootImpl 打印，表示在处理窗口大小变化时遇到问题，导致一些窗口调整操作被中止或放弃</p><p>检查代码发现，注释掉处理全屏的代码后，这个现象就不再会发生，再继续追问，得到这样的答复：如果你观察到 <code>Android handleResized abandoned!</code> 频繁出现在全屏模式下，这通常与窗口大小调整、系统栏状态变化或 SurfaceView 的 Surface 变化有关</p><p>我又多尝试了一下，发现这个与全屏情况下，触碰边缘后弹出状态栏有一点像，类似于正常情况下第一次触碰手机屏幕边缘时，状态栏弹出来，然后才能响应接下来第二次的操作。之所以我不能第一时间发现，就是因为我的全屏代码似乎没有生效，导致状态栏一直显示着，但是却需要两次去触发返回</p><p>我的设置全屏代码如下，有很多已经被废弃的属性，可能是因为我提升了 Android 版本，其中有一些属性已经无效了导致出现问题。我想替换 ImmersionBar 库来做全屏，发现它的 fullScreen 方法也失效了，应该也是因为同样的原因。于是换用了 ImmersionBar 库的 hideBar 方法，隐藏状态栏和导航栏来实现全屏，暂告一段落，这里先记录一下，具体的原因后续有兴趣再研究了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置是否全屏</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> enabled 是否全屏显示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Activity.<span class="hljs-title">setFullscreen</span><span class="hljs-params">(enabled: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (enabled) &#123;<br>        window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">val</span> lp: WindowManager.LayoutParams = window.attributes<br>        <span class="hljs-comment">// LayoutParams.FLAG_FULLSCREEN 强制屏幕状态条栏弹出</span><br>        lp.flags = lp.flags and WindowManager.LayoutParams.FLAG_FULLSCREEN.inv()<br>        window.attributes = lp<br>        <span class="hljs-comment">// 不允许窗口扩展到屏幕之外  clear掉了</span><br>        window.clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS)<br>    &#125;<br><br>    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)<br>    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)<br><br>    <span class="hljs-keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility<br>    systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN<br>    systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_STABLE<br>    window.decorView.systemUiVisibility = systemUiVisibility<br><br>    window.statusBarColor = Color.TRANSPARENT<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一些疑难杂症的笔记记录，汇集到一定量后可以再分类存放</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="疑难杂症" scheme="https://enderhoshi.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-Fragment</title>
    <link href="https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-Fragment/"/>
    <id>https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-Fragment/</id>
    <published>2024-03-05T07:33:28.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-Fragment-not-attached-to-a-context"><a href="#No-1-Fragment-not-attached-to-a-context" class="headerlink" title="No.1 Fragment not attached to a context"></a>No.1 Fragment not attached to a context</h2><p>可以检查以下是否是下面的情况产生的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> dialog = SquareConfirmDialog().apply &#123;<br>    <span class="hljs-comment">// 以下代码会报错 not attached to a context</span><br>    <span class="hljs-comment">// 因为调用的是 Dialog 的 Fragment.getString() 方法，而此时 dialog 并未 attached to a context</span><br>    positive = getString(R.string.ai_base_policy_agree_and_continue)<br><br>    <span class="hljs-comment">// 以下代码是正确用法，调用当前 Activity 的 Context.getString() 方法</span><br>    negative = <span class="hljs-keyword">this</span><span class="hljs-symbol">@CurrentActivity</span>.getString(R.string.somt_string)<br>    contentView = view<br>    onPositiveListener = &#123; &#125;<br>    onNegativeListener = &#123; finish() &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="No-2-相邻的-Fragment-中使用-webview，出现加载异常的问题"><a href="#No-2-相邻的-Fragment-中使用-webview，出现加载异常的问题" class="headerlink" title="No.2 相邻的 Fragment 中使用 webview，出现加载异常的问题"></a>No.2 相邻的 Fragment 中使用 webview，出现加载异常的问题</h2><p>在项目中，一个页面中同时使用多个不同的 Fragment，比如 ViewPager 中有几个 Fragment 的场景，这几个 Fragment 同时加载，且其中有几个是有 WebView 的，这个时候就会出现当中的某一个或者几个出现异常的情况，原因是使用 Webview 加载不同的 url 时，会存在 js 及 css 动画执行异常的问题，当时使用的布局，Viewpager 中存在两个不同的 Fragment，在这两个 Fragment 中分别使用 Webview 加载了不同的页面（页面中使用了比较接近的js及样式），这个问题最后的解决办法是，当需要加载 Viewpager 时，只加载一个 Fragment 或者一个 Webview，切换 tab 标签时，再去动态更换加载其他的 URL，也就是懒加载</p><h2 id="No-3-commit-和-commitAllowingStateLoss-区别及应用场景"><a href="#No-3-commit-和-commitAllowingStateLoss-区别及应用场景" class="headerlink" title="No.3 commit 和 commitAllowingStateLoss 区别及应用场景"></a>No.3 commit 和 commitAllowingStateLoss 区别及应用场景</h2><p>做 Android 开发，Fragment 是我们经常用的，我们在使用 Fragment 时，会像如下这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> getFragmentManager();<br>testFragment = (TestFragment) fm.findFragmentById(R.id.fragment_container);<br><br><span class="hljs-keyword">if</span> (testFragment == <span class="hljs-literal">null</span>) &#123;<br>    testFragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestFragment</span>();<br>    fm.beginTransaction().add(R.id.fragment_container, testFragment).commit();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们偶尔会碰到这样一个异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState<br></code></pre></td></tr></table></figure><p>大意是在 activity 的 onSaveInstanceState 调用过后，再 commit 的 Transaction 导致的异常，看到网上一些建议用 commitAllowingStateLoss 来代替 commit，那么 commit 和 commitAllowingStateLoss 有什么区别呢？查看下相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> commitInternal(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">commitAllowingStateLoss</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> commitInternal(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>发现他们都是调用了commitInternal()方法，只是一个传了false，一个传了true，接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">commitInternal</span><span class="hljs-params">(<span class="hljs-type">boolean</span> allowStateLoss)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mCommitted) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;commit already called&quot;</span>);<br>    &#125;<br>    ...<br>    mCommitted = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (mAddToBackStack) &#123;<br>        mIndex = mManager.allocBackStackIndex(<span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mIndex = -<span class="hljs-number">1</span>;<br>    &#125;<br>    mManager.enqueueAction(<span class="hljs-built_in">this</span>, allowStateLoss);<br>    <span class="hljs-keyword">return</span> mIndex;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是 mManager.enqueueAction(this, allowStateLoss) 来执行这个任务，根据传入的参数继续往下走，可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueueAction</span><span class="hljs-params">(Runnable action, <span class="hljs-type">boolean</span> allowStateLoss)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!allowStateLoss) &#123;<br>        checkStateLoss();<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mDestroyed || mHost == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Activity has been destroyed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mPendingActions == <span class="hljs-literal">null</span>) &#123;<br>            mPendingActions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Runnable&gt;();<br>        &#125;<br>        mPendingActions.add(action);<br>        <span class="hljs-keyword">if</span> (mPendingActions.size() == <span class="hljs-number">1</span>) &#123;<br>            mHost.getHandler().removeCallbacks(mExecCommit);<br>            mHost.getHandler().post(mExecCommit);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是最后了，可以看到最开始传进来的 allowStateLoss 在这里只做了检查状态的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkStateLoss</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mStateSaved) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mNoTransactionsBecause != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Can not perform this action inside of &quot;</span> + mNoTransactionsBecause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果activity的状态被保存了，这里再提交就会检查这个状态，符合条件就抛出一个异常来终止应用进程，也就是说在 activity 调用了 onSaveInstanceState()之后，再 commit 一个事务就会出现该异常，那如果不想抛出异常，也可以很简单调用 commitAllowingStateLoss() 方法来略过这个检查就可以了，但是 Google 说这是危险的，在官方文档上有如下描述：</p><blockquote><p>Like {@link #commit} but allows the commit to be executed after an activity’s state is saved. This is dangerous because the commit can be lost if the activity needs to later be restored from its state, so this should only be used for cases where it is okay for the UI state to change unexpectedly on the user.</p></blockquote><p>大意是如果 activity 随后需要从它保存的状态中恢复，这个 commit 是会丢失的，因此它仅仅适用在ui状态的改变对用户来说是可以接受的</p><p>因此可以得出几点结论：</p><ul><li>在 activity 的生命周期方法中提交事务要小心，越早越好，比如 onCreate，也可以在接收用户的输入时来提交，尽量避免在 onActivityResult() 方法中提交</li><li>避免在异步的回调方法中执行 commit，因为他们感知不到当前 activity 生命周期的状态</li><li>使用 commitAllowingStateLoss() 代替 commit()，相比于 crash，我觉得 ui 状态的改变对用户来说是可以接受的，但是也要看场景，比如涉及到金融相关的场景，用户可能突然觉得钱没了(从ui上看)，那还不如crash让系统再重新拉起 App 呢</li></ul><p>原文：<a href="https://huxian99.github.io/2016/08/28/cj3qymo360000owxk9zp17alo/">Android commit和commitAllowingStateLoss区别及应用场景</a></p>]]></content>
    
    
    <summary type="html">关于 Fragment 的一些开发中的笔记</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="Fragment" scheme="https://enderhoshi.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-UI</title>
    <link href="https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-UI/"/>
    <id>https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-UI/</id>
    <published>2024-03-05T07:00:28.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-RecyclerView-隐藏-item（多布局）的所在区域显示空白"><a href="#No-1-RecyclerView-隐藏-item（多布局）的所在区域显示空白" class="headerlink" title="No.1 RecyclerView 隐藏 item（多布局）的所在区域显示空白"></a>No.1 RecyclerView 隐藏 item（多布局）的所在区域显示空白</h2><p>在 RecyclerView 是多种布局的情况下，需要把 RecyclerView 的其中一个条目 GONE 掉，若只是把内容隐藏，这样就会出现一片空白区域，高度不会改变，解决方法是，隐藏时把 item 的高度宽度设置为 0，需要显示的时候再设置回来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (type == TYPE1) &#123; <span class="hljs-comment">// 某个类型，反正就是要隐藏的类型或者状态</span><br>    <span class="hljs-keyword">val</span> param = holder.itemView.layoutParams<br>    param.height = <span class="hljs-number">0</span><br>    param.width = <span class="hljs-number">0</span><br>    holder.itemView.layoutParams = param<br>    ...<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 其他类型，要显示的类型或者状态，恢复宽高</span><br>    <span class="hljs-keyword">val</span> param = holder.itemView.layoutParams<br>    param.height = ScreenUtil.dp2px(context, <span class="hljs-number">46F</span>)<br>    param.width = RelativeLayout.LayoutParams.MATCH_PARENT<br>    holder.itemView.layoutParams = param<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="No-2-ListView-getChildAt-取得位置错误问题"><a href="#No-2-ListView-getChildAt-取得位置错误问题" class="headerlink" title="No.2 ListView getChildAt() 取得位置错误问题"></a>No.2 ListView getChildAt() 取得位置错误问题</h2><p>有时候我们需要获取 ListView 或 RecycleView 的某个 item 的 view 对象来做一些处理，发现使用 getChildAt(position: Int) 这个方法取到的不是想要的 item，而是可视的第 position 位置的 item，也就是说 position 只是从第一个可以看到的 item 算起的，这样就和实际列表中的第 position 个是不一样的，这样就需要使用如下代码来取得实际的位置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> itemPosition = <span class="hljs-number">1</span> <span class="hljs-comment">// 想要修改的 item position</span><br><span class="hljs-keyword">val</span> targetPosition = itemPosition - listView.getFirstVisiblePosition() <span class="hljs-comment">// 实际的目标 item position</span><br><span class="hljs-keyword">val</span> itemView = listView.getChildAt(targetPosition)<br></code></pre></td></tr></table></figure><p>这里需要注意的是 itemView 在可视范围上方时，会返回 null，在源码中可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Returns the view at the specified position in the group.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> index the position at which to get the view from</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> the view at the specified position or null if the position</span><br><span class="hljs-comment">  *         does not exist within the group</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> View <span class="hljs-title function_">getChildAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= mChildrenCount) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mChildren[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>所以需要对空值做一下处理</p><h2 id="No-3-performClick-和-callOnclick-的区别"><a href="#No-3-performClick-和-callOnclick-的区别" class="headerlink" title="No.3 performClick 和 callOnclick 的区别"></a>No.3 performClick 和 callOnclick 的区别</h2><p>View 类的 performClick 和 callOnclick 函数都可以实现点击，不用用户手动点击，直接触发 View 的点击事件。区别有如下两点：</p><ol><li><p>API 等级</p><p> performClick 是在 API 1 中加入，callOnClick 是在 API 15 中加入</p></li><li><p>代码实现层面</p><p> 看两个方面的代码实现，如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Directly call any attached OnClickListener.  Unlike &#123;<span class="hljs-doctag">@link</span> #performClick()&#125;,</span><br><span class="hljs-comment">* this only calls the listener, and does not do any associated clicking</span><br><span class="hljs-comment">* actions like reporting an accessibility event.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> True there was an assigned OnClickListener that was called, false</span><br><span class="hljs-comment">*         otherwise is returned.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">callOnClick</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>    <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-literal">null</span>) &#123;<br>        li.mOnClickListener.onClick(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Call this view&#x27;s OnClickListener, if it is defined.  Performs all normal</span><br><span class="hljs-comment"> * actions associated with clicking: reporting accessibility event, playing</span><br><span class="hljs-comment"> * a sound, etc.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> True there was an assigned OnClickListener that was called, false</span><br><span class="hljs-comment"> *         otherwise is returned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">performClick</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> result;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>    <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-literal">null</span>) &#123;<br>        playSoundEffect(SoundEffectConstants.CLICK);<br>        li.mOnClickListener.onClick(<span class="hljs-built_in">this</span>);<br>        result = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-literal">false</span>;<br>    &#125;<br>    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p> 从代码中可以看出，callOnClick 是 performClick 的简化版，不包含点击播放声音，不具有辅助功能，辅助功能官方介绍如下：</p><blockquote><p>许多 Android 用户有不同的能力（限制），这要求他们以不同的方式使用他们的 Android 设备。这些限制包括视力，肢体或与年龄有关，这些限制阻碍了他们看到或充分使用触摸屏，而用户的听力丧失，让他们可能无法感知声音信息和警报，Android 提供了辅助功能的特性和服务帮助这些用户更容易的使用他们的设备，这些功能包括语音合成、触觉反馈、手势导航、轨迹球和方向键导航。Android 应用程序开发人员可以利用这些服务，使他们的应用程序更贴近用户</p></blockquote></li></ol><h2 id="No-4-android-ems-具体意义"><a href="#No-4-android-ems-具体意义" class="headerlink" title="No.4 android ems 具体意义"></a>No.4 android ems 具体意义</h2><p>在 android 里 setEms() 作用是设置 TextView 的字符宽度，em 是一个印刷排版的单位，表示字宽的单位，em 字面意思为：equal M（和M字符一致的宽度为一个单位）简称 em，而 ems 是 em 的复数表达，所以 ems 和字节什么的都是没关系的，只是和字宽度有关系，而且由于各个手机版本自定义字体等问题，所以设置 ems 意义不大，只能作为参考，当设置该属性后，控件显示的长度就为10个字符的长度，超出的部分将不显示，而且 EditText 的属性，只有在<br><code>android:layout_width=&quot;wrap_content&quot;</code> 时，才会显示，如果是 <code>android:layout_width=&quot;match_parent&quot;</code><br> 时，则不会有变化</p><h2 id="No-5-图片显示上下有空白的解决办法"><a href="#No-5-图片显示上下有空白的解决办法" class="headerlink" title="No.5 图片显示上下有空白的解决办法"></a>No.5 图片显示上下有空白的解决办法</h2><p>在使用 ImageView 时，采用不同的 scaleType 属性可以调整图片的缩放类型，但是有时会导致图片上下方出现空白，这时就要设置 <code>android:adjustViewBounds=&quot;true&quot;</code></p><h3 id="关于-ImageView-的-adjustViewBounds-属性"><a href="#关于-ImageView-的-adjustViewBounds-属性" class="headerlink" title="关于 ImageView 的 adjustViewBounds 属性"></a>关于 ImageView 的 adjustViewBounds 属性</h3><p>取值为 true 时：</p><blockquote><p>Adjust the ImageView’s bounds to preserve the aspect ration of its drawable.</p></blockquote><p>调整 ImageView 的界限来保持图像纵横比不变。<br>这并不意味着 ImageView 的纵横比就一定和图像的纵横比相同，XML定义里的 <code>android:adjustViewBounds=&quot;true&quot;</code> 会将这个 ImageView 的 scaleType 设为 fitCenter，不过这个 fitCenter 会被后面定义的 scaleType 属性覆盖（如果定义了的话），除非在 Java 代码里再次显式调用 setAdjustViewBounds(true)</p><h4 id="1-如果设置的-layout-width-与-layout-height-都是定值"><a href="#1-如果设置的-layout-width-与-layout-height-都是定值" class="headerlink" title="1. 如果设置的 layout_width 与 layout_height 都是定值"></a>1. 如果设置的 layout_width 与 layout_height 都是定值</h4><p>那么设置 adjustViewBounds 是没有效果的，ImageView 将始终是设定的定值的宽高</p><h4 id="2-如果设置的-layout-width-与-layout-height-都是-wrap-content"><a href="#2-如果设置的-layout-width-与-layout-height-都是-wrap-content" class="headerlink" title="2. 如果设置的 layout_width 与 layout_height 都是 wrap_content"></a>2. 如果设置的 layout_width 与 layout_height 都是 wrap_content</h4><p>那么设置 adjustViewBounds 是没有意义的，因为 ImageView 将始终与图片拥有相同的宽高比（但是并不是相同的宽高值，通常都会放大一些）</p><h4 id="3-如果两者中一个是定值，一个是-wrap-content"><a href="#3-如果两者中一个是定值，一个是-wrap-content" class="headerlink" title="3. 如果两者中一个是定值，一个是 wrap_content"></a>3. 如果两者中一个是定值，一个是 wrap_content</h4><p>比如 <code>android:layout_width=&quot;100px&quot;</code>，<code>android:layout_height=&quot;wrap_content&quot;</code> 时，ImageView 的宽将始终是 100px，而高则分两种情况：</p><ul><li>当图片的宽小于 100px 时，layout_height 将与图片的高相同，即图片不会缩放，完整显示在 ImageView 中，ImageView 高度与图片实际高度相同，图片没有占满 ImageView，ImageView 中有空白</li><li>当图片的宽大于等于 100px 时，此时 ImageView 将与图片拥有相同的宽高比，因此 ImageView 的 layout_height 值为：100 除以图片的宽高比，比如图片是 500X500 的，那么 layout_height 是 100，图片将保持宽高比缩放，完整显示在 ImageView 中，并且完全占满 ImageView</li></ul><h2 id="No-6-硬件加速导致画线不显示（有待深入研究，先总结现象）"><a href="#No-6-硬件加速导致画线不显示（有待深入研究，先总结现象）" class="headerlink" title="No.6 硬件加速导致画线不显示（有待深入研究，先总结现象）"></a>No.6 硬件加速导致画线不显示（有待深入研究，先总结现象）</h2><ul><li>Android 9.0 drawLine drawPath 都可以正常实现画线，抗锯齿，实现虚线</li><li>Android 9.0 以下 <ul><li>drawLine 一定能画出线，但是不能画出虚线 (抗锯齿有效)</li><li>drawPath 一定能画出虚线，但是大斜率的时候线会消失 (抗锯齿无效) 因为x y值过大，不进行绘制了</li></ul></li></ul><h2 id="No-7-在约束布局中使用-include-标签报错"><a href="#No-7-在约束布局中使用-include-标签报错" class="headerlink" title="No.7 在约束布局中使用 include 标签报错"></a>No.7 在约束布局中使用 include 标签报错</h2><p>在约束布局 ConstraintLayout 中引入了一个布局，然后给引入布局添加了底部约束，让它距离底部 8dp，但是引入布局仍然出现在顶部，并报错如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Layout parameter layout_marginBottom ignored unless both layout_width and layout_height are also specified on &lt;include&gt; tag<br></code></pre></td></tr></table></figure><p>在约束布局中引入新的控件或者布局时，若不重新指定一下控件或者布局的宽高，那么给它添加的约束便会失效，给 include 标签中添加上 layout_width 和 layout_height 属性即可</p><h2 id="No-8-BottomSheetDialog-输入框输入文字时上下跳动"><a href="#No-8-BottomSheetDialog-输入框输入文字时上下跳动" class="headerlink" title="No.8 BottomSheetDialog 输入框输入文字时上下跳动"></a>No.8 BottomSheetDialog 输入框输入文字时上下跳动</h2><p>开发中遇到一个问题，一个 BottomSheetDialog 里面有上下两个输入框，上方的输入框在软键盘弹出时，并没有被软键盘顶着，所以输入时，BottomSheetDialog 表现正常，但是下方的输入框，是被软键盘顶的，在输入时，BottomSheetDialog 中的 TextView 要根据输入的内容作出变化，这时，一旦 TextView 的属性为 wrap_parent ，他的的文字发生变化时，高度宽度随之发生变化，BottomSheetDialog 就会上下跃动，体验比较差，后来发现只要给定 TextView 的高度和宽度，就可以避免这个问题，比较低版本的 Android 系统中似乎不会出现，后续有待排查</p><h2 id="No-9-关于-ViewPager-嵌套-RecyclerView，当-RecyclerView-滑动到尽头后，不希望-ViewPager-被连带拖动的情况"><a href="#No-9-关于-ViewPager-嵌套-RecyclerView，当-RecyclerView-滑动到尽头后，不希望-ViewPager-被连带拖动的情况" class="headerlink" title="No.9 关于 ViewPager 嵌套 RecyclerView，当 RecyclerView 滑动到尽头后，不希望 ViewPager 被连带拖动的情况"></a>No.9 关于 ViewPager 嵌套 RecyclerView，当 RecyclerView 滑动到尽头后，不希望 ViewPager 被连带拖动的情况</h2><p>有下面两种情况</p><ol><li>当 RecyclerView 外部是一个自定义的 View，你可以在这个自定义的 View 中加入下面的代码，这样，外部可以判断如果 rv 不可滑动，就做一个类似拦截的操作，避免引起滑动（还需要研究 dispatchTouchEvent 相关内容，弄明白这样为什么有效）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">lastX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">lastY</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span><br>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercept</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(ev);<br>    <span class="hljs-keyword">switch</span> (ev.getAction())<br>    &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>            intercept = needIntercept(ev);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>    &#125;<br>    lastX = (<span class="hljs-type">int</span>)ev.getX();<br>    lastY = (<span class="hljs-type">int</span>)ev.getY();<br><br>    <span class="hljs-keyword">return</span> intercept;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needIntercept</span><span class="hljs-params">(MotionEvent ev)</span><br>&#123;<br>    <span class="hljs-comment">// 水平滚动距离大于垂直滚动距离则拦截</span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> ev.getX() - lastX;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> ev.getY() - lastY;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isHorizontal</span> <span class="hljs-operator">=</span> Math.abs(deltaX) &gt; Math.abs(deltaY);<br>    <span class="hljs-keyword">if</span> (isHorizontal)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (deltaX &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 往右滑动</span><br>            <span class="hljs-keyword">return</span> !recyclerView.canScrollHorizontally(-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 往左滑动</span><br>            <span class="hljs-keyword">return</span> !recyclerView.canScrollHorizontally(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>自定义一个 View 继承 RecyclerView，写如下代码，有点像内部拦截法，需要弄懂 requestDisallowInterceptTouchEvent 相关内容<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-comment">/*---解决垂直 ViewPager 嵌套水平 RecyclerView 横向滑动到底后不滑动 ViewPager start ---*/</span><br>    <span class="hljs-type">ViewParent</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">while</span>(!((parent = parent.getParent()) <span class="hljs-keyword">instanceof</span> ViewPager)); <span class="hljs-comment">// 循环查找 ViewPager</span><br>    parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(ev);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="No-10-View-的一些踩坑"><a href="#No-10-View-的一些踩坑" class="headerlink" title="No.10 View 的一些踩坑"></a>No.10 View 的一些踩坑</h2><h3 id="1-GestureDetector-无反应"><a href="#1-GestureDetector-无反应" class="headerlink" title="1. GestureDetector 无反应"></a>1. GestureDetector 无反应</h3><p>使用 GestureDetector 时，无论什么手势，均无反应，解决方法：需要重写 onDown 方法，可看<a href="https://blog.csdn.net/catzifeng/article/details/89571226">参考文章</a></p><h3 id="2-界面闪烁"><a href="#2-界面闪烁" class="headerlink" title="2. 界面闪烁"></a>2. 界面闪烁</h3><p>View 的逻辑不能太重，运算不能太多，重复调用的的 path 相关操作要记得 reset，可看<a href="https://blog.csdn.net/DucklikeJAVA/article/details/98636505">参考文章</a></p><h2 id="No-11-SurfaceView-重叠问题"><a href="#No-11-SurfaceView-重叠问题" class="headerlink" title="No.11 SurfaceView 重叠问题"></a>No.11 SurfaceView 重叠问题</h2><p>有时候我们会遇到页面内有两个 SurfaceView 的场景，比如有一个视频播放器在上方，下方是一个地图控件。正常使用时问题不大，一旦涉及到一些要设置显隐（View.VISIBLE、View.GONE）以及离开页面又回来的情形时，在某些 Android 高版本手机（测试时用的是）就会有一些异常出现，地图控件的内容会显示在视频播放器上，即使这两个控件本来的位置并不重合，这时候如果再设置一下控件的显隐或者位置（总之就是让它再发生一些布局变化刷新一下），又会恢复正常</p><p>初步猜测，经过离开页面又返回的这个过程后，控件位置会产生一些未知变化，然后两个 SurfaceView 显示会出现异常，页面内有这种情况，要注意规避，有以下的一些方案：</p><ol><li>不能用 GONE 和 VISIBLE 控制显隐，需要使用 alpha 来控制（xml 中设置为 gone 都不行）；原理就是让空间不存在 GONE 或者 INVISIBLE 这种可能导致异常的状态。但是这样之后，点击事件不好处理，因为以前用了 GONE 和 INVISIBLE 之后，控件就点击不到了，用 alpha 控制的话，还要另外处理</li><li>想办法设置 SurfaceView 的背景色，遮盖掉底部地图不让其透出来；要注意等视频播放器出图像后又把背景色移除掉，否则背景色会一直存在导致视频内容被遮盖，这个方案缺点在于你要控制好设置背景色和移除背景色的时机，否则会有一瞬间出现底部的控件，看起来还是有些怪</li><li>用弹窗尝试改造页面；如果你的地图控件是弹出来的或者是点击后再显示的，这种方案其实是最佳的，可以把它写在另一个弹窗页面内，一方面和页面解耦，另一方面可以避免重叠问题</li><li>还有一种方案是设置 <code>surfaceView.setZOrderOnTop(true)</code>；这样可以让你想要放在顶层的 SurfaceView 始终位于顶层，但是要注意这样之后它就是最顶层的，没有其他控件能遮盖它了，看到有<a href="https://blog.51cto.com/marller/1762028">文章</a>说再调用一下 <code>surfaceView.setZOrderMediaOverlay(true)</code> 可以解决，然而实际并没有用</li></ol><h2 id="No-12-补间动画重置问题"><a href="#No-12-补间动画重置问题" class="headerlink" title="No.12 补间动画重置问题"></a>No.12 补间动画重置问题</h2><p>因为公司代码框架的问题，切换 Tab 时，补间动画（也可以叫做 View 动画）没有保留在最后一帧，而是重置到第一帧了，一般情况下好像不会这样，但是现在出现了这个问题又不好改公司代码，所以换属性动画来实现，就解决了问题，这是因为属性动画是基于对象的实际属性进行修改，从而体现出动画，而补间动画只是 View 的一些动画体现，实际上 View 没有变化，所以不知道怎么就被重置了。这里简单记录一下，加深对两种动画之间的区别的认识。</p>]]></content>
    
    
    <summary type="html">关于 UI 实现的一些开发中的笔记</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="UI" scheme="https://enderhoshi.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记-TextView &amp; EditText</title>
    <link href="https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-TextView%20&amp;%20EditText/"/>
    <id>https://enderhoshi.github.io/2024/03/05/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-TextView%20&amp;%20EditText/</id>
    <published>2024-03-05T06:15:55.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>开发笔记主要是记录开发中遇到的一些问题和解决方案，以及引发的一些思考，不会太深入地记录问题，但是会尽可能广泛地记录涉及到的内容，方便之后整理归纳和查阅</p><!-- more --><h2 id="No-1-TextView-添加-SpannableString-点击事件，并添加点击色"><a href="#No-1-TextView-添加-SpannableString-点击事件，并添加点击色" class="headerlink" title="No.1 TextView 添加 SpannableString 点击事件，并添加点击色"></a>No.1 TextView 添加 SpannableString 点击事件，并添加点击色</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">tv.movementMethod = LinkMovementMethod.getInstance() <span class="hljs-comment">// 必须设置否则无法点击</span><br>tv.highlightColor = SkinManager.resourcesTool.getColor(android.R.color.transparent) <span class="hljs-comment">// 设置点击后的高亮颜色，这里设置为透明，即点击后无反应</span><br></code></pre></td></tr></table></figure><h2 id="No-2-TextView-添加下划线并抗锯齿"><a href="#No-2-TextView-添加下划线并抗锯齿" class="headerlink" title="No.2 TextView 添加下划线并抗锯齿"></a>No.2 TextView 添加下划线并抗锯齿</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">textView.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);<br></code></pre></td></tr></table></figure><h2 id="No-3-TextView-中-Emoji-变淡"><a href="#No-3-TextView-中-Emoji-变淡" class="headerlink" title="No.3 TextView 中 Emoji 变淡"></a>No.3 TextView 中 Emoji 变淡</h2><p>TextView 中有 Emoji 时，Emoji 会变淡发白，具体的表现如该<a href="https://zhuanlan.zhihu.com/p/80510358">文章</a>中后半部分图片所示，评论中也有人提及</p><p>具体的解决办法：设置 textColor 后即可，可能与文字颜色相关，具体原理未知</p><h2 id="No-4-EditText-maxLines-不生效的问题"><a href="#No-4-EditText-maxLines-不生效的问题" class="headerlink" title="No.4 EditText maxLines 不生效的问题"></a>No.4 EditText maxLines 不生效的问题</h2><p>这是由于 android:inputType 属性默认值为 none 的缘故，设置 maxLines 后，再设置一下 inputType，就可以正常生效了</p><p>如果要设置单行的话，设置 singleLine 为 true 可以生效，但是 singleLine 已经过期了，提示用使用 <code>android:maxLines=&quot;1&quot;</code> 代替，设置之后也要记得设置一下 inputType，否则会没有效果。同理 TextView 应该也是一样</p><h2 id="No-5-EditText-showSoftInput-不起作用"><a href="#No-5-EditText-showSoftInput-不起作用" class="headerlink" title="No.5 EditText showSoftInput 不起作用"></a>No.5 EditText showSoftInput 不起作用</h2><p>有的时候需要在界面一显示时就让输入框处于焦点状态，并且需要键盘弹出，方便用户输入，需要以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs XML">android:focusable=&quot;true&quot;<br>android:focusableInTouchMode=&quot;true&quot;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">editText.requestFocus()<br><span class="hljs-keyword">val</span> inputManager = editText.context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword">as</span> InputMethodManager<br>inputManager.showSoftInput(editText, InputMethodManager.SHOW_IMPLICIT)<br></code></pre></td></tr></table></figure><p>有时当该 EditText 还未被绘制出来，InputMethodManager 还不能获取到该控件的焦点，软键盘不会弹出，manager.showSoftInput() 函数返回 false，告诉你键盘并未显示，而当 EditText 完全被绘制出来了，就可以去获取焦点了，所以需要添加绘制完毕监听，当 EditText 被绘制完毕时，调用 onGlobalLayoutListener.onGlobalLayout，正确展示键盘</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">editText?.viewTreeObserver?.addOnGlobalLayoutListener &#123;<br>  showKeyboard(editText)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lintcgirl/article/details/49796763">相关链接</a></p><h2 id="No-6-EditText-输入中文时出现下划线拼音处理"><a href="#No-6-EditText-输入中文时出现下划线拼音处理" class="headerlink" title="No.6 EditText 输入中文时出现下划线拼音处理"></a>No.6 EditText 输入中文时出现下划线拼音处理</h2><p>在开发过程中，有时候会需要监听 EditText 输入内容长度做出反应的操作，但是像某些手机如小米的输入机制，会在输入中文的时候出现带下划线的拼音，这种情况影响了 EditText 输入长度监听</p><p>处理方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 首先新建一个 自定义 InputFilter 继承 InputFilter</span><br><span class="hljs-comment">// 重写 filter() 方法，在filter 中过滤带下划线的字符</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> start 新输入的字符串起始下标，一般为0</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> end 一次性输入的长度，删除为 0</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> dest 原内容起始坐标</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> dstart 原内容终点坐标</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filter</span><span class="hljs-params">(source: <span class="hljs-type">CharSequence</span>?, start: <span class="hljs-type">Int</span>, end: <span class="hljs-type">Int</span>, dest: <span class="hljs-type">Spanned</span>?, dstart: <span class="hljs-type">Int</span>, dend: <span class="hljs-type">Int</span>)</span></span>: CharSequence &#123;<br>    <span class="hljs-comment">// 下划线字符不输入，避免输入中文的时候出现带下划线的拼音，这种情况影响了 EditText 输入长度监听</span><br>    <span class="hljs-keyword">val</span> spannableString = SpannableString(source)<br>    <span class="hljs-keyword">val</span> spans = spannableString.getSpans(<span class="hljs-number">0</span>, spannableString.length, Any::<span class="hljs-keyword">class</span>.java)<br>    <span class="hljs-keyword">if</span> (spans != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (span <span class="hljs-keyword">in</span> spans) &#123;<br>            <span class="hljs-keyword">if</span> (span <span class="hljs-keyword">is</span> UnderlineSpan) &#123; <span class="hljs-comment">// 带下划线的 span</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 最后把 filters 设置到 editText 中 see MaxLengthInputFilter</span><br>dialog_edit.filters = arrayOf(MaxLengthInputFilter(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>InputFilter 是系统提供的一个接口类，里面只有一个方法 filter()，用于过滤输入&#x2F;插入的字符串，返回值为 CharSequence</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputFilter</span> &#123;<br>    CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence var1, <span class="hljs-type">int</span> var2, <span class="hljs-type">int</span> var3, Spanned var4, <span class="hljs-type">int</span> var5, <span class="hljs-type">int</span> var6)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LengthFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InputFilter</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LengthFilter</span><span class="hljs-params">(<span class="hljs-type">int</span> max)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllCaps</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InputFilter</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AllCaps</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AllCaps</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Locale locale)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="No-7-Edittext-设置-inputType-为密码不能生效"><a href="#No-7-Edittext-设置-inputType-为密码不能生效" class="headerlink" title="No.7 Edittext 设置 inputType 为密码不能生效"></a>No.7 Edittext 设置 inputType 为密码不能生效</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 设置密文的时候，需要同时设置 TYPE_CLASS_TEXT 才能生效</span><br>et_price.setInputType(InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD）<br><br><span class="hljs-comment">// 设置小数</span><br>et_price.setInputType(InputType.TYPE_NUMBER_FLAG_DECIMAL or InputType.TYPE_CLASS_NUMBER）<br><br><span class="hljs-comment">// 设置无符号小数</span><br>et_price.setInputType(InputType.TYPE_NULL or InputType.TYPE_CLASS_NUMBER or InputType.TYPE_NUMBER_FLAG_DECIMAL)<br><br><span class="hljs-comment">// 设置有符号小数</span><br>et_price.setInputType(InputType.TYPE_NUMBER_FLAG_SIGNED or InputType.TYPE_CLASS_NUMBER or InputType.TYPE_NUMBER_FLAG_DECIMAL)<br></code></pre></td></tr></table></figure><h2 id="No-8-EditText-全角半角问题"><a href="#No-8-EditText-全角半角问题" class="headerlink" title="No.8 EditText 全角半角问题"></a>No.8 EditText 全角半角问题</h2><p>密码默认全角，需要设置半角以免影响 hint 的字体，设置半角需要在设置 inputType 之后，且全角半角可能会影响行数，出现即使设置了 maxLines 也无效的情况，切换明文密文显示，会让 digits 设置无效，需要另外实现 InputFilter</p>]]></content>
    
    
    <summary type="html">关于 TextView 和 EditText 的一些开发中的笔记</summary>
    
    
    
    <category term="开发笔记" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="TextView" scheme="https://enderhoshi.github.io/tags/TextView/"/>
    
    <category term="EditText" scheme="https://enderhoshi.github.io/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>Git 速查</title>
    <link href="https://enderhoshi.github.io/2022/03/09/Git%20%E9%80%9F%E6%9F%A5/"/>
    <id>https://enderhoshi.github.io/2022/03/09/Git%20%E9%80%9F%E6%9F%A5/</id>
    <published>2022-03-09T08:06:28.000Z</published>
    <updated>2025-07-09T09:33:16.187Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中，我们会用到一些 Git 的指令，有的比较常用，已经烂熟于心了，但是还有一些比较重要但是没有那么常用的，每次要用时记忆总有偏差，需要重新 Google 具体的用法，现在统一记录一下，方便以后查阅</p><h1 id="1-关于-Tag"><a href="#1-关于-Tag" class="headerlink" title="1. 关于 Tag"></a>1. 关于 Tag</h1><p>删除本地 Tag 的指令比较简单，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d your-tag<br></code></pre></td></tr></table></figure><p>如果要推送某个标签到远程，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin your-tag<br></code></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --tags<br></code></pre></td></tr></table></figure><p>但是，如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d your-tag<br></code></pre></td></tr></table></figure><p>然后，从远程删除，比较怪异和难记的就是这个，删除命令也是 push，但是格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin :refs/tags/your-tag<br></code></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/902335479936480">参考文章1</a></p><p><a href="https://zhuanlan.zhihu.com/p/133706032">参考文章2</a></p><h1 id="2-设置-AS-内-git-环境为-git-bash"><a href="#2-设置-AS-内-git-环境为-git-bash" class="headerlink" title="2. 设置 AS 内 git 环境为 git-bash"></a>2. 设置 AS 内 git 环境为 git-bash</h1><p>git-bash 的命令窗口操作，界面比 cmd 或 AS Terminal 美观，功能也强大，如果想要在 AS 内使用，可以设置一下</p><p>设置路径为 Settings… -&gt; Tools -&gt; Terminal，将其中的 Shell path 设置为你电脑中 git 目录下的 X:\Program Files\Git\bin\bash.exe，注意这个是让 Terminal 直接变成 git-bash 模式的，如果直接选择 git 目录下即 X:\Program Files\Git\git-bash.exe 的话，会变成弹窗模式</p><p><a href="https://blog.csdn.net/wangsun300/article/details/105782778">参考文章</a></p><h1 id="3-git-bash-中文乱码解决方法"><a href="#3-git-bash-中文乱码解决方法" class="headerlink" title="3. git-bash 中文乱码解决方法"></a>3. git-bash 中文乱码解决方法</h1><p>打开 git-bash，输入平时常用的命令如 ipconfig、systeminfo 等，输出的结果中英文是正常的，但是中文是乱码，可以做如下操作</p><ol><li>打开 GitBash（git-bash.exe）后，对窗口右键 -&gt; Options -&gt; Text -&gt; Locale 改为 zh_CN，Character set 改为 GBK </li><li>键入 exit 退出关闭再打开即可</li></ol><p><a href="https://blog.csdn.net/jfsufeng/article/details/79219673">参考文章</a></p><h1 id="4-撤销-merge、amend"><a href="#4-撤销-merge、amend" class="headerlink" title="4. 撤销 merge、amend"></a>4. 撤销 merge、amend</h1><p>撤销上一次 merge 的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD~<br></code></pre></td></tr></table></figure><p>撤销上一次 amend</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD@&#123;1&#125;<br></code></pre></td></tr></table></figure><h1 id="5-生成-SSH-Key"><a href="#5-生成-SSH-Key" class="headerlink" title="5. 生成 SSH Key"></a>5. 生成 SSH Key</h1><p>这个也算重要和常见，但是有时一旦弄好环境，很久都不需要再次使用，所以又会记不太住，基本步骤如下：</p><ol><li>生成 ssh key <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -o</span><br></code></pre></td></tr></table></figure></li><li>进入相关目录查看文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li>输出 key 的内容 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li></ol><p>具体效果演示如下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">DDP<span class="hljs-meta">@DESKTOP-EP4ME0S</span> MINGW64 ~<br>$ ssh-keygen -o<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/DDP/.ssh/id_rsa):<br>Created directory &#x27;/c/Users/DDP/.ssh&#x27;.<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /c/Users/DDP/.ssh/id_rsa<br>Your public key has been saved in /c/Users/DDP/.ssh/id_rsa.pub<br>The key fingerprint is:<br>SHA256:kQEwgBu5dCyJVCdXtqou2dpqeUfs8hgZvL8/q9UOuqk DDP<span class="hljs-meta">@DESKTOP-EP4ME0S</span><br>The key&#x27;s randomart image is:<br>+---[RSA 3072]----+<br>|<span class="hljs-string">o+=+o+o+.        </span>|<br>|<span class="hljs-string">=+ o+.. .o       </span>|<br>|<span class="hljs-string">.+o    .o        </span>|<br>|<span class="hljs-string">o .   .  .       </span>|<br>|<span class="hljs-string">   o..  S        </span>|<br>|<span class="hljs-string">    =o  .        </span>|<br>|<span class="hljs-string">  +=o  o .       </span>|<br>|<span class="hljs-string"> =o++o+.o        </span>|<br>|<span class="hljs-string">.o=E=O=oo.       </span>|<br>+----[SHA256]-----+<br><br>DDP<span class="hljs-meta">@DESKTOP-EP4ME0S</span> MINGW64 ~<br>$ cd ~/.ssh<br><br>DDP<span class="hljs-meta">@DESKTOP-EP4ME0S</span> MINGW64 ~/.ssh<br>$ ls<br>id_rsa  id_rsa.pub<br><br>DDP<span class="hljs-meta">@DESKTOP-EP4ME0S</span> MINGW64 ~/.ssh<br>$ cat ~/.ssh/id_rsa.pub<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDDPLcVlpXBAQ0/Gld6PXI3DxvduQu0nFc06dOionC2IfEp54EJvNWizS487wQnJj1Esg8vMVr7i2sM8imc2FyP2QXb8YCIZLhtjeXDk+Ihaq62f5/CfrgZNPVOj7xk73W0AlAxmfaV5GjJGejrC0+RtHkhLxeayGMwaNZrPaRbkv0PzA7mEglN8yNenzNaheHXe2bYvrVulTXg1YZUDZlDkzo4vwbOHCevVNxol3Q3UHq903KZsW/AM17CFk2fhNxvhbtHQWtfEoBQ3xvDQJqQLXnZCMw6rFsgpXxH4oB1HmuQOlwS3M8skDj9ogVrzZx1+TM3R215bzwzaco9iQVJRB4JD7TbV6XRKYUd7pHwn5GZe5xcb9LZYkrv2QGtjsf8Rimjd6//NJ2blZ5cnQRc8eMsGSTJoigS0N3VNPfa9ERGGj1ek9yZ9ZGcQN8gOPZl0oFFTlEy0MjWCq9Vddfp4vKhmvJ8OTSQ2OvPuhHcLDKSeVvLMFYXAIcFA05kCTU= DDP<span class="hljs-meta">@DESKTOP-EP4ME0S</span><br></code></pre></td></tr></table></figure><h1 id="6-切换-ssh-和-http-协议"><a href="#6-切换-ssh-和-http-协议" class="headerlink" title="6. 切换 ssh 和 http 协议"></a>6. 切换 ssh 和 http 协议</h1><ol><li>查看当前 remote <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span><br></code></pre></td></tr></table></figure></li><li>切换到 http： <figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">https</span>://<span class="hljs-string">github</span>.<span class="hljs-string">com</span>/<span class="hljs-string">username</span>/<span class="hljs-string">repository</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure></li><li>切换到ssh： <figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">git</span>@<span class="hljs-string">github</span>.<span class="hljs-string">com:username/</span><span class="hljs-string">repository</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure></li></ol><p>也可以直接改当前 git 目录里面有个配置文件，路径是 <code>.git/config</code>，大致如下，修改 url 即可，有时候 fetch 和 push 的 url 会不一样，如果没额外写出来的话，应该就是默认一致的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[core]</span><br>    <span class="hljs-attr">repositoryformatversion</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attr">filemode</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">bare</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">logallrefupdates</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">symlinks</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">ignorecase</span> = <span class="hljs-literal">true</span><br><span class="hljs-section">[remote &quot;origin&quot;]</span><br>    <span class="hljs-attr">url</span> = git@github.com:EndeRHoshI/hoshi-blog.git<br>    <span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br><span class="hljs-section">[branch &quot;master&quot;]</span><br>    <span class="hljs-attr">remote</span> = origin<br>    <span class="hljs-attr">merge</span> = refs/heads/master<br><span class="hljs-section">[gui]</span><br>    <span class="hljs-attr">wmstate</span> = normal<br>    <span class="hljs-attr">geometry</span> = <span class="hljs-number">841</span>x483+<span class="hljs-number">156</span>+<span class="hljs-number">156</span> <span class="hljs-number">189</span> <span class="hljs-number">218</span><br><br></code></pre></td></tr></table></figure><p>据评论说不正确，暂时还未做验证，如果有问题，还可参考下面的</p><ol><li>先增加新的协议 <figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-built_in">--add</span> <span class="hljs-string">origin</span> <span class="hljs-string">https</span>://<span class="hljs-string">gitee</span>.<span class="hljs-string">com</span>/<span class="hljs-string">zjZSTU</span>/<span class="hljs-string">zjzstu</span>.<span class="hljs-string">gitee</span>.<span class="hljs-string">io</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure></li><li>再删除原先的协议 <figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-built_in">--delete</span> <span class="hljs-string">origin</span> <span class="hljs-string">git</span>@<span class="hljs-string">gitee</span>.<span class="hljs-string">com:zjZSTU/</span><span class="hljs-string">zjzstu</span>.<span class="hljs-string">gitee</span>.<span class="hljs-string">io</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure></li></ol><p><a href="https://blog.csdn.net/yimingsilence/article/details/79980070">参考文章</a></p><h1 id="7-解决-The-authenticity-of-host-‘gitee-com-180-97-125-228-’-can’t-be-established-问题"><a href="#7-解决-The-authenticity-of-host-‘gitee-com-180-97-125-228-’-can’t-be-established-问题" class="headerlink" title="7. 解决 The authenticity of host ‘gitee.com (180.97.125.228)’ can’t be established. 问题"></a>7. 解决 The authenticity of host ‘gitee.com (180.97.125.228)’ can’t be established. 问题</h1><p>具体情形如下：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">HoShI@DESKTOP-<span class="hljs-number">050</span>RN3C MINGW64 /f/RiskOfRainPhoto (master)<br>$ ssh -T git@gitee.com<br>The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-symbol">&#x27;gitee</span>.com (<span class="hljs-number">180.97</span>.<span class="hljs-number">125.228</span>)&#x27; can<span class="hljs-symbol">&#x27;t</span> be established.<br>ECDSA key fingerprint <span class="hljs-keyword">is</span> SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.<br>Are you sure you want <span class="hljs-keyword">to</span> continue connecting (yes/no)? yes<br><span class="hljs-literal">Warning</span>: Permanently added <span class="hljs-symbol">&#x27;gitee</span>.com,<span class="hljs-number">180.97</span>.<span class="hljs-number">125.228</span>&#x27; (ECDSA) <span class="hljs-keyword">to</span> the list <span class="hljs-keyword">of</span> known hosts.<br>Hi Hoshi! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GITEE.COM does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>其原因为：在新生成密钥之后，在 .ssh 文件夹中少了一个 known_hosts 文件，本来密钥文件应该是三个，现在是两个，便报了这样的错误，此时选择 yes 回车之后，便可，会生成缺少了的 known_hosts 文件</p><p><a href="https://blog.csdn.net/M_WBCG/article/details/79156781">参考文章</a></p><h1 id="8-github-action-签名问题：如何保证自己的-keystore-文件安全？"><a href="#8-github-action-签名问题：如何保证自己的-keystore-文件安全？" class="headerlink" title="8. github action 签名问题：如何保证自己的 keystore 文件安全？"></a>8. github action 签名问题：如何保证自己的 keystore 文件安全？</h1><ul><li>如果整个项目都是私有的，你不会开放它，那么你可以直接上传你的 keystore</li><li>如果你的项目是公开的，有以下两个方法<ol><li>上传一个加密过的 keystore 文件，将你的密钥写到 github secret 里面，要使用的时候再解密</li><li>上传 keystore 到一个私有库中，要使用的时候，再从私有库拉取，把私有库的凭证例如账号密码之类的写到 github secret 里面</li></ol></li></ul><h1 id="9-修改-Git-用户名或邮箱"><a href="#9-修改-Git-用户名或邮箱" class="headerlink" title="9. 修改 Git 用户名或邮箱"></a>9. 修改 Git 用户名或邮箱</h1><p>查看用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 当前项目</span><br>git config user.name<br>git config user.email<br><br><span class="hljs-comment"># 全局</span><br>git config --global user.name<br>git config --global user.email<br></code></pre></td></tr></table></figure><p>如果要修改，则直接在后面加上目标字符串，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 当前项目</span><br>git config user.name targetName<br>git config user.email targetName<br><br><span class="hljs-comment"># 全局</span><br>git config --global user.name targetName<br>git config --global user.email targetName<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/helinlin007/article/details/52266169">参考文章</a></p><h1 id="10-修改远端提交记录"><a href="#10-修改远端提交记录" class="headerlink" title="10. 修改远端提交记录"></a>10. 修改远端提交记录</h1><h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><p>修改最近一次 commit 信息，可以直接用 amend，使用后，你会进入文本编辑器，修改 commit 信息保存后就可以更新 commit 信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>修改多条 commit 信息，例如想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给 <code>git rebase -i</code> 命令，即 <code>HEAD~2</code> 或 <code>HEAD~3</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>使用上述命令后，会出现类似的界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Bash">pick f7f3f6d changed my name a bit<br>pick 310154e updated README formatting and added blame<br>pick a5f4a0d added cat-file<br><br><span class="hljs-comment"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Commands:</span><br><span class="hljs-comment">#  p, pick = use commit</span><br><span class="hljs-comment">#  r, reword = use commit, but edit the commit message</span><br><span class="hljs-comment">#  e, edit = use commit, but stop for amending</span><br><span class="hljs-comment">#  s, squash = use commit, but meld into previous commit</span><br><span class="hljs-comment">#  f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="hljs-comment">#  x, exec = run command (the rest of the line) using shell</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that empty commits are commented out</span><br></code></pre></td></tr></table></figure><p>如果你想更改第一条 commit 信息，把第一条 commit 信息对应的 pick 更改为 edit 然后 ESC + :wq 保存退出，运行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git rebase <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>运行上述命令后在弹出文本编辑界面重新提交 commit 信息，完成后保存退出。运行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">git rebase --<span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>所有的 commit 信息都修改完之后运行一下命令将更改推送到远程</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git push origin <span class="hljs-keyword">master</span> <span class="hljs-title">--force</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/carbon06/article/details/78814659">参考文章</a></p><h3 id="修改提交记录用户名"><a href="#修改提交记录用户名" class="headerlink" title="修改提交记录用户名"></a>修改提交记录用户名</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 第一步，（n）代表提交次数</span><br>git rebase -i HEAD~n<br> <br><span class="hljs-comment"># 第二步然后按`i`编辑，把`pick` 改成 `edit`，按&#x27;Esc&#x27;退出编辑，按`:wq`保存退出</span><br> <br><span class="hljs-comment"># 第三步</span><br>git commit <span class="hljs-params">--amend</span> <span class="hljs-params">--author=</span><span class="hljs-string">&quot;作者 &lt;邮箱@xxxx.com&gt;&quot;</span> <span class="hljs-params">--no-edit</span><br> <br><span class="hljs-comment"># 第四步</span><br>git rebase <span class="hljs-params">--continue</span><br> <br><span class="hljs-comment"># 第五步</span><br>git push <span class="hljs-params">--force</span><br></code></pre></td></tr></table></figure><p>要注意，如果 master 分支是受保护的，无法直接强制推上去，那就需要分开其他分支如 develop 分支，方便此类操作以及后续的分支管理</p><p><a href="https://blog.csdn.net/HDFQQ188816190/article/details/118094900">参考文章</a></p><h1 id="11-Git-远程仓库地址变更本地如何修改"><a href="#11-Git-远程仓库地址变更本地如何修改" class="headerlink" title="11. Git 远程仓库地址变更本地如何修改"></a>11. Git 远程仓库地址变更本地如何修改</h1><p>由于各种原因，作为 Git 仓库的服务器 IP 地址变了，本地代码太多，重新检出会花很多时间，这时就可以修改一下配置让本地仓库和新的远程仓库建立关联</p><p>方法有很多，这里简单介绍几种，以下均以项目 git_test 为例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">老地址：http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.12</span>:<span class="hljs-number">9797</span><span class="hljs-regexp">/hoshi/gi</span>t_test.git<br>新地址：http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">100.235</span>:<span class="hljs-number">9797</span><span class="hljs-regexp">/hoshi/gi</span>t_test.git<br>远程仓库名称： origin<br></code></pre></td></tr></table></figure><h2 id="方法一-通过命令直接修改远程地址"><a href="#方法一-通过命令直接修改远程地址" class="headerlink" title="方法一 通过命令直接修改远程地址"></a>方法一 通过命令直接修改远程地址</h2><ol><li>进入 git_test 根目录</li><li>git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址</li><li>git remote set-url origin <a href="http://192.168.100.235:9797/hoshi/git_test.git">http://192.168.100.235:9797/hoshi/git_test.git</a></li></ol><h2 id="方法二-通过命令先删除再添加远程仓库"><a href="#方法二-通过命令先删除再添加远程仓库" class="headerlink" title="方法二 通过命令先删除再添加远程仓库"></a>方法二 通过命令先删除再添加远程仓库</h2><ol><li>进入 git_test 根目录</li><li>git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址</li><li>git remote rm origin</li><li>git remote add origin <a href="http://192.168.100.235:9797/hoshi/git_test.git">http://192.168.100.235:9797/hoshi/git_test.git</a></li></ol><h2 id="方法三-直接修改配置文件"><a href="#方法三-直接修改配置文件" class="headerlink" title="方法三 直接修改配置文件"></a>方法三 直接修改配置文件</h2><ol><li>进入 git_test&#x2F;.git</li><li>vim config <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[core]</span><br><span class="hljs-attr">repositoryformatversion</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">filemode</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">logallrefupdates</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">precomposeunicode</span> = <span class="hljs-literal">true</span><br><span class="hljs-section">[remote &quot;origin&quot;]</span><br><span class="hljs-attr">url</span> = http://<span class="hljs-number">192.168</span>.<span class="hljs-number">100.235</span>:<span class="hljs-number">9797</span>/shimanqiang/assistant.git<br><span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br><span class="hljs-section">[branch &quot;master&quot;]</span><br><span class="hljs-attr">remote</span> = origin<br><span class="hljs-attr">merge</span> = refs/heads/master<br></code></pre></td></tr></table></figure></li><li>修改 [remote “origin”] 下面的 url 即可</li></ol><h2 id="方法四-通过第三方git客户端修改。"><a href="#方法四-通过第三方git客户端修改。" class="headerlink" title="方法四 通过第三方git客户端修改。"></a>方法四 通过第三方git客户端修改。</h2><p>以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件，同样可以完成方法三</p><p>摘自他人的文章，<a href="https://blog.csdn.net/asdfsfsdgdfgh/article/details/54981823">原文链接</a></p><h1 id="12-git-reflog-以及-git-reset"><a href="#12-git-reflog-以及-git-reset" class="headerlink" title="12. git reflog 以及 git reset"></a>12. git reflog 以及 git reset</h1><p>有时候我们做了一些错误的操作，可以使用 git reflog 查看操作日志以及 git reset 来进行撤回</p><ol><li>执行 <code>git reflog</code>，可以查看所有操作日志： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reflog<br><br>8dd0780f2e (HEAD -&gt; temp/extend_warranty_2) HEAD@&#123;0&#125;: rebase (<span class="hljs-built_in">continue</span>) (finish): returning to refs/heads/temp/extend_warranty_2<br>8dd0780f2e (HEAD -&gt; temp/extend_warranty_2) HEAD@&#123;1&#125;: rebase (<span class="hljs-built_in">continue</span>) (pick): 初步实现积分中心框架<br>cb5b611664 HEAD@&#123;2&#125;: rebase (<span class="hljs-built_in">continue</span>): 初步实现单设备、多设备界面框架<br>5e60393df3 HEAD@&#123;3&#125;: rebase (pick): 增加激励广告<br>cdc046373e HEAD@&#123;4&#125;: rebase (pick): 调整异步工具类；调整 Span 工具类<br>d887d18e29 HEAD@&#123;5&#125;: rebase (pick): 移除本地冗余 MagicIndicator；初步实现 πStore 页面框架<br>c894b70de3 (origin/temp/dev-7.1.5, temp/dev-7.1.5) HEAD@&#123;6&#125;: rebase (start): checkout origin/temp/dev-7.1.5<br>b89a45651b HEAD@&#123;7&#125;: reset: moving to HEAD<br>b89a45651b HEAD@&#123;8&#125;: checkout: moving from temp/dev-7.1.5 to temp/extend_warranty_2<br>c894b70de3 (origin/temp/dev-7.1.5, temp/dev-7.1.5) HEAD@&#123;9&#125;: checkout: moving from ui7.0-kotlin-lvqx to temp/dev-7.1.5<br>496ffa9056 (ui7.0-kotlin-lvqx) HEAD@&#123;10&#125;: commit (amend): 调整 Gradle 版本，初步引入 Kotlin，并编写 Kotlin 示例类<br>3d81c02df2 HEAD@&#123;11&#125;: checkout: moving from temp/dev-admin-lvqx to ui7.0-kotlin-lvqx<br>3732cde39b HEAD@&#123;12&#125;: checkout: moving from temp/extend_warranty_2 to temp/dev-admin-lvqx<br>b89a45651b HEAD@&#123;13&#125;: commit: 初步实现积分中心框架<br>d9b3616a1f HEAD@&#123;14&#125;: commit: 初步实现单设备、多设备界面框架<br>47f0792ecf HEAD@&#123;15&#125;: commit: 增加激励广告<br></code></pre></td></tr></table></figure> 仔细查看记录，比如我想撤回到从分支 dev-7.1.5 切换到 extend_warranty_2 的那个状态，即 HEAD@{8} 的内容</li><li>执行命令 <code>git reset --hard</code> 回到初始状态 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard HEAD@&#123;26&#125;<br>或者<br>git reset --hard bbc9da41b5<br></code></pre></td></tr></table></figure></li></ol><p>如果错误地使用了 git commit –amend，也就是在 AS 中提交时，手滑点了右上角的 Amend commit，导致上一次的提交被覆盖了，丢失了提交记录，或者导致分支状况不一致无法上传到远端服务器，这时就要想办法撤销掉这个错误的 amend commit，回到之前的状态，解决方法如下：</p><p>首先使用 git reflog 命令查看操作记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reflog<br>6889e84 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (amend): modified 1/2/3.txt<br>b82585f HEAD@&#123;1&#125;: commit: modified 1/2.txt<br></code></pre></td></tr></table></figure><p>然后可以看到你的 amend commit，之后再使用 git reset，其中 reset 后面的就是你在 reflog 命令中查到的 id，或者后面的 HEAD@{x}</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset b82585f<br></code></pre></td></tr></table></figure><p>不使用 <code>git reset --hard</code> 的目的就是为了保留本地修改，否则修改就会被丢弃，如果一个 commit 被 amend 了多次, 也可以用这种方法撤销到任意一次 amend 处:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reflog<br>937fd53 HEAD@&#123;0&#125;: commit (amend): add blank line to index.html<br>7589755 HEAD@&#123;1&#125;: commit (amend): add blank line to index.html<br>f7ade82 HEAD@&#123;2&#125;: commit (amend): add blank line to index.html<br>c1c1b21 HEAD@&#123;3&#125;: commit (amend): add blank line to index.html<br>9ff821d HEAD@&#123;4&#125;: commit: add blank line to index.html<br>$ git reset --soft HEAD@&#123;2&#125;<br></code></pre></td></tr></table></figure><p>由此看来，不只是 rebase 可以撤回，很多操作都可以通过这个方法撤回</p><p><a href="https://www.jianshu.com/p/e6241b7891bf">参考文章</a></p><h1 id="13-端口-22-超时"><a href="#13-端口-22-超时" class="headerlink" title="13. 端口 22 超时"></a>13. 端口 22 超时</h1><p>端口 22 超时问题，报错如下，<a href="https://blog.csdn.net/MBuger/article/details/70226712">解决方法</a>，<a href="https://www.lainme.com/doku.php/blog/2011/02/%E4%BD%BF%E7%94%A8ssh_config">另外的参考文章</a>，<a href="https://segmentfault.com/a/1190000041909858###">终极解决问题文章</a>，<a href="https://blog.csdn.net/u012102536/article/details/90751519">修改 host</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ssh: <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> host github.com port <span class="hljs-number">22</span>: <span class="hljs-keyword">Connection</span> timed <span class="hljs-keyword">out</span><br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">from</span> remote repository.<br><br>Please make sure you have the correct <span class="hljs-keyword">access</span> rights<br><span class="hljs-keyword">and</span> the repository <span class="hljs-keyword">exists</span>.<br></code></pre></td></tr></table></figure><p>注意整完之后，好像用 https 协议不行了，报错 <code>https 地址 + Failed to connect to github.com port 443 after 21077 ms: Timed out</code></p><h1 id="14-git-gc-相关问题"><a href="#14-git-gc-相关问题" class="headerlink" title="14. git gc 相关问题"></a>14. git gc 相关问题</h1><p>在对 Git 库执行一些操作命令时（比如 <code>git am</code>，<code>git pull</code>，<code>git push</code> 等操作）的时候，会出现类似如下提示（作者是在用 <code>git am</code> 打 patch 时出现的，其他情况也是一回事）：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ronny@ronny:~/tmpgitrepol$ git am ~/<span class="hljs-number">03</span>patch/kernel/<span class="hljs-number">0001</span>-<span class="hljs-built_in">add</span>-kernel-<span class="hljs-built_in">version</span>.patch <span class="hljs-comment">--keep-cr</span><br>Applying: <span class="hljs-built_in">add</span> kernel <span class="hljs-built_in">version</span> <span class="hljs-keyword">for</span> compile<br>Auto packing <span class="hljs-keyword">the</span> repository <span class="hljs-keyword">for</span> optimum performance. You may also<br>run <span class="hljs-string">&quot;git gc&quot;</span> manually. See <span class="hljs-string">&quot;git help gc&quot;</span> <span class="hljs-keyword">for</span> more information.<br>Counting objects: <span class="hljs-number">84286</span>, done.<br></code></pre></td></tr></table></figure><p>而且 <code>git am</code> 后不退出，必须要 Ctrl + C 退出。（其实是 git 在将松散对象打包，这个需要时间，没有执行完打包，所以没退出）</p><p>里面主要关心如下两句：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Auto packing the repository <span class="hljs-keyword">for</span> optimum performance. You may also<br><span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git gc&quot;</span> manually. See <span class="hljs-string">&quot;git help gc&quot;</span> <span class="hljs-keyword">for</span> more information.<br></code></pre></td></tr></table></figure><p>当有这个提示的时候，直接运行 <code>git gc</code>，就可以了。</p><p>原因：Git 往磁盘保存对象时默认使用的格式叫松散对象 (loose object) 格式。Git 时不时地将这些对象打包至一个叫 packfile 的二进制文件以节省空间并提高效率。当仓库中有太多的松散对象则就会提示你运行 <code>git gc</code></p><p>我们可以运行 <code>find .git/objects -type f</code> 命令，查看一下 objects 目录里有多少对象，然后运行 <code>git gc</code> 之后再看看剩下多少对象</p><p><code>git gc</code> 后，接下来再执行 git 命令的时候就没有出现提示的情况了</p><p>摘自他人的文章，<a href="https://blog.csdn.net/RonnyJiang/article/details/54893190">原文链接</a></p><h1 id="15-修改历史-commit"><a href="#15-修改历史-commit" class="headerlink" title="15. 修改历史 commit"></a>15. 修改历史 commit</h1><p>平时如果我们刚刚提交完，发现有问题，可以用 amend 的方法来修改上一次的提交，但是如果是前几个提交中有需要修改的地方，就要用到下面的方法</p><p>首先 <code>git rebase -i HEAD~10</code> 查看最近十条提交记录（也可以指定其他条数），会得到下面的结果：</p><p><img src="/../img/blog/Git%20%E9%80%9F%E6%9F%A5/rebase%E5%8D%81%E6%9D%A1%E6%95%B0%E6%8D%AE.png" alt="rebase十条数据"></p><p>然后我们按 i 进入编辑模式，把需要修改的那一条提交前面的 pick 改为 edit，再按 ESC 退出编辑模式，:wq 退出当前编辑器</p><p>这时我们回到终端界面，再用指令 <code>git commit --amend</code> 更新提交信息，然后 <code>git rebase --continue</code> 结束当前这条的修改，进行下一条，循环执行这两条指令，直到最后提示你 rebase successfully，就全部完成了，下面是前后对比，我把第二第三条提交的 :bugfix: 改成 :bug: 了</p><p><img src="/../img/blog/Git%20%E9%80%9F%E6%9F%A5/%E4%BF%AE%E6%94%B9%E5%89%8D.png" alt="修改前"></p><p><img src="/../img/blog/Git%20%E9%80%9F%E6%9F%A5/%E4%BF%AE%E6%94%B9%E5%90%8E.png" alt="修改后"></p>]]></content>
    
    
    <summary type="html">Git 相关日常用法查阅</summary>
    
    
    
    <category term="日常查阅" scheme="https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"/>
    
    
    <category term="git" scheme="https://enderhoshi.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 的一个 IllegalStateException 探索</title>
    <link href="https://enderhoshi.github.io/2020/01/15/OkHttp%20%E7%9A%84%E4%B8%80%E4%B8%AA%20IllegalStateException%20%E6%8E%A2%E7%B4%A2/"/>
    <id>https://enderhoshi.github.io/2020/01/15/OkHttp%20%E7%9A%84%E4%B8%80%E4%B8%AA%20IllegalStateException%20%E6%8E%A2%E7%B4%A2/</id>
    <published>2020-01-15T02:09:28.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 OkHttp 框架处理请求时，容易会有如下写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> responseBody = response.body() ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>Log.d(<span class="hljs-string">&quot;responseBody = &quot;</span> + response.body())<br></code></pre></td></tr></table></figure><p>有时候，我们会直接写 response.body()，而不会再创建一个 String 对象，如果能确保只调用一次，这个是没什么问题的，但是如果向上面那样，在 Log 中又调用了一次，或者这个方法被多次调用，而且 response 是同一个，那么就会报如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java.lang.IllegalStateException: closed<br></code></pre></td></tr></table></figure><p>那么为何 response.body().string() 只能调用一次？</p><p>拆解来看，先通过 response.body() 得到 ResponseBody 对象（是一个抽象类，在此我们不需要关心具体的实现类），然后调用 ResponseBody 的 string() 方法得到响应体的内容</p><p>分析后 body() 方法没有问题，我们往下看 string() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">string</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes(), charset().name());<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单，通过指定字符集（charset）将 byte() 方法返回的 byte[] 数组转为 String 对象，构造没有问题，继续往下看 byte() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] bytes() <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-type">BufferedSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> source();<br>  <span class="hljs-type">byte</span>[] bytes;<br>  <span class="hljs-keyword">try</span> &#123;<br>    bytes = source.readByteArray();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    Util.closeQuietly(source);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 byte() 方法中，通过 BufferedSource 接口对象读取 byte[] 数组并返回，结合上面提到的异常信息 closed，可以注意到 finally 代码块中的 Util.closeQuietly() 方法，就是在执行完后，他会默默地关闭</p><p>再来看看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeQuietly</span><span class="hljs-params">(Closeable closeable)</span> &#123;<br>  <span class="hljs-keyword">if</span> (closeable != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      closeable.close();<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException rethrown) &#123;<br>      <span class="hljs-keyword">throw</span> rethrown;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原来，上面提到的 BufferedSource 接口，根据代码文档注释，可以理解为资源缓冲区，其实现了 Closeable 接口，通过复写 close() 方法来 关闭并释放资源，接着往下看 close() 方法做了什么（在当前场景下，BufferedSource 实现类为 RealBufferedSource）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//持有的 Source 对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Source source;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">if</span> (closed) <span class="hljs-keyword">return</span>;<br>  closed = <span class="hljs-literal">true</span>;<br>  source.close();<br>  buffer.clear();<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，通过 source.close() 关闭并释放资源，说到这儿， closeQuietly() 方法的作用就不言而喻了，就是关闭 ResponseBody 子类所持有的 BufferedSource 接口对象</p><p>分析至此，我们恍然大悟：当我们第一次调用 response.body().string() 时，OkHttp 将响应体的缓冲资源返回的同时，调用 closeQuietly() 方法默默释放了资源。</p><p>如此一来，当我们再次调用 string() 方法时，依然回到上面的 byte() 方法，这一次问题就出在了 bytes &#x3D; source.readByteArray() 这行代码，继续看看 RealBufferedSource 的 readByteArray() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readByteArray() <span class="hljs-keyword">throws</span> IOException &#123;<br>  buffer.writeAll(source);<br>  <span class="hljs-keyword">return</span> buffer.readByteArray();<br>&#125;<br></code></pre></td></tr></table></figure><p>继续往下看 writeAll() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">writeAll</span><span class="hljs-params">(Source source)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">totalBytesRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> readCount; (readCount = source.read(<span class="hljs-built_in">this</span>, Segment.SIZE)) != -<span class="hljs-number">1</span>; ) &#123;<br>      totalBytesRead += readCount;<br>    &#125;<br>    <span class="hljs-keyword">return</span> totalBytesRead;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题出在 for 循环的 source.read() 这儿。还记得在上面分析 close() 方法时，其调用了 source.close() 来关闭并释放资源，那么，再次调用 read() 方法会发生什么呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">read</span><span class="hljs-params">(Buffer sink, <span class="hljs-type">long</span> byteCount)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (closed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;closed&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> buffer.read(sink, toRead);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以就抛出了上面所说的异常了，为什么要这么设计呢？因为在实际开发中，响应主体 RessponseBody 持有的资源可能会很大，所以 OkHttp 并不会将其直接保存到内存中，只是持有数据流连接，只有当我们需要时，才会从服务器获取数据并返回。同时，考虑到应用重复读取数据的可能性很小，所以将其设计为一次性流(one-shot)，读取后即“关闭并释放资源”。</p><p>原文：<a href="https://segmentfault.com/a/1190000012740215">OkHttp踩坑记：为何 response.body().string() 只能调用一次？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用 OkHttp 框架处理请求时，容易会有如下写法：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
    <category term="OkHttp" scheme="https://enderhoshi.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Android TextToSpeech 使用指南</title>
    <link href="https://enderhoshi.github.io/2019/11/25/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://enderhoshi.github.io/2019/11/25/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2019-11-25T12:06:28.000Z</published>
    <updated>2025-07-09T09:33:16.186Z</updated>
    
    <content type="html"><![CDATA[<p>最近要做一个资讯朗读功能，当用户点击播放按钮时，把文章中的文字转化成声音播报出来</p><p>搜索了一番，类似的功能实现有如下几种：</p><ol><li><a href="https://www.xfyun.cn/services/offline_tts">科大讯飞</a></li><li><a href="https://ai.baidu.com/docs#/TTS-Pricing/top">百度语音</a></li><li><a href="http://dev.hivoice.cn/sdk_download/offline_sdk.jsp">云知声</a></li><li><a href="https://developer.rokid.com/docs/3-ApiReference/openvoice-speech-api.html">ROKID</a></li><li><a href="https://cloud.google.com/text-to-speech/docs/quickstart-client-libraries?hl=zh-cn#client-libraries-install-java">Google Cloud</a></li></ol><p>以上的产品，要么就是收费，要么就是接入和维护相对这样的一个小功能来说，比较困难，性价比低，所以最后决定动用 Android 原生提供的 TextToSpeech 来处理文字转语音的功能</p><p>Android 原生的 TextToSpeech 目前已经支持中文播放，而在一些国产测试机如小米、华为、vivo上跑了 TextToSpeech 的测试 demo，也是可以播报中文的，不过只是语音引擎不一样而已</p><p>查看小米手机的系统设置，发现其默认的 tts 是小爱同学引擎，那么其实只要使用不同的引擎搭配不同的语音包，一样可以实现文字转语音功能，但是考虑到安装包大小的问题，还是老老实实使用原生的 TextToSpeech 了</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-Google%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E8%AE%BE%E7%BD%AE.png"><br><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%B0%8F%E7%B1%B3%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E8%AE%BE%E7%BD%AE.png"><br><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%8D%8E%E4%B8%BA%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E8%AE%BE%E7%BD%AE.png"></p><p>谷歌的详细设置</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E9%80%89%E9%A1%B9.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E8%B0%83%E9%80%89%E9%A1%B9.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E9%80%89%E9%A1%B9.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E9%9F%B3%E5%8C%85%E6%95%B0%E6%8D%AE.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E9%9F%B3%E5%8C%85%E5%A4%A7%E5%B0%8F.png"></p><p>小米的详细设置</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%B0%8F%E7%B1%B3%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E8%AF%A6%E7%BB%86%E8%AE%BE%E7%BD%AE.png"></p><p>华为的详细设置</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%8D%8E%E4%B8%BA%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E8%AF%A6%E7%BB%86%E8%AE%BE%E7%BD%AE.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Android%20TextToSpeech%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%8D%8E%E4%B8%BA%E5%8F%91%E9%9F%B3%E4%BA%BA%E4%B8%8B%E8%BD%BD.png"></p><p><a href="https://blog.csdn.net/yingchengyou/article/details/79591954">Android文字转语音引擎（TTS）简单比较及下载</a></p><p>工具类代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文本阅读（TTS） 管理器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lv.qx on 2019/11/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextToSpeechManager</span>(context: Context) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> ttsErrorStatus: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tts: TextToSpeech? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        tts = TextToSpeech(context) &#123; status -&gt;<br>            ttsErrorStatus = <span class="hljs-keyword">if</span> (status == TextToSpeech.SUCCESS) &#123;<br>                TextToSpeech.SUCCESS<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                TextToSpeech.ERROR<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">val</span> tts = tts<br><br>        <span class="hljs-keyword">if</span> (ttsErrorStatus == TextToSpeech.SUCCESS &amp;&amp; tts != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 默认设定语言为中文，原生的 android 貌似不支持中文。</span><br>            ttsErrorStatus = <span class="hljs-keyword">when</span> &#123;<br>                tts.availableLanguages == <span class="hljs-literal">null</span> -&gt; TextToSpeech.LANG_NOT_SUPPORTED<br>                tts.availableLanguages.contains(Locale.CHINESE) -&gt; tts.setLanguage(Locale.CHINESE)<br>                tts.availableLanguages.contains(Locale.SIMPLIFIED_CHINESE) -&gt; tts.setLanguage(Locale.SIMPLIFIED_CHINESE)<br>                tts.availableLanguages.contains(Locale.TRADITIONAL_CHINESE) -&gt; tts.setLanguage(Locale.TRADITIONAL_CHINESE)<br>                <span class="hljs-keyword">else</span> -&gt; TextToSpeech.LANG_NOT_SUPPORTED<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置音调，值越大声音越尖（女生），值越小则变成男声，默认值为 1.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setPitch</span><span class="hljs-params">(pitch: <span class="hljs-type">Float</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> tts = tts ?: <span class="hljs-keyword">return</span><br>        tts.setPitch(pitch)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置语速，默认值为 1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setSpeechRate</span><span class="hljs-params">(rate: <span class="hljs-type">Float</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> tts = tts ?: <span class="hljs-keyword">return</span><br>        tts.setSpeechRate(rate)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读文本</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> content 文本内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> utteranceProgressListener 阅读进度监听</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">speak</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        content: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        utteranceProgressListener: <span class="hljs-type">GetLastSegUtteranceProgressListener</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-keyword">val</span> tts = tts ?: <span class="hljs-keyword">return</span><br>        tts.setOnUtteranceProgressListener(utteranceProgressListener)<br><br>        <span class="hljs-keyword">when</span> (ttsErrorStatus) &#123;<br>            TextToSpeech.LANG_MISSING_DATA -&gt; showToast(R.string.voice_missing_data)<br>            TextToSpeech.LANG_NOT_SUPPORTED -&gt; showToast(R.string.voice_lang_not_supported)<br>            ANDROID_VERSION_NOT_SUPPORT -&gt; showToast(R.string.voice_android_version_not_supported)<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (tts.isSpeaking) &#123;<br>                    tts.stop()<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> textSeg = genSegment(content, <span class="hljs-number">10</span>)<br>                    utteranceProgressListener.setLastSegId(SEG_PREFIX + (textSeg.size - <span class="hljs-number">1</span>))<br>                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> textSeg.indices) &#123;<br>                        <span class="hljs-comment">// QUEUE_ADD：播放完之前的语音任务后才播报本次内容，QUEUE_FLUSH：丢弃之前的播报任务，立即播报本次内容</span><br>                        tts.speak(textSeg[i], TextToSpeech.QUEUE_ADD, <span class="hljs-literal">null</span>, SEG_PREFIX + i)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将源文本分段</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> segmentLength 每一段的长度，最大设置 3999，大于 3999 将阅读出错</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> originStr     源文本</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 分成的文本段</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">genSegment</span><span class="hljs-params">(originStr: <span class="hljs-type">String</span>, segmentLength: <span class="hljs-type">Int</span> = <span class="hljs-number">3999</span>)</span></span>: Array&lt;String?&gt; &#123;<br>        <span class="hljs-keyword">val</span> originLength = originStr.length<br>        <span class="hljs-keyword">val</span> arraySize = originLength / segmentLength + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">val</span> result = arrayOfNulls&lt;String&gt;(arraySize)<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until arraySize) &#123;<br>            result[i] = originStr.substring(i * segmentLength, min((i + <span class="hljs-number">1</span>) * segmentLength, originLength))<br>        &#125;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取得文本内容大约分钟长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getSpeechLength</span><span class="hljs-params">(content: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">val</span> totalSecond = (content.length / <span class="hljs-number">3.7</span>).toInt()<br>        <span class="hljs-keyword">return</span> totalSecond / <span class="hljs-number">60</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩展 onDone 方法的进度监听</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressLint(<span class="hljs-string">&quot;NewApi&quot;</span>)</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetLastSegUtteranceProgressListener</span> : <span class="hljs-type">UtteranceProgressListener</span>() &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastSegId = <span class="hljs-string">&quot;&quot;</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 设置最后一段的 id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setLastSegId</span><span class="hljs-params">(lastSegId: <span class="hljs-type">String</span>)</span></span> &#123;<br>            <span class="hljs-keyword">this</span>.lastSegId = lastSegId<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDone</span><span class="hljs-params">(utteranceId: <span class="hljs-type">String</span>?)</span></span> &#123;<br>            onDone(utteranceId, lastSegId == utteranceId)<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> isLastSeg 是否是最后一段</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDone</span><span class="hljs-params">(utteranceId: <span class="hljs-type">String</span>?, isLastSeg: <span class="hljs-type">Boolean</span>)</span></span><br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SEG_PREFIX = <span class="hljs-string">&quot;seg&quot;</span> <span class="hljs-comment">// 段落前缀</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROID_VERSION_NOT_SUPPORT = -<span class="hljs-number">3</span> <span class="hljs-comment">// 版本不支持</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单使用如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> ttsManager = TextToSpeechManager(<span class="hljs-keyword">this</span>)<br>···<br>ttsManager.speak(<br>    binding.voiceText.text.toString(),<br>    <span class="hljs-keyword">object</span> : TextToSpeechManager.GetLastSegUtteranceProgressListener() &#123;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStart</span><span class="hljs-params">(utteranceId: <span class="hljs-type">String</span>?)</span></span> &#123;<br>            <span class="hljs-comment">// 开始阅读</span><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStop</span><span class="hljs-params">(utteranceId: <span class="hljs-type">String</span>?, interrupted: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>            <span class="hljs-comment">// 停止阅读</span><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDone</span><span class="hljs-params">(utteranceId: <span class="hljs-type">String</span>?, isLastSeg: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>            <span class="hljs-comment">// 每一段结束时调用，通过 stop() 停止则不会调用这里</span><br>            <span class="hljs-keyword">if</span> (isLastSeg) &#123;<br>                <span class="hljs-comment">// 这里是最后一段</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(utteranceId: <span class="hljs-type">String</span>?)</span></span> &#123;<br>            <span class="hljs-comment">// 阅读出错</span><br>        &#125;<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/post/5d54caa3e51d453c2577b776">Android TTS TextToSpeek 的使用记录</a></li><li><a href="https://blog.csdn.net/hfut_why/article/details/80587630">Android 原生 TTS 的基本使用以及配合中文语音包实现中文 TTS</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近要做一个资讯朗读功能，当用户点击播放按钮时，把文章中的文字转化成声音播报出来&lt;/p&gt;
&lt;p&gt;搜索了一番，类似的功能实现有如下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.xfyun.cn/services/offline_tts&quot;&gt;科大讯飞</summary>
      
    
    
    
    <category term="日常查阅" scheme="https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>如何正确终止 forEach | Kotlin操作符（run、with、let、also、apply）的差异</title>
    <link href="https://enderhoshi.github.io/2019/11/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2%20forEach%20Kotlin%20%E6%93%8D%E4%BD%9C%E7%AC%A6(run%E3%80%81with%E3%80%81let%E3%80%81also%E3%80%81apply)%E7%9A%84%E5%B7%AE%E5%BC%82%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>https://enderhoshi.github.io/2019/11/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2%20forEach%20Kotlin%20%E6%93%8D%E4%BD%9C%E7%AC%A6(run%E3%80%81with%E3%80%81let%E3%80%81also%E3%80%81apply)%E7%9A%84%E5%B7%AE%E5%BC%82%E4%B8%8E%E9%80%89%E6%8B%A9/</id>
    <published>2019-11-14T13:16:28.000Z</published>
    <updated>2025-07-09T09:33:16.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何正确终止-forEach"><a href="#如何正确终止-forEach" class="headerlink" title="如何正确终止 forEach"></a>如何正确终止 forEach</h2><p>在一次编码中，我发现我的 forEach 函数使用 return@forEach 无法跳出遍历，而是会把所有元素都遍历完，使用 return 的话会直接跳出整个函数体，自然是不符合的，于是我做了些试验，想要得出真正跳出 forEach 遍历的方法</p><p>假设我们需要输出一个列表的一部分内容，可以用到 for 循环加个 break 来处理，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br><span class="hljs-keyword">for</span> (e <span class="hljs-keyword">in</span> list) &#123;<br>  <span class="hljs-keyword">if</span> (e &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span><br>  println(e)<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单，当 e 大于 3 时，就会跳出 for 循环，也就是说，会输出 1 和 3 两个数字：</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-for%E4%B8%AD%E6%96%AD%E7%A4%BA%E4%BE%8B.png?raw=true"></p><p>如果改成用 forEach 呢，就会是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>list.forEach &#123;<br>  <span class="hljs-keyword">if</span> (it &gt; <span class="hljs-number">3</span>) ???<br>  println(it)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 ??? 应当填写什么呢，我第一反应就写了个 return@forEach，跑起来之后发现，确实达到了我们的效果</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-forEach%E4%B8%AD%E6%96%AD%E7%A4%BA%E4%BE%8B.png?raw=true"></p><p>那么为什么我在程序中就不行呢？观察之后，我做了下面的变化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>list.forEach &#123;<br>  println(it)<br>  <span class="hljs-keyword">if</span> (it &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样之后呢，有一些细微的不同，就是会多输出一个 5 而已，因为输出了 5 才执行到 return@forEach 语句，这个也是很简单的</p><p>但是跑起来之后就不一样了，居然是下面这样的</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-forEach%E4%B8%AD%E6%96%AD%E7%A4%BA%E4%BE%8B%E5%8F%98%E4%BD%93.png?raw=true"></p><p>原来，上面的例子只是每次大于 3 的时候都跳过了，最多相当于一个 continue，而没有达到 break 的效果，也就是说，在 Lambda 表达式中，return 返回的是所在函数，return@xxx 返回的是 xxx 标签对应的代码块，由于 forEach 后面的这个 Lambda 实际上被调用了多次，因此我们没有办法像 for 循环那样直接 break</p><p>实际上我们在 Kotlin 当中用到的 forEach、map、flatMap 等等这样的高阶函数调用，都是流式数据处理的典型例子，重新理一下需求，遇到某一个大于 3 的数，我们就终止遍历，这样的代码用流式 api 写出来应该是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>list.takeWhile &#123; it &lt;= <span class="hljs-number">3</span> &#125;.forEach(::println)<br>println(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>首先通过 takeWhile 来筛选出前面连续不大于 3 的元素，也就是说一旦遇到一个大于 3 的元素我们就丢弃从这个开始所有后面的元素；接着，我们把取到的这些不大于 3 的元素通过 forEach 打印出来，这样的话，程序的效果与最开头的 for 循环 break 的实现就完全一致了</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-takeWhile%E7%94%A8%E6%B3%95.png?raw=true"></p><p>但是在 filter 的时候就调用了一次完整的 for-loop，而后面的 forEach 同样再来一遍，也就是说用传统的 for-loop 一遍搞定的事，用流式 api 写了两遍，如果条件比较复杂，出现两遍三遍的情况也是比较正常的，这样就导致了流式 api 性能会比一般 loop 差</p><p>除了性能问题，这个实现其实还不是最终的通用的实现，这里只能针对这一个数组做到类似 break 的效果，试想一下，如果我这个数组是无序的，我需要输出数字 3 之前的所有数字，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>那肯定不能用上面的写法了，下面这个应该才是最终的解决方案</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-any%E7%94%A8%E6%B3%95.png?raw=true"></p><p>或者简化为</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-any%E7%94%A8%E6%B3%95%E7%AE%80%E5%8C%96%E7%89%88.png?raw=true"></p><p>可能语义不够清晰，一下子比较难看懂，所以也可以用 run 函数写，如下：</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach-run%E7%94%A8%E6%B3%95.png?raw=true"></p><h2 id="Kotlin操作符-run、with、let、also、apply等-的差异"><a href="#Kotlin操作符-run、with、let、also、apply等-的差异" class="headerlink" title="Kotlin操作符(run、with、let、also、apply等)的差异"></a>Kotlin操作符(run、with、let、also、apply等)的差异</h2><p>上面提到了几个不同的操作符 run、apply、any、takeWhile，其中 any、takeWhile 是 Kotlin 的 _Collections 扩展中的，源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns `true` if at least one element matches the given [predicate].</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@sample</span> samples.collections.Collections.Aggregates.anyWithPredicate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">any</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Collection &amp;&amp; isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) <span class="hljs-keyword">if</span> (predicate(element)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a list containing first elements satisfying the given [predicate].</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@sample</span> samples.collections.Collections.Transformations.take</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">takeWhile</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: List&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> list = ArrayList&lt;T&gt;()<br>    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!predicate(item))<br>            <span class="hljs-keyword">break</span><br>        list.add(item)<br>    &#125;<br>    <span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><p>而 run、apply 等函数则位于 Kotlin 标准库 StandardKt.kt 中，源码位于 kotlin-stdlib-common&#x2F;kotlin 包下，基本都由内联函数 inline 修饰</p><ul><li><p>run</p><p>run 函数在标准库有两个，两个逻辑一样，但是第二个是 T 的扩展函数，入参是一个 block 函数，类型是一个 T 的扩展函数 T.()-&gt;R，无参，返回值是 R 类型 ，也可以传入 lambda 表达式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls the specified function [block] and returns its result.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    <span class="hljs-comment">// Kotlin 契约的写法，告诉编译器：</span><br>    <span class="hljs-comment">// “这个函数会在此时此处调用‘block’，并且刚好只调用一次”</span><br>    <span class="hljs-comment">// 这里不用管这一段，主要看 return 的部分</span><br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>let</p><p>仔细观察，let 函数和 run 函数的区别在于 T.let 入参传入的 block 函数，其参数是虽然是 T，返回值依旧是 R，block 在内部调用时传入 T.this，调用时用 it 调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls the specified function [block] with `this` value as its argument and returns its result.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>with</p><p>with 函数有两个入参 receiver:T，block 函数，关于 T 的扩展函数，返回 R，return receiver 运行 block 函数后的返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        allsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> receiver.block()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>also</p><p>also 函数和 let 函数的区别在于，also 返回的是自身，且入参 block 函数无返回值，和 let 一样，block 在内部调用时传入 T.this，调用时用 it 调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-meta">@SinceKotlin(<span class="hljs-string">&quot;1.1&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>apply</p><p>apply 函数十分常用，它可以轻松实现 java 的链式调用，在一些比较简单的应用场景就不用很麻烦地写 build 模式了，apply 函数和 also 函数很相似，不同的是，对于 lambda 内部，apply 函数中直接持有 T 的引用，this 可以省略，所以可以直接调用关于 T 的所有 api，而 also 持有的是外部传入的 T 的引用，用 it 表示，所以需要用 it 来调用关于 T 的所有 api</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>takeIf、takeUnless</p><p>takeIf 和 takeUnless 只是断言相反，takeIf 也是十分实用的标准函数，传入的 predicate 断言函数，返回值 Boolean，对于 takeIf 而言，符合条件则返回 T，否则返回 null</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn&#x27;t.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-meta">@SinceKotlin(<span class="hljs-string">&quot;1.1&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">takeIf</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: T? &#123;<br>    contract &#123;<br>        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (predicate(<span class="hljs-keyword">this</span>)) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-meta">@SinceKotlin(<span class="hljs-string">&quot;1.1&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">takeUnless</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: T? &#123;<br>    contract &#123;<br>        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (!predicate(<span class="hljs-keyword">this</span>)) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>repeat</p><p>repeat 标准函数可以轻松实现循环任务，time是循环的次数，action 函数指定具体循环的动作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the given function [action] specified number of [times].</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A zero-based index of current iteration is passed as a parameter to [action].</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@sample</span> samples.misc.ControlFlow.repeat</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">repeat</span><span class="hljs-params">(times: <span class="hljs-type">Int</span>, action: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    contract &#123; callsInPlace(action) &#125;<br><br>    <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until times) &#123;<br>        action(index)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用一张流传甚广的图来简单说明，就是如下这样：<br><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2forEach&Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%B7%AE%E5%BC%82/Kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6-%E9%80%89%E6%8B%A9%E8%A1%A8.png?raw=true"></p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/post/5c873ad0e51d454170785649">Kotlin StandardKt 标准库源码走一波</a></li><li><a href="https://juejin.im/post/5a1be4cc51882512a86108f8">Kotlin 操作符：run、with、let、also、apply 的差异与选择</a></li><li><a href="https://code-examples.net/zh-CN/q/2109bb4">loops foreachindexed 在Kotlin的功能循环中,如何“中断”或“继续”?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何正确终止-forEach&quot;&gt;&lt;a href=&quot;#如何正确终止-forEach&quot; class=&quot;headerlink&quot; title=&quot;如何正确终止 forEach&quot;&gt;&lt;/a&gt;如何正确终止 forEach&lt;/h2&gt;&lt;p&gt;在一次编码中，我发现我的 forEach 函</summary>
      
    
    
    
    <category term="日常查阅" scheme="https://enderhoshi.github.io/categories/%E6%97%A5%E5%B8%B8%E6%9F%A5%E9%98%85/"/>
    
    
    <category term="Kotlin" scheme="https://enderhoshi.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android 版本适配</title>
    <link href="https://enderhoshi.github.io/2019/08/12/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"/>
    <id>https://enderhoshi.github.io/2019/08/12/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/</id>
    <published>2019-08-12T09:16:28.000Z</published>
    <updated>2025-07-09T09:33:16.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子适配 Android 9.0 时，遇到一些坑，感觉适配准备得不够充分就上线，会遇到非常多的问题，而现在再过几周，Android Q 正式版就要发布了，今天 Google 宣布发布最后一个 Beta 测试版 Android Q Beta 6 了，所以适配 Android Q 的工作也要尽早完成，<a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652050165&idx=1&sn=7280b6f3d056eab106aeef8c97324dfc&chksm=808cb2b0b7fb3ba601927ccccaacd814f14dfdc306cc377bdb07b72659ddf8190cbcc0797bae&mpshare=1&scene=23&srcid=&sharer_sharetime=1565589898193&sharer_shareid=72a963f2ffe6f59cb6e70b8e4f2dbe01#rd">Android Q Beta 6 发布文章</a></p><h2 id="适配-Android-9-0-的坑"><a href="#适配-Android-9-0-的坑" class="headerlink" title="适配 Android 9.0 的坑"></a>适配 Android 9.0 的坑</h2><ul><li><a href="https://developer.android.com/about/versions/pie/android-9.0">Android 9 功能和 API</a></li></ul><h2 id="适配-Android-10-0-应当注意的事项"><a href="#适配-Android-10-0-应当注意的事项" class="headerlink" title="适配 Android 10.0 应当注意的事项"></a>适配 Android 10.0 应当注意的事项</h2><ul><li><a href="https://developer.android.google.cn/preview/">Android Q 测试版</a></li><li><a href="https://developer.android.com/preview/features">Android 10 功能和 API</a></li><li><a href="https://juejin.im/post/5cad5b7ce51d456e5a0728b0">Android Q 适配指南 让你少走一堆弯路</a></li></ul><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>总之，先搞到 Android Q 的手机或者模拟器先，可以查看<a href="https://developer.android.google.cn/preview/get?hl=zh_cn">获取 Android Q 测试版</a></p><p>成功打开 Android Q 版本的模拟器之后，先打开设置看一看，可以看到当前的系统版本号</p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%89%88%E6%9C%AC%E5%8F%B7.jpg?raw=true"></p><p><a href="https://developer.android.google.cn/preview/release-notes">支持与版本说明</a></p><p><a href="https://source.android.com/setup/start/build-numbers">代号、标记和细分版本号</a></p><p><a href="https://source.android.com/setup/build/running">关于代号官方文档</a></p><p><img src="https://github.com/EndeRHoshI/Photo/blob/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E5%9F%BA%E5%B8%A6%E7%89%88%E6%9C%AC%E5%8F%B7.jpg?raw=true"></p><p>然后直接在 Android Q 上运行应用，查看应用的运行情况，是否存在打不开，卡顿，闪退等比较明显的现象</p><p>上面的操作没问题了，于是直接把 targetSdkVersion 改为 29</p><p><a href="https://chinagdg.org/2016/01/picking-your-compilesdkversion-minsdkversion-targetsdkversion/">如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion</a></p><p>编译运行，发现出现了非常多的报错，都是类型错误，原本没有说明是可为空的对象，现在变成了可为空的，比如 Parcel 的 readString() 方法，Class 的 cast() 方法等</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-Packages%20Unavailable.jpg"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-Android%20SDK%20Manager.jpg"></p><p><a href="https://developer.android.google.cn/kotlin">使用 Kotlin 开发 Android 应用</a></p><p><a href="https://developer.android.google.cn/reference/kotlin/android/os/Parcel?hl=en#readString(">Parcel readString 可为空</a></p><p>所以要对这些可为空的对象进行处理，让代码可以正常编译运行，最后可以正常运行在 Android Q 的模拟器上</p><h2 id="扫描非-SDK-接口"><a href="#扫描非-SDK-接口" class="headerlink" title="扫描非 SDK 接口"></a>扫描非 SDK 接口</h2><p>所谓非 SDK 接口，在 iOS 开发中类似于“私有 API”，通俗的说，两者都是官方提供的接口，但前者明文包含在 SDK 中，允许开发者调用；后者出于各方面原因（比如还在测试中或是这个接口仅供系统内部调用），不鼓励甚至禁止开发者调用</p><p>当你调用了非 SDK 接口时，会有类似 Accessing hidden XXX 的日志，还指示了访问方式：直接，通过反射或通过 JNI</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E9%9D%9ESDK%E8%B0%83%E7%94%A8%E8%AD%A6%E5%91%8A.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Accessing hidden field Landroid/os/Message;-&gt;flags:I (light greylist, JNI)<br>Accessing hidden method Landroid/app/ActivityThread;-&gt;currentActivityThread()Landroid/app/ActivityThread; (dark greylist, reflection)<br></code></pre></td></tr></table></figure><ul><li>light greylisted ：包含方法和字段，它们继续在 Android P 预览版中运行，但 Google 无法保证在未来版本的平台上访问这些方法和字段</li><li>dark greylist：开发人员预览版本中无法访问的方法，这些日志消息可以使用 adb logcat 访问，并且会显示在正在运行的应用程序的 PID 下</li></ul><p>但是一个大项目到底哪里使用了这些方法，靠自己 review 代码和看日志是不现实的，谷歌官方提供了官方检查器 veridex 来检测一个 apk 中哪里使用了非 SDK 接口，<a href="https://android.googlesource.com/platform/prebuilts/runtime/+/master/appcompat">veridex下载</a></p><p>下载完毕后解压，解压后目录结构如下：</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-veridex%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9B%AE%E5%BD%95.png"></p><p>可以看到它里面包含了各名单的 txt 文件，其中 appcompat.sh 就是运行脚本</p><p>把需要扫描的 apk 放到同一目录下，使用终端 cd 到该目录，运行以下命令：(test.apk 为目标 apk，imprecise：不精确)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./appcompat.sh --dex-file=test.apk<br><br>./appcompat.sh --dex-file=test.apk &gt;&gt; happy.txt<br><br>./appcompat.sh --dex-file=test.apk --imprecise &gt;&gt; happy2.txt<br></code></pre></td></tr></table></figure><p>对项目中的条目分类了一下，得到如下列表，观察详细内容，发现 veridex 把 Android 自己调用的也检测出来了</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs txt">Rxjava:<br><br>#2: Linking greylist Lsun/misc/Unsafe;-&gt;arrayBaseOffset(Ljava/lang/Class;)I use(s): (io.reactivex:rxjava:1.2.1@jar)<br>       Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray;-&gt;&lt;clinit&gt;()V<br>       Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;&lt;clinit&gt;()V<br>       Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;&lt;clinit&gt;()V<br>       Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;&lt;clinit&gt;()V<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;&lt;clinit&gt;()V<br><br>#3: Linking greylist Lsun/misc/Unsafe;-&gt;arrayIndexScale(Ljava/lang/Class;)I use(s): (io.reactivex:rxjava:1.2.1@jar)<br>       Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray;-&gt;&lt;clinit&gt;()V<br>       Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;&lt;clinit&gt;()V<br>       Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;&lt;clinit&gt;()V<br>       Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;&lt;clinit&gt;()V<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;&lt;clinit&gt;()V<br><br>#5: Linking greylist Lsun/misc/Unsafe;-&gt;compareAndSwapLong(Ljava/lang/Object;JJJ)Z use(s):<br>       Lcom/google/common/cache/Striped64$Cell;-&gt;a(JJ)Z<br>       Lcom/google/common/cache/Striped64;-&gt;b(JJ)Z<br>       Lrx/internal/util/unsafe/MpmcArrayQueueConsumerField;-&gt;b(JJ)Z<br>       Lrx/internal/util/unsafe/MpmcArrayQueueProducerField;-&gt;c(JJ)Z<br>       Lrx/internal/util/unsafe/SpmcArrayQueueConsumerField;-&gt;b(JJ)Z<br><br>#6: Linking greylist Lsun/misc/Unsafe;-&gt;compareAndSwapObject(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z use(s):<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture;Lcom/google/common/util/concurrent/AbstractFuture$Listener;Lcom/google/common/util/concurrent/AbstractFuture$Listener;)Z<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture;Lcom/google/common/util/concurrent/AbstractFuture$Waiter;Lcom/google/common/util/concurrent/AbstractFuture$Waiter;)Z<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture;Ljava/lang/Object;Ljava/lang/Object;)Z<br>       Lrx/internal/util/unsafe/MpscLinkedQueue;-&gt;c(Lrx/internal/util/atomic/LinkedQueueNode;)Lrx/internal/util/atomic/LinkedQueueNode;<br><br>#8: Linking greylist Lsun/misc/Unsafe;-&gt;getLongVolatile(Ljava/lang/Object;J)J use(s):<br>       Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;a([JJ)J<br>       Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;a()J<br>       Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;b()J<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a()J<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;b()J<br><br>#9: Linking greylist Lsun/misc/Unsafe;-&gt;getObject(Ljava/lang/Object;J)Ljava/lang/Object; use(s):<br>       Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;a([Ljava/lang/Object;J)Ljava/lang/Object;<br><br>#10: Linking greylist Lsun/misc/Unsafe;-&gt;getObjectVolatile(Ljava/lang/Object;J)Ljava/lang/Object; use(s):<br>       Lrx/internal/util/unsafe/BaseLinkedQueueConsumerNodeRef;-&gt;a()Lrx/internal/util/atomic/LinkedQueueNode;<br>       Lrx/internal/util/unsafe/BaseLinkedQueueProducerNodeRef;-&gt;c()Lrx/internal/util/atomic/LinkedQueueNode;<br>       Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;b([Ljava/lang/Object;J)Ljava/lang/Object;<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a([Ljava/lang/Object;J)Ljava/lang/Object;<br><br>#12: Linking greylist Lsun/misc/Unsafe;-&gt;objectFieldOffset(Ljava/lang/reflect/Field;)J use(s):<br>       Lcom/google/common/cache/Striped64$Cell;-&gt;&lt;clinit&gt;()V<br>       Lcom/google/common/cache/Striped64;-&gt;&lt;clinit&gt;()V (2 occurrences)<br>       Lcom/google/common/hash/Striped64$Cell;-&gt;&lt;clinit&gt;()V<br>       Lcom/google/common/hash/Striped64;-&gt;&lt;clinit&gt;()V (2 occurrences)<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;&lt;clinit&gt;()V (5 occurrences)<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;&lt;clinit&gt;()V (2 occurrences)<br>       Lrx/internal/util/unsafe/UnsafeAccess;-&gt;a(Ljava/lang/Class;Ljava/lang/String;)J<br><br>#13: Linking greylist Lsun/misc/Unsafe;-&gt;putObject(Ljava/lang/Object;JLjava/lang/Object;)V use(s):<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture$Waiter;Lcom/google/common/util/concurrent/AbstractFuture$Waiter;)V<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;a(Lcom/google/common/util/concurrent/AbstractFuture$Waiter;Ljava/lang/Thread;)V<br>       Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;a([Ljava/lang/Object;JLjava/lang/Object;)V<br><br>#14: Linking greylist Lsun/misc/Unsafe;-&gt;putOrderedLong(Ljava/lang/Object;JJ)V use(s):<br>       Lrx/internal/util/unsafe/ConcurrentSequencedCircularArrayQueue;-&gt;a([JJJ)V<br>       Lrx/internal/util/unsafe/SpmcArrayQueueProducerField;-&gt;d(J)V<br>       Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;d(J)V<br>       Lrx/internal/util/unsafe/SpscArrayQueue;-&gt;e(J)V<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a(J)V<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;b(J)V<br><br>#15: Linking greylist Lsun/misc/Unsafe;-&gt;putOrderedObject(Ljava/lang/Object;JLjava/lang/Object;)V use(s):<br>       Lrx/internal/util/unsafe/ConcurrentCircularArrayQueue;-&gt;b([Ljava/lang/Object;JLjava/lang/Object;)V<br>       Lrx/internal/util/unsafe/SpscUnboundedArrayQueue;-&gt;a([Ljava/lang/Object;JLjava/lang/Object;)V<br><br>Google:<br><br>#4: Linking greylist Lsun/misc/Unsafe;-&gt;compareAndSwapInt(Ljava/lang/Object;JII)Z use(s):<br>       Lcom/google/common/cache/Striped64;-&gt;c()Z<br><br>#7: Linking greylist Lsun/misc/Unsafe;-&gt;getLong(Ljava/lang/Object;J)J use(s):<br>       Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray$1;-&gt;a([BI)J<br>       Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray$2;-&gt;a([BI)J<br>       Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;a([B[B)I (2 occurrences)<br><br>#11: Linking greylist Lsun/misc/Unsafe;-&gt;getUnsafe()Lsun/misc/Unsafe; use(s):<br>       Lcom/google/common/cache/Striped64;-&gt;a()Lsun/misc/Unsafe;<br>       Lcom/google/common/hash/LittleEndianByteArray$UnsafeByteArray;-&gt;c()Lsun/misc/Unsafe;<br>       Lcom/google/common/hash/Striped64;-&gt;a()Lsun/misc/Unsafe;<br>       Lcom/google/common/primitives/UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator;-&gt;a()Lsun/misc/Unsafe;<br>       Lcom/google/common/util/concurrent/AbstractFuture$UnsafeAtomicHelper;-&gt;&lt;clinit&gt;()V<br><br>AndroidX<br><br>#16: Reflection greylist-max-p Landroid/animation/LayoutTransition;-&gt;cancel use(s):<br>       Landroidx/transition/ViewGroupUtilsApi14;-&gt;a(Landroid/animation/LayoutTransition;)V<br><br>#21: Reflection greylist Landroid/app/Dialog;-&gt;mOnKeyListener use(s):<br>       Landroidx/core/view/KeyEventDispatcher;-&gt;a(Landroid/app/Dialog;)Landroid/content/DialogInterface$OnKeyListener;<br><br>#29: Reflection greylist Landroid/content/res/Resources;-&gt;mResourcesImpl use(s):<br>       Landroidx/appcompat/app/ResourcesFlusher;-&gt;d(Landroid/content/res/Resources;)V<br><br>#30: Reflection greylist Landroid/graphics/Typeface;-&gt;createFromFamiliesWithDefault use(s):<br>       Landroidx/core/graphics/TypefaceCompatApi24Impl;-&gt;&lt;clinit&gt;()V<br>       Landroidx/core/graphics/TypefaceCompatApi26Impl;-&gt;f(Ljava/lang/Class;)Ljava/lang/reflect/Method;<br>       Landroidx/core/graphics/TypefaceCompatApi28Impl;-&gt;f(Ljava/lang/Class;)Ljava/lang/reflect/Method;<br><br>#31: Reflection greylist Landroid/media/session/MediaSession;-&gt;getCallingPackage use(s):<br>       Landroid/support/v4/media/session/MediaSessionCompatApi24;-&gt;a(Ljava/lang/Object;)Ljava/lang/String;<br><br>#33: Reflection greylist Landroid/os/Bundle;-&gt;getIBinder use(s):<br>       Landroidx/core/app/BundleCompat$BundleCompatBaseImpl;-&gt;a(Landroid/os/Bundle;Ljava/lang/String;)Landroid/os/IBinder;<br><br>#34: Reflection greylist Landroid/os/Bundle;-&gt;putIBinder use(s):<br>       Landroidx/core/app/BundleCompat$BundleCompatBaseImpl;-&gt;a(Landroid/os/Bundle;Ljava/lang/String;Landroid/os/IBinder;)V<br><br>#35: Reflection greylist Landroid/service/media/MediaBrowserService$Result;-&gt;mFlags use(s):<br>       Landroidx/media/MediaBrowserServiceCompatApi26;-&gt;&lt;clinit&gt;()V<br><br>#45: Reflection greylist Landroid/view/LayoutInflater;-&gt;mFactory2 use(s):<br>       Landroidx/core/view/LayoutInflaterCompat;-&gt;b(Landroid/view/LayoutInflater;Landroid/view/LayoutInflater$Factory2;)V<br><br>#46: Reflection greylist Landroid/view/View;-&gt;computeFitSystemWindows use(s):<br>       Landroidx/appcompat/widget/ViewUtils;-&gt;&lt;clinit&gt;()V<br><br>#47: Reflection greylist Landroid/view/View;-&gt;mAccessibilityDelegate use(s):<br>       Landroidx/core/view/ViewCompat;-&gt;b(Landroid/view/View;)Z<br><br>#49: Reflection greylist-max-p Landroid/view/View;-&gt;mViewFlags use(s):<br>       Landroidx/transition/ViewUtils;-&gt;a()V<br><br>#50: Reflection greylist-max-p Landroid/view/animation/Animation;-&gt;mListener use(s):<br>       Landroidx/fragment/app/FragmentManagerImpl;-&gt;a(Landroid/view/animation/Animation;)Landroid/view/animation/Animation$AnimationListener;<br><br>#51: Reflection greylist Landroid/widget/AbsListView;-&gt;mIsChildViewEnabled use(s):<br>       Landroidx/appcompat/widget/DropDownListView;-&gt;&lt;init&gt;(Landroid/content/Context;Z)V<br><br>#52: Reflection greylist-max-p Landroid/widget/AutoCompleteTextView;-&gt;doAfterTextChanged use(s):<br>       Landroidx/appcompat/widget/SearchView$AutoCompleteTextViewReflector;-&gt;&lt;init&gt;()V<br><br>#53: Reflection greylist-max-p Landroid/widget/AutoCompleteTextView;-&gt;doBeforeTextChanged use(s):<br>       Landroidx/appcompat/widget/SearchView$AutoCompleteTextViewReflector;-&gt;&lt;init&gt;()V<br><br>#54: Reflection greylist-max-p Landroid/widget/AutoCompleteTextView;-&gt;ensureImeVisible use(s):<br>       Landroidx/appcompat/widget/SearchView$AutoCompleteTextViewReflector;-&gt;&lt;init&gt;()V<br><br>#65: Reflection greylist Ljava/lang/Thread;-&gt;inheritableThreadLocals use(s):<br>       Lcom/google/common/base/internal/Finalizer;-&gt;b()Ljava/lang/reflect/Field;<br><br>#66: Reflection greylist Llibcore/icu/ICU;-&gt;addLikelySubtags use(s):<br>       Landroidx/core/text/ICUCompat;-&gt;&lt;clinit&gt;()V<br><br>#67: Reflection greylist Lsun/misc/Unsafe;-&gt;allocateInstance use(s):<br>       Lcom/google/gson/internal/UnsafeAllocator;-&gt;create()Lcom/google/gson/internal/UnsafeAllocator;<br><br>#68: Reflection greylist Lsun/misc/Unsafe;-&gt;theUnsafe use(s):<br>       Lcom/google/gson/internal/UnsafeAllocator;-&gt;create()Lcom/google/gson/internal/UnsafeAllocator;<br>       Lrx/internal/util/unsafe/UnsafeAccess;-&gt;&lt;clinit&gt;()V<br><br>68 hidden API(s) used: 15 linked against, 53 through reflection<br>       60 in greylist<br>       0 in blacklist<br>       0 in greylist-max-o<br>       8 in greylist-max-p<br>To run an analysis that can give more reflection accesses, <br>but could include false positives, pass the --imprecise flag. <br></code></pre></td></tr></table></figure><ul><li>greylist: 灰名单，即当前版本仍能使用的非 SDK 接口，但在下一版本中可能变成被限制的非 SDK 接口</li><li>blacklist：黑名单，使用了就会报错。也是我们项目中必须解决的非 SDK 接口</li><li>greylist-max-o： 在 targetSDK&lt;&#x3D;O 中能使用，但是在 targetSDK&gt;&#x3D;P 中被限制的非 SDK 接口</li><li>greylist-max-p： 在 targetSDK&lt;&#x3D;P 中能使用，但是在 targetSDK&gt;&#x3D;Q 中被限制的非 SDK 接口</li></ul><h3 id="使用非官方-API-的后果"><a href="#使用非官方-API-的后果" class="headerlink" title="使用非官方 API 的后果"></a>使用非官方 API 的后果</h3><p>在 Developer Preview 的后续版本中，访问非 SDK 接口的各种方法都会产生错误或其他不良结果，下面列出了几种示例：</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E9%9D%9ESDK%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8%E5%86%85%E8%AD%A6%E5%91%8A.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AE%98%E6%96%B9API%E7%9A%84%E5%90%8E%E6%9E%9C.png"></p><h2 id="Android-Q-暗黑模式适配"><a href="#Android-Q-暗黑模式适配" class="headerlink" title="Android Q 暗黑模式适配"></a>Android Q 暗黑模式适配</h2><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2.gif"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查当前系统是否已开启暗黑模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDarkModeStatus</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>  <span class="hljs-keyword">val</span> mode = context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK<br>  <span class="hljs-keyword">return</span> mode == Configuration.UI_MODE_NIGHT_YES<br>&#125;<br></code></pre></td></tr></table></figure><p>在需要跟随夜间模式的 Activity 中添加 <code>android:configChanges=&quot;uiMode&quot;</code> 选项，并重写 onConfigurationChanged() 方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;activity<br>    android:name=<span class="hljs-string">&quot;.TestActivity&quot;</span><br>    android:configChanges=<span class="hljs-string">&quot;uiMode&quot;</span> /&gt;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onConfigurationChanged</span><span class="hljs-params">(newConfig: <span class="hljs-type">Configuration</span>)</span></span> &#123;<br>  <span class="hljs-keyword">super</span>.onConfigurationChanged(newConfig)<br>  <span class="hljs-keyword">when</span> (newConfig.uiMode and Configuration.UI_MODE_NIGHT_MASK) &#123;<br>    Configuration.UI_MODE_NIGHT_YES -&gt; &#123;<br>        <span class="hljs-comment">// 暗黑模式开启</span><br>    &#125;<br>    Configuration.UI_MODE_NIGHT_NO -&gt; &#123;<br>        <span class="hljs-comment">// 暗黑模已关闭</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://developer.android.com/guide/topics/resources/runtime-changes?hl=zh-cn">关于 configChanges</a></p><h2 id="Android-Q-全面屏及手势适配"><a href="#Android-Q-全面屏及手势适配" class="headerlink" title="Android Q 全面屏及手势适配"></a>Android Q 全面屏及手势适配</h2><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E6%9C%AA%E9%80%82%E9%85%8D%E5%85%A8%E9%9D%A2%E5%B1%8F%E5%AF%B9%E6%AF%94.png"></p><p>左图 18.5:9 设备上最大纵横比设置为 16:9 的应用</p><p>右图 18.5:9 设备上最大纵横比设置为 18.5:9 的应用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 适配全面屏 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.max_aspect&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;2.22&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>建议将应用设计为支持 2.1 或更高的纵横比，如果未设置任何值，并且 <code>android:resizeableActivity</code> 不为 true，则最大纵横比默认为 1.86（大约相当于 16:9），应用将无法充分利用额外的屏幕空间</p><p>打开全面屏：</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E6%89%8B%E5%8A%BF%E5%88%87%E6%8D%A2.gif"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4.png"></p><p>这张图片基本上指的是过去这么长时间，一般应用可以利用的在屏幕上的一个所谓的“安全范围”，在 Android Q 上，我们首先建议大家去考虑使用最下面的导航栏区域</p><p>在没有适配全面屏的应用中，会看到如下效果：</p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E5%85%A8%E9%9D%A2%E5%B1%8F%E5%AF%BC%E8%88%AA%E6%A0%8F.png"></p><p><a href="https://developer.android.com/preview/features/gesturalnav#conflicting-gestures">官方文档</a></p><p><a href="https://sspai.com/post/55638">手势操作再添新机制，Android Q Beta 5 更新详解 | 剧透</a></p><p><a href="https://juejin.im/post/5ce8e413f265da1b9253b680#heading-11">Android Q Labs | Android Q 手势导航</a></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%95%E9%83%A8.png"></p><p><img src="https://raw.githubusercontent.com/EndeRHoshI/Photo/master/blog/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/Android%20%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D-%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%BA%95%E9%83%A8.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前阵子适配 Android 9.0 时，遇到一些坑，感觉适配准备得不够充分就上线，会遇到非常多的问题，而现在再过几周，Android Q 正</summary>
      
    
    
    
    <category term="开发记录" scheme="https://enderhoshi.github.io/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="https://enderhoshi.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
